"use strict";
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
const obsidian = require("obsidian");
require("events");
require("console");
function noop() {
}
const identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value2;
  subscribe(store, (_) => value2 = _)();
  return value2;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function split_css_unit(value2) {
  const split = typeof value2 === "string" && value2.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || "px"] : [value2, "px"];
}
const contenteditable_truthy_values = ["", true, 1, "true", "contenteditable"];
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
let is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function upper_bound(low, high, key, value2) {
  while (low < high) {
    const mid = low + (high - low >> 1);
    if (key(mid) <= value2) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function init_hydrate(target) {
  if (target.hydrate_init)
    return;
  target.hydrate_init = true;
  let children2 = target.childNodes;
  if (target.nodeName === "HEAD") {
    const myChildren = [];
    for (let i = 0; i < children2.length; i++) {
      const node = children2[i];
      if (node.claim_order !== void 0) {
        myChildren.push(node);
      }
    }
    children2 = myChildren;
  }
  const m = new Int32Array(children2.length + 1);
  const p = new Int32Array(children2.length);
  m[0] = -1;
  let longest = 0;
  for (let i = 0; i < children2.length; i++) {
    const current = children2[i].claim_order;
    const seqLen = (longest > 0 && children2[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, (idx) => children2[m[idx]].claim_order, current)) - 1;
    p[i] = m[seqLen] + 1;
    const newLen = seqLen + 1;
    m[newLen] = i;
    longest = Math.max(newLen, longest);
  }
  const lis = [];
  const toMove = [];
  let last = children2.length - 1;
  for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
    lis.push(children2[cur - 1]);
    for (; last >= cur; last--) {
      toMove.push(children2[last]);
    }
    last--;
  }
  for (; last >= 0; last--) {
    toMove.push(children2[last]);
  }
  lis.reverse();
  toMove.sort((a, b) => a.claim_order - b.claim_order);
  for (let i = 0, j = 0; i < toMove.length; i++) {
    while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
      j++;
    }
    const anchor = j < lis.length ? lis[j] : null;
    target.insertBefore(toMove[i], anchor);
  }
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function append_hydration(target, node) {
  if (is_hydrating) {
    init_hydrate(target);
    if (target.actual_end_child === void 0 || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {
      target.actual_end_child = target.firstChild;
    }
    while (target.actual_end_child !== null && target.actual_end_child.claim_order === void 0) {
      target.actual_end_child = target.actual_end_child.nextSibling;
    }
    if (node !== target.actual_end_child) {
      if (node.claim_order !== void 0 || node.parentNode !== target) {
        target.insertBefore(node, target.actual_end_child);
      }
    } else {
      target.actual_end_child = node.nextSibling;
    }
  } else if (node.parentNode !== target || node.nextSibling !== null) {
    target.appendChild(node);
  }
}
function insert_hydration(target, node, anchor) {
  if (is_hydrating && !anchor) {
    append_hydration(target, node);
  } else if (node.parentNode !== target || node.nextSibling != anchor) {
    target.insertBefore(node, anchor || null);
  }
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value2) {
  if (value2 == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2)
    node.setAttribute(attribute, value2);
}
function to_number(value2) {
  return value2 === "" ? null : +value2;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function init_claim_info(nodes) {
  if (nodes.claim_info === void 0) {
    nodes.claim_info = { last_index: 0, total_claimed: 0 };
  }
}
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
  init_claim_info(nodes);
  const resultNode = (() => {
    for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
      const node = nodes[i];
      if (predicate(node)) {
        const replacement = processNode(node);
        if (replacement === void 0) {
          nodes.splice(i, 1);
        } else {
          nodes[i] = replacement;
        }
        if (!dontUpdateLastIndex) {
          nodes.claim_info.last_index = i;
        }
        return node;
      }
    }
    for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
      const node = nodes[i];
      if (predicate(node)) {
        const replacement = processNode(node);
        if (replacement === void 0) {
          nodes.splice(i, 1);
        } else {
          nodes[i] = replacement;
        }
        if (!dontUpdateLastIndex) {
          nodes.claim_info.last_index = i;
        } else if (replacement === void 0) {
          nodes.claim_info.last_index--;
        }
        return node;
      }
    }
    return createNode();
  })();
  resultNode.claim_order = nodes.claim_info.total_claimed;
  nodes.claim_info.total_claimed += 1;
  return resultNode;
}
function claim_element_base(nodes, name, attributes, create_element) {
  return claim_node(nodes, (node) => node.nodeName === name, (node) => {
    const remove = [];
    for (let j = 0; j < node.attributes.length; j++) {
      const attribute = node.attributes[j];
      if (!attributes[attribute.name]) {
        remove.push(attribute.name);
      }
    }
    remove.forEach((v) => node.removeAttribute(v));
    return void 0;
  }, () => create_element(name));
}
function claim_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
  return claim_node(
    nodes,
    (node) => node.nodeType === 3,
    (node) => {
      const dataStr = "" + data;
      if (node.data.startsWith(dataStr)) {
        if (node.data.length !== dataStr.length) {
          return node.splitText(dataStr.length);
        }
      } else {
        node.data = dataStr;
      }
    },
    () => text(data),
    true
  );
}
function claim_space(nodes) {
  return claim_text(nodes, " ");
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_data_contenteditable(text2, data) {
  data = "" + data;
  if (text2.wholeText === data)
    return;
  text2.data = data;
}
function set_data_maybe_contenteditable(text2, data, attr_value) {
  if (~contenteditable_truthy_values.indexOf(attr_value)) {
    set_data_contenteditable(text2, data);
  } else {
    set_data(text2, data);
  }
}
function set_input_value(input, value2) {
  input.value = value2 == null ? "" : value2;
}
function set_style(node, key, value2, important) {
  if (value2 == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value2, important ? "important" : "");
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    start: start_time = now() + delay,
    end = start_time + duration,
    tick = noop,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t, 1 - t);
    }
    return true;
  });
  start();
  tick(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
function add_transform(node, a) {
  const b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function claim_component(block, parent_nodes) {
  block && block.l(parent_nodes);
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value2);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [xValue, xUnit] = split_css_unit(x);
  const [yValue, yUnit] = split_css_unit(y);
  return {
    delay,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}
const Designer$1 = "";
function create_fragment$n(ctx) {
  let div13;
  let section0;
  let div0;
  let pre;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let t3;
  let section1;
  let div12;
  let div5;
  let div3;
  let t4;
  let t5;
  let div4;
  let input0;
  let t6;
  let select;
  let option0;
  let t7;
  let option1;
  let t8;
  let option2;
  let t9;
  let t10;
  let div8;
  let div6;
  let t11;
  let t12;
  let div7;
  let input1;
  let t13;
  let div11;
  let div9;
  let t14;
  let t15;
  let div10;
  let input2;
  return {
    c() {
      div13 = element("div");
      section0 = element("section");
      div0 = element("div");
      pre = element("pre");
      t0 = text("				Grobax' TTRPG.\n				Make a ```TTRPG ``` block in an article. then you get to setup your block.\n				choosing a system, and then a UI for that system.\n\n				There are a standard Layouts, but you are able to use editing systems to change the layout,\n				You can use the Edit button to change single view settings.\n				The layout is made up of rows, then columns, then items in rows.\n				You can use edit rows to add, delete and switch the placing of these rows along with their contents.\n\n				You can use edit columns to add, delete and switch places of columns and their items. \n\n				You can use edit Items to add, delete items in the columns, you can also asign an item a view, as well as drag them into other columns. \n				in this mode you are also given access to buttons to manouver the item's position in that column.\n			");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = text("IMAGE");
      t3 = space();
      section1 = element("section");
      div12 = element("div");
      div5 = element("div");
      div3 = element("div");
      t4 = text("Setting 1");
      t5 = space();
      div4 = element("div");
      input0 = element("input");
      t6 = space();
      select = element("select");
      option0 = element("option");
      t7 = text("px");
      option1 = element("option");
      t8 = text("em");
      option2 = element("option");
      t9 = text("%");
      t10 = space();
      div8 = element("div");
      div6 = element("div");
      t11 = text("Setting 2");
      t12 = space();
      div7 = element("div");
      input1 = element("input");
      t13 = space();
      div11 = element("div");
      div9 = element("div");
      t14 = text("Setting 3");
      t15 = space();
      div10 = element("div");
      input2 = element("input");
      this.h();
    },
    l(nodes) {
      div13 = claim_element(nodes, "DIV", { class: true });
      var div13_nodes = children(div13);
      section0 = claim_element(div13_nodes, "SECTION", { class: true });
      var section0_nodes = children(section0);
      div0 = claim_element(section0_nodes, "DIV", {});
      var div0_nodes = children(div0);
      pre = claim_element(div0_nodes, "PRE", {});
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "				Grobax' TTRPG.\n				Make a ```TTRPG ``` block in an article. then you get to setup your block.\n				choosing a system, and then a UI for that system.\n\n				There are a standard Layouts, but you are able to use editing systems to change the layout,\n				You can use the Edit button to change single view settings.\n				The layout is made up of rows, then columns, then items in rows.\n				You can use edit rows to add, delete and switch the placing of these rows along with their contents.\n\n				You can use edit columns to add, delete and switch places of columns and their items. \n\n				You can use edit Items to add, delete items in the columns, you can also asign an item a view, as well as drag them into other columns. \n				in this mode you are also given access to buttons to manouver the item's position in that column.\n			");
      pre_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t1 = claim_space(section0_nodes);
      div2 = claim_element(section0_nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "IMAGE");
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      section0_nodes.forEach(detach);
      t3 = claim_space(div13_nodes);
      section1 = claim_element(div13_nodes, "SECTION", {});
      var section1_nodes = children(section1);
      div12 = claim_element(section1_nodes, "DIV", { class: true });
      var div12_nodes = children(div12);
      div5 = claim_element(div12_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div3 = claim_element(div5_nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      t4 = claim_text(div3_nodes, "Setting 1");
      div3_nodes.forEach(detach);
      t5 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true, style: true });
      var div4_nodes = children(div4);
      input0 = claim_element(div4_nodes, "INPUT", { type: true });
      t6 = claim_space(div4_nodes);
      select = claim_element(div4_nodes, "SELECT", {});
      var select_nodes = children(select);
      option0 = claim_element(select_nodes, "OPTION", {});
      var option0_nodes = children(option0);
      t7 = claim_text(option0_nodes, "px");
      option0_nodes.forEach(detach);
      option1 = claim_element(select_nodes, "OPTION", {});
      var option1_nodes = children(option1);
      t8 = claim_text(option1_nodes, "em");
      option1_nodes.forEach(detach);
      option2 = claim_element(select_nodes, "OPTION", {});
      var option2_nodes = children(option2);
      t9 = claim_text(option2_nodes, "%");
      option2_nodes.forEach(detach);
      select_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      t10 = claim_space(div12_nodes);
      div8 = claim_element(div12_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      div6 = claim_element(div8_nodes, "DIV", { class: true, style: true });
      var div6_nodes = children(div6);
      t11 = claim_text(div6_nodes, "Setting 2");
      div6_nodes.forEach(detach);
      t12 = claim_space(div8_nodes);
      div7 = claim_element(div8_nodes, "DIV", { class: true, style: true });
      var div7_nodes = children(div7);
      input1 = claim_element(div7_nodes, "INPUT", { type: true });
      div7_nodes.forEach(detach);
      div8_nodes.forEach(detach);
      t13 = claim_space(div12_nodes);
      div11 = claim_element(div12_nodes, "DIV", { class: true });
      var div11_nodes = children(div11);
      div9 = claim_element(div11_nodes, "DIV", { class: true, style: true });
      var div9_nodes = children(div9);
      t14 = claim_text(div9_nodes, "Setting 3");
      div9_nodes.forEach(detach);
      t15 = claim_space(div11_nodes);
      div10 = claim_element(div11_nodes, "DIV", { class: true, style: true });
      var div10_nodes = children(div10);
      input2 = claim_element(div10_nodes, "INPUT", { type: true });
      div10_nodes.forEach(detach);
      div11_nodes.forEach(detach);
      div12_nodes.forEach(detach);
      section1_nodes.forEach(detach);
      div13_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "MainAppContainerPageTextImageSectionImage");
      attr(section0, "class", "MainAppContainerPageTextImageSection");
      attr(div3, "class", "tableRowColumn");
      set_style(div3, "float", "left");
      attr(input0, "type", "number");
      input0.value = "12";
      option0.__value = "px";
      option0.value = option0.__value;
      option0.selected = true;
      option1.__value = "em";
      option1.value = option1.__value;
      option2.__value = "%";
      option2.value = option2.__value;
      attr(div4, "class", "tableRowColumn");
      set_style(div4, "float", "right");
      attr(div5, "class", "tableRow");
      attr(div6, "class", "tableRowColumn");
      set_style(div6, "float", "left");
      attr(input1, "type", "checkbox");
      attr(div7, "class", "tableRowColumn");
      set_style(div7, "float", "right");
      attr(div8, "class", "tableRow");
      attr(div9, "class", "tableRowColumn");
      set_style(div9, "float", "left");
      attr(input2, "type", "checkbox");
      attr(div10, "class", "tableRowColumn");
      set_style(div10, "float", "right");
      attr(div11, "class", "tableRow");
      attr(div12, "class", "table ");
      attr(div13, "class", "MainAppContainerPage");
    },
    m(target, anchor) {
      insert_hydration(target, div13, anchor);
      append_hydration(div13, section0);
      append_hydration(section0, div0);
      append_hydration(div0, pre);
      append_hydration(pre, t0);
      append_hydration(section0, t1);
      append_hydration(section0, div2);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
      append_hydration(div13, t3);
      append_hydration(div13, section1);
      append_hydration(section1, div12);
      append_hydration(div12, div5);
      append_hydration(div5, div3);
      append_hydration(div3, t4);
      append_hydration(div5, t5);
      append_hydration(div5, div4);
      append_hydration(div4, input0);
      append_hydration(div4, t6);
      append_hydration(div4, select);
      append_hydration(select, option0);
      append_hydration(option0, t7);
      append_hydration(select, option1);
      append_hydration(option1, t8);
      append_hydration(select, option2);
      append_hydration(option2, t9);
      append_hydration(div12, t10);
      append_hydration(div12, div8);
      append_hydration(div8, div6);
      append_hydration(div6, t11);
      append_hydration(div8, t12);
      append_hydration(div8, div7);
      append_hydration(div7, input1);
      append_hydration(div12, t13);
      append_hydration(div12, div11);
      append_hydration(div11, div9);
      append_hydration(div9, t14);
      append_hydration(div11, t15);
      append_hydration(div11, div10);
      append_hydration(div10, input2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div13);
    }
  };
}
class HomePage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$n, safe_not_equal, {});
  }
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value2) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value2 = useValue ? initializers[i].call(thisArg, value2) : initializers[i].call(thisArg);
  }
  return useValue ? value2 : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value2, async) {
  if (value2 !== null && value2 !== void 0) {
    if (typeof value2 !== "object" && typeof value2 !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value2[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value2[Symbol.dispose];
      if (async)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value: value2, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value2;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1)
          return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async)
            return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } else
          s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1)
      return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError)
      throw env.error;
  }
  return next();
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __extends,
  get __assign() {
    return __assign;
  },
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
function create_fragment$m(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      var circle_nodes = children(circle);
      circle_nodes.forEach(detach);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      var line0_nodes = children(line0);
      line0_nodes.forEach(detach);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      var line1_nodes = children(line1);
      line1_nodes.forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(line0, "x1", "12");
      attr(line0, "y1", "8");
      attr(line0, "x2", "12");
      attr(line0, "y2", "16");
      attr(line1, "x1", "8");
      attr(line1, "y1", "12");
      attr(line1, "x2", "16");
      attr(line1, "y2", "12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svg-icon lucide-plus-circle");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, circle);
      append_hydration(svg, line0);
      append_hydration(svg, line1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { color = "black" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color];
}
class Plus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$m, safe_not_equal, { color: 0 });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[17] = list;
  child_ctx[18] = i;
  return child_ctx;
}
function create_each_block$6(key_1, ctx) {
  let button;
  let div;
  let t_value = ctx[16].name + "";
  let t;
  let button_data_selected_value;
  let button_transition;
  let current;
  let mounted;
  let dispose;
  function div_input_handler() {
    ctx[10].call(div, ctx[17], ctx[18]);
  }
  function click_handler() {
    return ctx[11](ctx[16]);
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "data-selected": true,
        "data-can-hover": true
      });
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", {
        tabindex: true,
        class: true,
        contenteditable: true
      });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "tabindex", "-1");
      attr(div, "class", "Editable_column");
      attr(div, "contenteditable", "false");
      if (ctx[16].name === void 0)
        add_render_callback(div_input_handler);
      attr(button, "class", "Editable_row");
      attr(button, "data-selected", button_data_selected_value = ctx[16].isSelected);
      attr(button, "data-can-hover", true);
      this.first = button;
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, div);
      append_hydration(div, t);
      if (ctx[16].name !== void 0) {
        div.textContent = ctx[16].name;
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "input", div_input_handler),
          listen(div, "click", click_handler),
          listen(div, "keyup", ctx[9])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 4) && t_value !== (t_value = ctx[16].name + ""))
        set_data_maybe_contenteditable(t, t_value, "false");
      if (dirty & 4 && ctx[16].name !== div.textContent) {
        div.textContent = ctx[16].name;
      }
      if (!current || dirty & 4 && button_data_selected_value !== (button_data_selected_value = ctx[16].isSelected)) {
        attr(button, "data-selected", button_data_selected_value);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!button_transition)
          button_transition = create_bidirectional_transition(button, slide, {}, true);
        button_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!button_transition)
        button_transition = create_bidirectional_transition(button, slide, {}, false);
      button_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (detaching && button_transition)
        button_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$e(ctx) {
  let div1;
  let div0;
  let image_plus;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  image_plus = new Plus({ props: { color: "#fff" } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(image_plus.$$.fragment);
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-selected": true,
        "data-can-hover": true,
        style: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        tabindex: true,
        class: true,
        contenteditable: true
      });
      var div0_nodes = children(div0);
      claim_component(image_plus.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "tabindex", "-1");
      attr(div0, "class", "Editable_Icon");
      attr(div0, "contenteditable", "false");
      attr(div1, "class", "Editable_row Editable_rowPlusButton");
      attr(div1, "data-selected", false);
      attr(div1, "data-can-hover", true);
      set_style(div1, "display", "flex");
      set_style(div1, "justify-content", "center");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      mount_component(image_plus, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[12]),
          listen(div1, "keyup", ctx[13])
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_plus.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, slide, {}, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(image_plus.$$.fragment, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, slide, {}, false);
      div1_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(image_plus);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$l(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let div_class_value;
  let current;
  let each_value = ctx[2];
  const get_key = (ctx2) => ctx2[16].key;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
  }
  let if_block = ctx[1] != null && create_if_block$e(ctx);
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", div_class_value = ctx[0] ? "GrobsInteractiveContainer editableTable" : "editableTable");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 12) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$6, t, get_each_context$6);
        check_outros();
      }
      if (ctx2[1] != null) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$e(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_class_value !== (div_class_value = ctx2[0] ? "GrobsInteractiveContainer editableTable" : "editableTable")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let _collection;
  let { isEditableContainer = true } = $$props;
  let { collection } = $$props;
  let { onSelect } = $$props;
  let { onAdd = null } = $$props;
  const dispatch2 = createEventDispatcher();
  let selected = null;
  function deselect() {
    if (!selected)
      return;
    let i = _collection.findIndex((p) => p.isSelected);
    if (i != -1)
      $$invalidate(2, _collection[i].isSelected = false, _collection);
    selected = null;
    dispatch2("onDeSelect");
  }
  function select(key) {
    let item = _collection.find((p) => p.key == key);
    if (item) {
      _onSelect(item);
    }
  }
  function _onSelect(item) {
    let i = _collection.findIndex((p) => p.isSelected);
    if (i != -1 && _collection[i].key == item.key) {
      $$invalidate(2, _collection[i].isSelected = false, _collection);
      selected = null;
      dispatch2("onDeSelect");
      return;
    }
    if (i != -1)
      $$invalidate(2, _collection[i].isSelected = false, _collection);
    i = _collection.findIndex((p) => p.key == item.key);
    const isSelected = onSelect(_collection[i].key);
    if (isSelected) {
      selected = _collection[i];
    } else {
      selected = null;
    }
    $$invalidate(2, _collection[i].isSelected = isSelected, _collection);
  }
  function _onAdd() {
    if (!onAdd)
      return;
    deselect();
    onAdd();
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_input_handler(each_value, e_index) {
    each_value[e_index].name = this.textContent;
    $$invalidate(2, _collection), $$invalidate(5, collection);
  }
  const click_handler = (e) => _onSelect(e);
  const click_handler_1 = () => _onAdd();
  const keyup_handler_1 = () => _onAdd();
  $$self.$$set = ($$props2) => {
    if ("isEditableContainer" in $$props2)
      $$invalidate(0, isEditableContainer = $$props2.isEditableContainer);
    if ("collection" in $$props2)
      $$invalidate(5, collection = $$props2.collection);
    if ("onSelect" in $$props2)
      $$invalidate(6, onSelect = $$props2.onSelect);
    if ("onAdd" in $$props2)
      $$invalidate(1, onAdd = $$props2.onAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $$invalidate(2, _collection = collection.map((p) => {
        var _a;
        if (p.key && p.value) {
          return {
            key: p.key,
            name: p.value,
            isSelected: (_a = p.isSelected) !== null && _a !== void 0 ? _a : false,
            nameEdit: p.value
          };
        } else {
          return {
            key: p,
            name: p,
            isSelected: false,
            nameEdit: p
          };
        }
      }));
    }
  };
  return [
    isEditableContainer,
    onAdd,
    _collection,
    _onSelect,
    _onAdd,
    collection,
    onSelect,
    deselect,
    select,
    keyup_handler,
    div_input_handler,
    click_handler,
    click_handler_1,
    keyup_handler_1
  ];
}
class EditAbleList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$l, safe_not_equal, {
      isEditableContainer: 0,
      collection: 5,
      onSelect: 6,
      onAdd: 1,
      deselect: 7,
      select: 8
    });
  }
  get deselect() {
    return this.$$.ctx[7];
  }
  get select() {
    return this.$$.ctx[8];
  }
}
const subscriber_queue = [];
function writable(value2, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value2));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function flip(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t, u) => {
      const x = u * dx;
      const y = u * dy;
      const sx = t + u * from.width / to.width;
      const sy = t + u * from.height / to.height;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
    }
  };
}
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i][0];
  child_ctx[13] = list[i][1];
  const constants_0 = child_ctx[13].msg.replace("\n", "<br />");
  child_ctx[14] = constants_0;
  return child_ctx;
}
function create_if_block$d(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_transition;
  let current;
  let each_value = ctx[2];
  const get_key = (ctx2) => ctx2[12];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "ErrorHandlerSignage");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 13) {
        each_value = ctx2[2];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_1$9(ctx) {
  let i;
  let t;
  return {
    c() {
      i = element("i");
      t = text(ctx[0]);
    },
    l(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[0]);
      i_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, i, anchor);
      append_hydration(i, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(i);
    }
  };
}
function create_each_block$5(key_1, ctx) {
  let div;
  let p;
  let raw_value = ctx[14] + "";
  let t0;
  let t1;
  let div_class_value;
  let div_transition;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && ctx[13].type == MessageTypes.error && create_if_block_1$9(ctx);
  function keydown_handler() {
    return ctx[9](ctx[13], ctx[12]);
  }
  function click_handler() {
    return ctx[10](ctx[13], ctx[12]);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      p = element("p");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      var div_nodes = children(div);
      p = claim_element(div_nodes, "P", {});
      var p_nodes = children(p);
      p_nodes.forEach(detach);
      t0 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "role", "none");
      attr(div, "class", div_class_value = ctx[13].type == MessageTypes.error ? "ErrorHandlerSign" : ctx[13].type == MessageTypes.verbose ? "VerboseHandlerSign" : ctx[13].type == MessageTypes.good ? "OKHandlerSign" : "");
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, p);
      p.innerHTML = raw_value;
      append_hydration(div, t0);
      if (if_block)
        if_block.m(div, null);
      append_hydration(div, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "keydown", keydown_handler),
          listen(div, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 4) && raw_value !== (raw_value = ctx[14] + ""))
        p.innerHTML = raw_value;
      if (ctx[0] && ctx[13].type == MessageTypes.error) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$9(ctx);
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = ctx[13].type == MessageTypes.error ? "ErrorHandlerSign" : ctx[13].type == MessageTypes.verbose ? "VerboseHandlerSign" : ctx[13].type == MessageTypes.good ? "OKHandlerSign" : "")) {
        attr(div, "class", div_class_value);
      }
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
      add_transform(div, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, {});
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$k(ctx) {
  let div;
  let current;
  let if_block = ctx[1] != 0 && create_if_block$d(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "ErrorHandlerSignageContainer");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] != 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
const MessageTypes = {
  error: "error",
  verbose: "verbose",
  good: "good"
};
function instance$k($$self, $$props, $$invalidate) {
  let messages = writable({});
  let messagesLength = Object.entries(messages).length;
  let entries = [];
  let { overrideClick = null } = $$props;
  let { overrideClickTextError = null } = $$props;
  messages.subscribe((p) => {
    $$invalidate(2, entries = Object.entries(p));
    $$invalidate(1, messagesLength = entries.length);
  });
  function addMessage(key, msg) {
    if (!msg)
      return;
    if (!msg.type)
      msg.type = "error";
    messages.update((r) => {
      r[key] = msg;
      return r;
    });
  }
  function addMessageManual(key, msg, type = "error") {
    messages.update((r) => {
      r[key] = { msg, type };
      return r;
    });
  }
  function removeError(key) {
    messages.update((r) => {
      if (!r[key])
        return r;
      delete r[key];
      return r;
    });
  }
  function removeAllMessages() {
    messages.update(() => {
      return {};
    });
  }
  function onclick(type, key) {
    let a = true;
    if (overrideClick)
      a = overrideClick(type, key);
    if (a) {
      removeError(key);
    }
  }
  const keydown_handler = (obj, key) => {
    onclick(obj.type, key);
  };
  const click_handler = (obj, key) => {
    onclick(obj.type, key);
  };
  $$self.$$set = ($$props2) => {
    if ("overrideClick" in $$props2)
      $$invalidate(4, overrideClick = $$props2.overrideClick);
    if ("overrideClickTextError" in $$props2)
      $$invalidate(0, overrideClickTextError = $$props2.overrideClickTextError);
  };
  return [
    overrideClickTextError,
    messagesLength,
    entries,
    onclick,
    overrideClick,
    addMessage,
    addMessageManual,
    removeError,
    removeAllMessages,
    keydown_handler,
    click_handler
  ];
}
class StaticMessageHandler extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$k, safe_not_equal, {
      overrideClick: 4,
      overrideClickTextError: 0,
      addMessage: 5,
      addMessageManual: 6,
      removeError: 7,
      removeAllMessages: 8
    });
  }
  get addMessage() {
    return this.$$.ctx[5];
  }
  get addMessageManual() {
    return this.$$.ctx[6];
  }
  get removeError() {
    return this.$$.ctx[7];
  }
  get removeAllMessages() {
    return this.$$.ctx[8];
  }
}
class Layout01Context {
  constructor() {
    __publicField(this, "activeSystem");
    __publicField(this, "availablePreviews");
    __publicField(this, "API");
    __publicField(this, "mainAppContainer");
    __publicField(this, "uiSystem");
    __publicField(this, "uiGuid");
  }
}
function getAugmentedNamespace(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a = function() {
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var dist = {};
var KeyManager$1 = {};
Object.defineProperty(KeyManager$1, "__esModule", { value: true });
KeyManager$1.keyManagerInstance = KeyManager$1.KeyManager = void 0;
var KeyManager = function() {
  function KeyManager2() {
    this.keyCounter = 0;
  }
  KeyManager2.prototype.getNewKey = function() {
    var num = this.keyCounter++;
    return num.toString(16);
  };
  return KeyManager2;
}();
KeyManager$1.KeyManager = KeyManager;
KeyManager$1.keyManagerInstance = new KeyManager();
var TTRPGSystemGraphModel = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var IOutputHandler = {};
Object.defineProperty(IOutputHandler, "__esModule", { value: true });
IOutputHandler.newOutputHandler = void 0;
function newOutputHandler() {
  var a = {
    outError: function(msg) {
      console.error(msg);
    },
    outLog: function(msg) {
      console.log(msg);
    }
  };
  return a;
}
IOutputHandler.newOutputHandler = newOutputHandler;
var TTRPGSystemGraphAbstractModel$1 = {};
var GrobCollection$1 = {};
var AGraphItem$1 = {};
Object.defineProperty(AGraphItem$1, "__esModule", { value: true });
AGraphItem$1.AGraphItem = void 0;
var KeyManager_1 = KeyManager$1;
var keyManager = new KeyManager_1.KeyManager();
var AGraphItem = function() {
  function AGraphItem2(name, key) {
    if (name === void 0) {
      name = "";
    }
    if (key === void 0) {
      key = "";
    }
    this.name = name;
    this._key = key + keyManager.getNewKey();
  }
  AGraphItem2.prototype.getName = function() {
    return this.name;
  };
  AGraphItem2.prototype.setName = function(name) {
    this.name = name;
  };
  AGraphItem2.prototype.getKey = function() {
    return this._key;
  };
  return AGraphItem2;
}();
AGraphItem$1.AGraphItem = AGraphItem;
Object.defineProperty(GrobCollection$1, "__esModule", { value: true });
GrobCollection$1.GrobCollection = void 0;
var tslib_1$4 = require$$0;
var AGraphItem_1$2 = AGraphItem$1;
var GrobCollection = function(_super2) {
  tslib_1$4.__extends(GrobCollection2, _super2);
  function GrobCollection2(name, parent) {
    var _this = _super2.call(this, name, "C") || this;
    _this.nodes_names = {};
    _this.updateListeners = {};
    return _this;
  }
  GrobCollection2.prototype.getNodeNames = function() {
    return Object.keys(this.nodes_names);
  };
  GrobCollection2.prototype.getNodes = function() {
    return Object.values(this.nodes_names);
  };
  GrobCollection2.prototype.hasNode = function(name) {
    return this.nodes_names[name] ? true : false;
  };
  GrobCollection2.prototype.getNode = function(name) {
    var _a;
    return (_a = this.nodes_names[name]) !== null && _a !== void 0 ? _a : null;
  };
  GrobCollection2.prototype.addNode = function(node) {
    node.parent = this;
    this.nodes_names[node.getName()] = node;
    return true;
  };
  GrobCollection2.prototype.removeNode = function(node) {
    if (!node) {
      console.error('attempted to delete node "Null" ');
      return false;
    }
    var name = node.getName();
    var n = this.nodes_names[name];
    if (!n)
      return false;
    n.dispose();
    delete this.nodes_names[name];
    return this.nodes_names[name] == null;
  };
  GrobCollection2.prototype.update_node_name = function(oldName, newName) {
    if (oldName == newName) {
      return;
    }
    if (!this.nodes_names[oldName]) {
      return;
    }
    this.nodes_names[oldName].setName(newName, true);
    this.nodes_names[newName] = this.nodes_names[oldName];
    delete this.nodes_names[oldName];
  };
  GrobCollection2.prototype.setName = function(name) {
    var oldname = this.getName();
    if (oldname == name) {
      return;
    }
    _super2.prototype.setName.call(this, name);
    this.parent.update_collection_name(oldname, name);
    this.updateLocation(this.parent);
  };
  GrobCollection2.prototype.updateLocation = function(parent) {
    this.parent = parent;
    for (var name in this.nodes_names) {
      var curr = this.nodes_names[name];
      curr.updateLocation(this);
    }
    this.getNodes().forEach(function(node) {
      node.update();
    });
    this.callUpdateListeners();
  };
  GrobCollection2.prototype.dispose = function() {
    for (var name in this.nodes_names) {
      var curr = this.nodes_names[name];
      curr.dispose();
      delete this.nodes_names[name];
    }
    this.parent = null;
    this.name = null;
  };
  GrobCollection2.prototype.getCollectionType = function() {
    return this.colType;
  };
  GrobCollection2.prototype.setCollectionType = function(colType) {
    if (this.colType != null && colType != colType) {
      throw new Error("tried to convert a group type after Setting. Denied Action");
    }
    this.colType = colType;
  };
  GrobCollection2.prototype.update = function() {
    this.callUpdateListeners();
  };
  GrobCollection2.prototype.callUpdateListeners = function() {
    var _this = this;
    Object.keys(this.updateListeners).forEach(function(key) {
      _this.updateListeners[key]();
    });
    return true;
  };
  GrobCollection2.prototype.addUpdateListener = function(key, listener) {
    if (this.updateListeners[key] != void 0) {
      console.error("tried to add updatelistener to node with key:" + key + ". but there was already a listener using that key");
      return false;
    }
    this.updateListeners[key] = listener;
  };
  GrobCollection2.prototype.removeUpdateListener = function(key) {
    delete this.updateListeners[key];
  };
  GrobCollection2.prototype.removeAllUpdateListeners = function() {
    this.updateListeners = {};
  };
  return GrobCollection2;
}(AGraphItem_1$2.AGraphItem);
GrobCollection$1.GrobCollection = GrobCollection;
var GrobGroup$1 = {};
Object.defineProperty(GrobGroup$1, "__esModule", { value: true });
GrobGroup$1.GrobGroup = void 0;
var tslib_1$3 = require$$0;
var AGraphItem_1$1 = AGraphItem$1;
var GrobGroup = function(_super2) {
  tslib_1$3.__extends(GrobGroup2, _super2);
  function GrobGroup2(name, parent) {
    var _this = _super2.call(this, name, "G") || this;
    _this.collections_names = {};
    _this.updateListeners = {};
    return _this;
  }
  GrobGroup2.prototype.getCollectionsNames = function() {
    return Object.keys(this.collections_names);
  };
  GrobGroup2.prototype.hasCollection = function(name) {
    return this.collections_names[name] ? true : false;
  };
  GrobGroup2.prototype.getCollection = function(name) {
    return this.collections_names[name];
  };
  GrobGroup2.prototype.addCollection = function(collection) {
    collection.parent = this;
    this.collections_names[collection.getName()] = collection;
    collection.setCollectionType(this.groupType);
    this.callUpdateListeners();
    return true;
  };
  GrobGroup2.prototype.removeCollection = function(collection) {
    var name = collection.getName();
    var c = this.collections_names[name];
    if (!c)
      return false;
    collection.dispose();
    delete this.collections_names[name];
    this.callUpdateListeners();
    return this.collections_names[name] == null;
  };
  GrobGroup2.prototype.update_collection_name = function(oldName, newName) {
    if (!this.collections_names[oldName])
      return;
    this.collections_names[newName] = this.collections_names[oldName];
    delete this.collections_names[oldName];
    this.collections_names[newName].setName(newName);
  };
  GrobGroup2.prototype.setName = function(name) {
    _super2.prototype.setName.call(this, name);
    for (var name_1 in this.collections_names) {
      var curr = this.collections_names[name_1];
      curr.updateLocation(this);
    }
    this.callUpdateListeners();
  };
  GrobGroup2.prototype.dispose = function() {
    for (var name in this.collections_names) {
      var curr = this.collections_names[name];
      curr.dispose();
      delete this.collections_names[name];
    }
    this.name = null;
  };
  GrobGroup2.prototype.getGroupType = function() {
    return this.groupType;
  };
  GrobGroup2.prototype.setGroupType = function(groupType) {
    if (this.groupType != null && groupType != groupType) {
      throw new Error("tried to convert a group type after Setting. Denied Action");
    }
    this.groupType = groupType;
    Object.values(this.collections_names).forEach(function(col) {
      col.setCollectionType(groupType);
    });
  };
  GrobGroup2.prototype.update = function() {
    this.callUpdateListeners();
  };
  GrobGroup2.prototype.callUpdateListeners = function() {
    var _this = this;
    Object.keys(this.updateListeners).forEach(function(key) {
      _this.updateListeners[key]();
    });
    return true;
  };
  GrobGroup2.prototype.addUpdateListener = function(key, listener) {
    if (this.updateListeners[key] != void 0) {
      console.error("tried to add updatelistener to node with key:" + key + ". but there was already a listener using that key");
      return false;
    }
    this.updateListeners[key] = listener;
  };
  GrobGroup2.prototype.removeUpdateListener = function(key) {
    delete this.updateListeners[key];
  };
  GrobGroup2.prototype.removeAllUpdateListeners = function() {
    this.updateListeners = {};
  };
  return GrobGroup2;
}(AGraphItem_1$1.AGraphItem);
GrobGroup$1.GrobGroup = GrobGroup;
Object.defineProperty(TTRPGSystemGraphAbstractModel$1, "__esModule", { value: true });
TTRPGSystemGraphAbstractModel$1.TTRPGSystemGraphAbstractModel = void 0;
var GrobCollection_1 = GrobCollection$1;
var GrobGroup_1 = GrobGroup$1;
var IOutputHandler_1 = IOutputHandler;
var TTRPGSystemGraphAbstractModel = function() {
  function TTRPGSystemGraphAbstractModel2() {
    this.data = {};
  }
  TTRPGSystemGraphAbstractModel2.prototype.setOut = function(out) {
    this.out = out ? out : (0, IOutputHandler_1.newOutputHandler)();
  };
  TTRPGSystemGraphAbstractModel2.prototype._deleteGroup = function(group) {
    if (typeof group == "string") {
      var g_1 = this.getGroup(group);
      if (!g_1)
        return false;
      group = g_1;
    }
    var key = group.getName();
    var g = this.data[key];
    if (!g) {
      this.out.outError("tried to delete non existant group");
      return false;
    }
    group.dispose();
    delete this.data[key];
  };
  TTRPGSystemGraphAbstractModel2.prototype._createGroup = function(name) {
    if (this._hasGroup(name)) {
      this.out.outError("attempted to add new group, however group already existed");
      return null;
    }
    var gp = new GrobGroup_1.GrobGroup(name, this);
    this.data[gp.getName()] = gp;
    return gp;
  };
  TTRPGSystemGraphAbstractModel2.prototype._hasGroup = function(name) {
    for (var key in this.data) {
      if (this.data[key].getName() == name) {
        return true;
      }
    }
    return false;
  };
  TTRPGSystemGraphAbstractModel2.prototype._getGroup_key = function(key) {
    return this.data[key];
  };
  TTRPGSystemGraphAbstractModel2.prototype.getGroup = function(name) {
    for (var key in this.data) {
      if (this.data[key].getName() == name) {
        return this.data[key];
      }
    }
    return null;
  };
  TTRPGSystemGraphAbstractModel2.prototype._deleteCollection = function(collection) {
    if (!collection) {
      this.out.outError("tried to delete collection, but supplied collection was invalid");
    }
    var group = collection.parent;
    return group.removeCollection(collection);
  };
  TTRPGSystemGraphAbstractModel2.prototype._createCollection = function(group, name) {
    if (!group) {
      this.out.outError("tried to create collection, but supplied group was invalid");
    }
    if (group.hasCollection(name)) {
      this.out.outError("Collection by that name already existed in '".concat(group.getName(), "'"));
      return null;
    }
    var collection = new GrobCollection_1.GrobCollection(name, group);
    group.addCollection(collection);
    return collection;
  };
  TTRPGSystemGraphAbstractModel2.prototype._AddNode = function(collection, node) {
    if (!collection) {
      this.out.outError("tried to add node, but supplied collection was invalid");
    }
    if (collection.getCollectionType() != "Node") {
      throw new Error("Tried to Add Node to Non Node Collecton");
    }
    return collection.addNode(node);
  };
  TTRPGSystemGraphAbstractModel2.prototype._deleteNode = function(node) {
    var col = node.parent;
    var r = col.removeNode(node);
    node.dispose();
    return r;
  };
  TTRPGSystemGraphAbstractModel2.prototype._addNodeDependency = function(node, dep) {
    var o1 = node.addDependency(dep);
    var o2 = dep.addDependent(node);
    if (!(o1 && o2)) {
      if (!o1) {
        this.out.outError("Could not add dependency ".concat(dep.getName(), ", on node ").concat(node.getName()));
      }
      if (!o2) {
        this.out.outError("Could not add dependent ".concat(node.getName(), ", on node ").concat(dep.getName()));
      }
      return false;
    }
    return true;
  };
  TTRPGSystemGraphAbstractModel2.prototype._removeNodeDependency = function(node, dep) {
    var o1 = node.removeDependency(dep);
    var o2 = dep.removeDependent(node);
    if (!(o1 && o2)) {
      if (!o1) {
        this.out.outError("Could not remove dependency ".concat(dep.getName(), ", on node ").concat(node.getName()));
      }
      if (!o2) {
        this.out.outError("Could not remove dependent ".concat(node.getName(), ", on node ").concat(dep.getName()));
      }
      return false;
    }
    return true;
  };
  TTRPGSystemGraphAbstractModel2.prototype._addTable = function(collection, table) {
    if (!collection) {
      this.out.outError("tried to add node, but supplied collection was invalid");
      return;
    }
    if (collection.getCollectionType() != "Table") {
      this.out.outError("Tried to Add table to Non Table Collecton");
      return;
    }
    return collection.addNode(table);
  };
  return TTRPGSystemGraphAbstractModel2;
}();
TTRPGSystemGraphAbstractModel$1.TTRPGSystemGraphAbstractModel = TTRPGSystemGraphAbstractModel;
var hasRequiredTTRPGSystemGraphModel;
function requireTTRPGSystemGraphModel() {
  if (hasRequiredTTRPGSystemGraphModel)
    return TTRPGSystemGraphModel;
  hasRequiredTTRPGSystemGraphModel = 1;
  Object.defineProperty(TTRPGSystemGraphModel, "__esModule", { value: true });
  TTRPGSystemGraphModel.TTRPGSystemGraphModel = void 0;
  var tslib_12 = require$$0;
  var IOutputHandler_12 = IOutputHandler;
  var TTRPGSystemGraphAbstractModel_1 = TTRPGSystemGraphAbstractModel$1;
  var index_1 = requireDist();
  var index_2 = requireDist();
  var derived = "derived";
  var fixed = "fixed";
  var TTRPGSystemGraphModel$1 = function(_super2) {
    tslib_12.__extends(TTRPGSystemGraphModel2, _super2);
    function TTRPGSystemGraphModel2() {
      var _this = _super2.call(this) || this;
      _this.setOut((0, IOutputHandler_12.newOutputHandler)());
      return _this;
    }
    TTRPGSystemGraphModel2.prototype.initAsNew = function() {
      this._createGroup("fixed");
      this._createGroup("derived");
      this._createGroup("extra");
      this.data["fixed"].setGroupType("Node");
      this.data["derived"].setGroupType("Node");
      this.data["extra"].setGroupType("Table");
    };
    TTRPGSystemGraphModel2.prototype.createCollection = function(group, name) {
      if (!this._hasGroup(group)) {
        this.out.outError("No group existed by name ".concat(group));
      }
      var grp = this.getGroup(group);
      if (!grp)
        return null;
      return this._createCollection(grp, name);
    };
    TTRPGSystemGraphModel2.prototype.createDerivedCollection = function(name) {
      return this.createCollection(derived, name);
    };
    TTRPGSystemGraphModel2.prototype.createFixedCollection = function(name) {
      return this.createCollection(fixed, name);
    };
    TTRPGSystemGraphModel2.prototype.createNode = function(group, col, name) {
      if (!this._hasGroup(group)) {
        this.out.outError("No group existed by name ".concat(group));
        return null;
      }
      if (this.hasNode(group, col, name)) {
        this.out.outError("Node by this name already existed ".concat(group));
        return null;
      }
      if (group == "fixed") {
        return this.createFixedNode(col, name);
      } else if (group == "derived") {
        return this.createDerivedNode(col, name);
      }
      return null;
    };
    TTRPGSystemGraphModel2.prototype.createDerivedNode = function(col, name) {
      var colName = col;
      if (typeof col == "string") {
        var grp = this.getGroup(derived);
        if (!grp)
          return null;
        col = grp.getCollection(col);
      } else {
        colName = col.getName();
      }
      if (!col) {
        this.out.outError("No Derived collection found by name: ".concat(colName, " "));
        return null;
      }
      var node = new index_2.GrobDerivedNode(name, col);
      col.addNode(node);
      return node;
    };
    TTRPGSystemGraphModel2.prototype.createFixedNode = function(col, name) {
      var grp = this.getGroup(fixed);
      if (!grp)
        return null;
      var colName = col;
      if (typeof col !== "string") {
        colName = col.getName();
      } else {
        col = grp.getCollection(colName);
      }
      if (!col) {
        this.out.outError("No Fixed collection found by name: ".concat(colName, " "));
        return null;
      }
      var node = new index_1.GrobFixedNode(name, col);
      col.addNode(node);
      return node;
    };
    TTRPGSystemGraphModel2.prototype.hasCollection = function(group, name) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return false;
      }
      return grp.hasCollection(name);
    };
    TTRPGSystemGraphModel2.prototype.hasDerivedCollection = function(name) {
      return this.hasCollection(derived, name);
    };
    TTRPGSystemGraphModel2.prototype.hasFixedCollection = function(name) {
      return this.hasCollection(fixed, name);
    };
    TTRPGSystemGraphModel2.prototype.hasNode = function(group, col, name) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return false;
      }
      var _col = col;
      if (typeof col === "string") {
        _col = this.getCollection(grp, col);
        if (!_col) {
          this.out.outError("attempted to get ".concat(group, " collection ").concat(name, ", but no collection existed by that name"));
          return false;
        }
      }
      return _col.hasNode(name);
    };
    TTRPGSystemGraphModel2.prototype.hasDerivedNode = function(col, name) {
      return this.hasNode(derived, col, name);
    };
    TTRPGSystemGraphModel2.prototype.hasFixedNode = function(col, name) {
      return this.hasNode(fixed, col, name);
    };
    TTRPGSystemGraphModel2.prototype.getCollectionNames = function(group) {
      var grp;
      if (typeof group == "string") {
        grp = this.getGroup(group);
      } else {
        grp = group;
      }
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return [];
      }
      return grp.getCollectionsNames();
    };
    TTRPGSystemGraphModel2.prototype.getCollection = function(group, name) {
      var grp;
      if (typeof group == "string") {
        grp = this.getGroup(group);
      } else {
        grp = group;
      }
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return null;
      }
      var col = grp.getCollection(name);
      if (!col) {
        this.out.outError("attempted to get ".concat(group, " collection ").concat(name, ", but no collection existed by that name"));
        return null;
      }
      return col;
    };
    TTRPGSystemGraphModel2.prototype.getDerivedCollection = function(name) {
      return this.getCollection(derived, name);
    };
    TTRPGSystemGraphModel2.prototype.getFixedCollection = function(name) {
      return this.getCollection(fixed, name);
    };
    TTRPGSystemGraphModel2.prototype.getNode = function(group, col, name) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return null;
      }
      var node;
      if (typeof col !== "string") {
        node = col.getNode(name);
      } else {
        var colName = col;
        col = grp.getCollection(col);
        if (!col) {
          this.out.outError("attempted to get ".concat(group, " collection ").concat(colName, ", but did not exist"));
          return null;
        }
        node = col.getNode(name);
      }
      if (!node) {
        this.out.outError("attempted to get ".concat(group, ".").concat(col.getName(), " Node ").concat(name, ", but did not exist"));
        return null;
      }
      return node;
    };
    TTRPGSystemGraphModel2.prototype.getDerivedNode = function(col, name) {
      return this.getNode(derived, col, name);
    };
    TTRPGSystemGraphModel2.prototype.getFixedNode = function(col, name) {
      return this.getNode(fixed, col, name);
    };
    TTRPGSystemGraphModel2.prototype.getNodeNames = function(group, col) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return null;
      }
      var _col;
      if (typeof col === "string") {
        _col = grp.getCollection(col);
      } else {
        _col = col;
      }
      return _col.getNodeNames();
    };
    TTRPGSystemGraphModel2.prototype._deleteGroup = function(group) {
      if (typeof group == "string") {
        var name = group;
        group = this.getGroup(group);
        if (!group) {
          this.out.outError("No Collection by name " + name);
          return false;
        }
      }
      _super2.prototype._deleteGroup.call(this, group);
    };
    TTRPGSystemGraphModel2.prototype.deleteCollection = function(group, col) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return false;
      }
      if (typeof col === "string") {
        col = col = grp.getCollection(col);
        if (!col)
          return false;
      }
      return this._deleteCollection(col);
    };
    TTRPGSystemGraphModel2.prototype.deleteDerivedCollection = function(col) {
      return this.deleteCollection(derived, col);
    };
    TTRPGSystemGraphModel2.prototype.deleteFixedCollection = function(col) {
      return this.deleteCollection(fixed, col);
    };
    TTRPGSystemGraphModel2.prototype.deleteNode = function(group, col, name) {
      var grp = this.getGroup(group);
      if (!grp) {
        this.out.outError("No group existed by name ".concat(group));
        return false;
      }
      if (typeof col === "string") {
        col = grp.getCollection(col);
      }
      if (!col) {
        this.out.outError("attempted to get ".concat(group, " collection ").concat(name, ", but no collection existed by that name"));
        return false;
      }
      var node = col.getNode(name);
      return col.removeNode(node);
    };
    TTRPGSystemGraphModel2.prototype.deleteDerivedNode = function(col, name) {
      return this.deleteNode(derived, col, name);
    };
    TTRPGSystemGraphModel2.prototype.deleteFixedNode = function(col, name) {
      return this.deleteNode(fixed, col, name);
    };
    TTRPGSystemGraphModel2.prototype.renameCollection = function(group, col, newName) {
      var grp;
      var grpName;
      if (typeof group == "string") {
        grpName = group;
        grp = this.getGroup(group);
      } else {
        grpName = group.getName();
        grp = group;
      }
      if (!grp) {
        this.out.outError("No group existed by name ".concat(grpName));
        return null;
      }
      var colName = col;
      if (typeof col == "string") {
        colName = col;
        col = grp.getCollection(col);
      } else {
        colName = col.getName();
      }
      if (!col) {
        this.out.outError("No Collection existed by name ".concat(colName, " in ").concat(grpName));
        return null;
      }
      if (grp.getCollection(newName)) {
        this.out.outError("Collection already existed by name ".concat(newName, " in ").concat(grpName));
        return null;
      }
      return col.setName(newName);
    };
    TTRPGSystemGraphModel2.prototype.renameItem = function(group, col, oldName, newName) {
      var grp;
      var grpName;
      if (typeof group == "string") {
        grpName = group;
        grp = this.getGroup(group);
      } else {
        grpName = group.getName();
        grp = group;
      }
      if (!grp) {
        this.out.outError("No group existed by name ".concat(grpName));
        return null;
      }
      var colName = col;
      if (typeof col == "string") {
        colName = col;
        col = grp.getCollection(col);
      } else {
        colName = col.getName();
      }
      if (!col) {
        this.out.outError("No Collection existed by name ".concat(colName, " in ").concat(grpName));
        return null;
      }
      if (!col.hasNode(oldName)) {
        this.out.outError("No Item existed by name ".concat(oldName, " in ").concat(grpName, ".").concat(colName));
        return null;
      }
      return col.update_node_name(oldName, newName);
    };
    TTRPGSystemGraphModel2.prototype.isValid = function(errorMessages) {
      if (errorMessages === void 0) {
        errorMessages = [];
      }
      var key_group, key_collection, key_node;
      var collectionNames, nodeNames;
      var group, collection, node;
      var isValid;
      for (key_group in this.data) {
        group = this.data[key_group];
        collectionNames = group.getCollectionsNames();
        for (var c = 0; c < collectionNames.length; c++) {
          var colIndex = c;
          key_collection = collectionNames[colIndex];
          collection = group.getCollection(key_collection);
          nodeNames = collection.getNodeNames();
          for (var n = 0; n < nodeNames.length; n++) {
            var nodeIndex = n;
            key_node = nodeNames[nodeIndex];
            node = collection.getNode(key_node);
            isValid = node.isValid();
            if (!isValid) {
              var msg = "".concat(key_group, ".").concat(key_collection, ".").concat(key_node, " was invalid");
              var keys = [key_group, key_collection, key_node];
              errorMessages.push({ msg, key: keys });
            }
          }
        }
      }
      return errorMessages.length == 0;
    };
    TTRPGSystemGraphModel2.prototype.getGroup = function(name) {
      var grp = this.data[name];
      return grp !== null && grp !== void 0 ? grp : null;
    };
    TTRPGSystemGraphModel2.prototype.addNodeDependency = function(node, dep) {
      this._addNodeDependency(node, dep);
    };
    TTRPGSystemGraphModel2.prototype.removeNodeDependency = function(node, dep) {
      this._removeNodeDependency(node, dep);
    };
    return TTRPGSystemGraphModel2;
  }(TTRPGSystemGraphAbstractModel_1.TTRPGSystemGraphAbstractModel);
  TTRPGSystemGraphModel.TTRPGSystemGraphModel = TTRPGSystemGraphModel$1;
  return TTRPGSystemGraphModel;
}
var TTRPGSystemBonusDesigner = {};
var GrobBonusNode = {};
var GrobDerivedNode$1 = {};
var AGrobNodte = {};
var TarjanNode = {};
Object.defineProperty(TarjanNode, "__esModule", { value: true });
TarjanNode.GrobAlgorithms = void 0;
var GrobAlgorithms = function() {
  function GrobAlgorithms2() {
  }
  GrobAlgorithms2.TarjAlgo = function(nodes, strongComponents) {
    if (strongComponents === void 0) {
      strongComponents = {};
    }
    var que = [];
    nodes.forEach(function(node) {
      que.push(node);
    });
    var algLevel = GrobAlgorithms2.algLevel++;
    var counter = 0;
    while (que.length > 0) {
      var curr = que.pop();
      if (curr.tarjanAlgorithmAlgorithmIndex != algLevel) {
        curr.linkValue = counter++;
        curr.LowLinkValue = Number.MAX_SAFE_INTEGER;
        curr.tarjanAlgorithmAlgorithmIndex = algLevel;
        que.push.apply(que, Object.values(curr.dependencies));
      }
    }
    que = [];
    nodes.forEach(function(node) {
      que.push(node);
    });
    algLevel = GrobAlgorithms2.algLevel++;
    while (que.length > 0) {
      var curr = que.pop();
      tarjanNodeVisit(algLevel, curr, strongComponents);
    }
    function tarjanNodeVisit(algLevel2, node, strongComponents2) {
      if (node.tarjanAlgorithmAlgorithmIndex == algLevel2) {
        return node.LowLinkValue;
      }
      var que2 = Object.values(node.dependencies);
      var lowLinkValue = node.LowLinkValue;
      node.tarjanAlgorithmAlgorithmIndex = algLevel2;
      while (que2.length > 0) {
        var curr2 = que2.pop();
        var lowLinkCandidate = tarjanNodeVisit(algLevel2, curr2, strongComponents2);
        if (curr2.LowLinkValue == lowLinkCandidate) {
          strongComponents2[curr2.getLocationKey()] = curr2;
        } else if (curr2.LowLinkValue < lowLinkCandidate) {
          lowLinkValue = lowLinkCandidate;
        }
      }
      node.LowLinkValue = lowLinkValue;
      return lowLinkValue;
    }
    return [Object.keys(strongComponents).length == 0, strongComponents];
  };
  GrobAlgorithms2.algLevel = 1;
  return GrobAlgorithms2;
}();
TarjanNode.GrobAlgorithms = GrobAlgorithms;
Object.defineProperty(AGrobNodte, "__esModule", { value: true });
AGrobNodte.AGrobNode = void 0;
var tslib_1$2 = require$$0;
var AGraphItem_1 = AGraphItem$1;
var TarjanNode_1 = TarjanNode;
var AGrobNode = function(_super2) {
  tslib_1$2.__extends(AGrobNode2, _super2);
  function AGrobNode2(name, keystart, parent) {
    var _this = _super2.call(this, name, keystart) || this;
    _this.dependencies = {};
    _this.dependents = {};
    _this.updateListeners = {};
    _this.bonuses = {};
    _this.tarjanAlgorithmAlgorithmIndex = 0;
    _this.LowLinkValue = 0;
    _this.linkValue = 0;
    if (parent)
      _this.parent = parent;
    return _this;
  }
  AGrobNode2.prototype.addBonus = function(bonusIndex, bonus, errors) {
    if (errors === void 0) {
      errors = [];
    }
    bonus.update();
    var preStrongComponents = {};
    var alreadyHadStrongComps = TarjanNode_1.GrobAlgorithms.TarjAlgo([this], preStrongComponents);
    if (alreadyHadStrongComps[0]) {
      errors.push({ key: "Pre-AddBonusError", msg: "this node already had circular dependencies, before adding another node. Added Bonus is therefore refused" });
      return false;
    }
    if (this.bonuses[bonusIndex]) {
      this.remBonus(bonusIndex);
    }
    this.bonuses[bonusIndex] = bonus;
    this.addDependency(bonus);
    var StrongComponents = {};
    var StrongComps = TarjanNode_1.GrobAlgorithms.TarjAlgo([this], StrongComponents);
    if (StrongComps[0]) {
      errors.push({ key: "Pre-AddBonusError", msg: "this node already had circular dependencies, before adding another node. Added Bonus is therefore refused" });
      this.remBonus(bonusIndex);
      return false;
    }
    return true;
  };
  AGrobNode2.prototype.remBonus = function(bonusIndex) {
    if (!this.bonuses[bonusIndex])
      return true;
    var node = this.bonuses[bonusIndex];
    delete this.bonuses[bonusIndex];
    this.removeDependency(node);
    return true;
  };
  AGrobNode2.getTypeString = function() {
    return "Nodte<T extends Nodte<T>>";
  };
  AGrobNode2.prototype.addDependent = function(node) {
    var key = node.getKey();
    if (this.dependents[key]) {
      return true;
    }
    this.dependents[key] = node;
    return true;
  };
  AGrobNode2.prototype.removeDependent = function(node) {
    delete this.dependents[node.getKey()];
    return this.dependents[node.getKey()] == null;
  };
  AGrobNode2.prototype.getDependents = function() {
    var _a;
    return (_a = Object.values(this.dependents)) !== null && _a !== void 0 ? _a : [];
  };
  AGrobNode2.prototype.addDependency = function(node) {
    return false;
  };
  AGrobNode2.prototype.removeDependency = function(node) {
    return false;
  };
  AGrobNode2.prototype.nullifyDependency = function(node) {
    return false;
  };
  AGrobNode2.prototype.getDependencies = function() {
    var _a;
    return (_a = Object.values(this.dependencies)) !== null && _a !== void 0 ? _a : [];
  };
  AGrobNode2.prototype.getValue = function() {
    var initialValue = this._getValue();
    for (var key in this.bonuses) {
      var bonus = this.bonuses[key];
      var value2 = bonus._getValue();
      initialValue += value2;
    }
    return initialValue;
  };
  AGrobNode2.prototype.getLocationKey = function() {
    var segs = this.getLocationKeySegments();
    return segs.join(".");
  };
  AGrobNode2.prototype.getLocationKeySegments = function() {
    var _a, _b, _c, _d, _e, _f;
    var seg = ["", "", ""];
    seg[0] = (_c = (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.getName()) !== null && _c !== void 0 ? _c : "unknown";
    seg[1] = (_e = (_d = this.parent) === null || _d === void 0 ? void 0 : _d.getName()) !== null && _e !== void 0 ? _e : "unknown";
    seg[2] = (_f = this.getName()) !== null && _f !== void 0 ? _f : "unknown";
    return seg;
  };
  AGrobNode2.prototype.update = function() {
    var _this = this;
    this._update();
    Object.keys(this.updateListeners).forEach(function(key) {
      _this.updateListeners[key]();
    });
    return true;
  };
  AGrobNode2.prototype.dispose = function() {
    for (var key in this.dependencies) {
      var curr = this.dependencies[key];
      curr.removeDependent(this);
    }
    for (var key in this.dependents) {
      var curr = this.dependents[key];
      curr.nullifyDependency(this);
    }
    this.parent = null;
    this.name = null;
  };
  AGrobNode2.prototype.setName = function(name, parentCall) {
    if (parentCall === void 0) {
      parentCall = false;
    }
    var oldname = this.getName();
    _super2.prototype.setName.call(this, name);
    if (!parentCall) {
      this.parent.update_node_name(oldname, name);
    }
    this.updateLocation(this.parent);
  };
  AGrobNode2.prototype.updateLocation = function(parent) {
    this.parent = parent;
    for (var key in this.dependents) {
      var dep = this.dependents[key];
      dep.updateDependecysLocation(this);
    }
    this.update();
  };
  AGrobNode2.prototype.updateDependecysLocation = function(dependency) {
  };
  AGrobNode2.prototype.isValid = function() {
    return true;
  };
  AGrobNode2.prototype.addUpdateListener = function(key, listener) {
    if (this.updateListeners[key] != void 0) {
      console.error("tried to add updatelistener to node with key:" + key + ". but there was already a listener using that key");
      return false;
    }
    this.updateListeners[key] = listener;
  };
  AGrobNode2.prototype.removeUpdateListener = function(key) {
    delete this.updateListeners[key];
  };
  AGrobNode2.prototype.removeAllUpdateListeners = function() {
    this.updateListeners = {};
  };
  return AGrobNode2;
}(AGraphItem_1.AGraphItem);
AGrobNodte.AGrobNode = AGrobNode;
var TTRPGSystemsGraphDependencies = {};
Object.defineProperty(TTRPGSystemsGraphDependencies, "__esModule", { value: true });
TTRPGSystemsGraphDependencies.grobDerivedSymbolRegex = void 0;
TTRPGSystemsGraphDependencies.grobDerivedSymbolRegex = /@[a-zA-Z]/g;
var GrobOrigin$1 = {};
Object.defineProperty(GrobOrigin$1, "__esModule", { value: true });
GrobOrigin$1.GrobOrigin = void 0;
var GrobOrigin = function() {
  function GrobOrigin2() {
    this.standardValue = 1;
  }
  GrobOrigin2.UnkownLocationKey = "unknown.unknown.unknown";
  return GrobOrigin2;
}();
GrobOrigin$1.GrobOrigin = GrobOrigin;
Object.defineProperty(GrobDerivedNode$1, "__esModule", { value: true });
GrobDerivedNode$1.GrobDerivedNode = void 0;
var tslib_1$1 = require$$0;
var AGrobNodte_1$1 = AGrobNodte;
var TTRPGSystemsGraphDependencies_1 = TTRPGSystemsGraphDependencies;
var GrobOrigin_1 = GrobOrigin$1;
var GrobDerivedNode = function(_super) {
  tslib_1$1.__extends(GrobDerivedNode, _super);
  function GrobDerivedNode(name, parent) {
    var _this = _super.call(this, name, "ND", parent) || this;
    _this.calc = "@a";
    _this.origins = [];
    _this._value = NaN;
    return _this;
  }
  GrobDerivedNode.prototype._getValue = function() {
    return this._value;
  };
  GrobDerivedNode.prototype.setValue = function(value2) {
    this._value = value2;
  };
  GrobDerivedNode.getTypeString = function() {
    return "derivedNode";
  };
  GrobDerivedNode.prototype.getTypeString = function() {
    return GrobDerivedNode.getTypeString();
  };
  GrobDerivedNode.prototype.addDependency = function(node) {
    var key = node.getKey();
    this.dependencies[key] = node;
    node.addDependent(this);
    return true;
  };
  GrobDerivedNode.prototype.removeDependency = function(node) {
    var key = node.getKey();
    if (this.dependencies[key]) {
      delete this.dependencies[key];
      node.removeDependent(this);
    }
    for (var i = 0; i < this.origins.length; i++) {
      var orig = this.origins[i];
      if (orig.origin != null && orig.origin.getKey() == key) {
        orig.origin = null;
      }
    }
    return this.dependencies[key] == null;
  };
  GrobDerivedNode.prototype.nullifyDependency = function(node) {
    var key = node.getKey();
    var orig = this.origins.find(function(p) {
      var _a;
      return ((_a = p.origin) === null || _a === void 0 ? void 0 : _a.getKey()) == key;
    });
    if (orig) {
      orig.origin = null;
      orig.originKey = GrobOrigin_1.GrobOrigin.UnkownLocationKey;
    }
    return this.removeDependency(node);
  };
  GrobDerivedNode.prototype.setOrigin = function(symbol, node, standardValue) {
    var _a, _b;
    if (standardValue === void 0) {
      standardValue = null;
    }
    var origin2 = this.origins.find(function(p) {
      return p.symbol == symbol;
    });
    if (!origin2) {
      return false;
    }
    if (origin2.origin) {
      this.removeDependency(origin2.origin);
    }
    var nodeKey = (_a = node === null || node === void 0 ? void 0 : node.getTypeString()) !== null && _a !== void 0 ? _a : "";
    if (!["derivedNode", "fixedNode"].find(function(p) {
      return p == nodeKey;
    })) {
      node = null;
    }
    if (node) {
      this.addDependency(node);
    }
    origin2.origin = node;
    origin2.standardValue = (_b = standardValue !== null && standardValue !== void 0 ? standardValue : origin2.standardValue) !== null && _b !== void 0 ? _b : 1;
    if (origin2.origin)
      origin2.originKey = origin2.origin.getLocationKey();
    if (this.isValid()) {
      this.recalculate(false);
    }
    return true;
  };
  GrobDerivedNode.prototype.isValid = function() {
    var hadNullOrigin = false;
    this.origins.forEach(function(o) {
      if (!o.origin) {
        hadNullOrigin = true;
      }
    });
    if (hadNullOrigin) {
      return false;
    }
    var originsWithLinks = this.origins.filter(function(p) {
      return p.origin != null;
    });
    if (originsWithLinks.length != this.getDependencies().length) {
      return false;
    }
    return true;
  };
  GrobDerivedNode.prototype.updateOrigins = function() {
    var originRes = this.parseCalculationToOrigins(this.calc);
    if (originRes) {
      var symbolsToRem_1 = originRes.symbolsToRem;
      var symbolsToAdd = originRes.symbolsToAdd;
      if (symbolsToRem_1.length != 0) {
        this.origins = this.origins.filter(function(p) {
          return !symbolsToRem_1.includes(p.symbol);
        });
      }
      if (symbolsToAdd.length != 0) {
        for (var i = 0; i < symbolsToAdd.length; i++) {
          var orig = new GrobOrigin_1.GrobOrigin();
          orig.symbol = symbolsToAdd[i];
          orig.standardValue = 1;
          orig.origin = null;
          orig.originKey = GrobOrigin_1.GrobOrigin.UnkownLocationKey;
          this.origins.push(orig);
        }
      }
      var oldDependencies_1 = {};
      this.getDependencies().forEach(function(p) {
        return oldDependencies_1[p.getName()] = p;
      });
      var newDependencies_1 = {};
      this.origins.forEach(function(p) {
        var _a;
        if (p.origin != null) {
          newDependencies_1[(_a = p.origin) === null || _a === void 0 ? void 0 : _a.getName()] = p.origin;
        }
      });
      for (var key in oldDependencies_1) {
        if (!newDependencies_1[key]) {
          this.removeDependency(oldDependencies_1[key]);
        }
      }
      return { added: symbolsToAdd, removed: symbolsToRem_1.length };
    } else {
      return { added: 0, removed: 0 };
    }
  };
  GrobDerivedNode.prototype.setCalc = function(calc, updateOrigins) {
    if (updateOrigins === void 0) {
      updateOrigins = true;
    }
    this._value = NaN;
    var testCalc = this.testCalculate(calc);
    if (testCalc == null || !testCalc.success) {
      return false;
    }
    this.calc = calc;
    if (updateOrigins) {
      this.updateOrigins();
    }
    if (this.isValid()) {
      this.recalculate(false);
    }
    return true;
  };
  GrobDerivedNode.prototype.parseCalculationToOrigins = function(calc) {
    var _a;
    var calcValue = calc;
    var symbols2 = (_a = calcValue.match(TTRPGSystemsGraphDependencies_1.grobDerivedSymbolRegex)) !== null && _a !== void 0 ? _a : [];
    symbols2 = Array.from(new Set(symbols2));
    var existingKeysArray = this.origins.map(function(p) {
      return p.symbol;
    });
    var symbolsToAdd = symbols2.filter(function(p) {
      return !existingKeysArray.includes(p);
    });
    var symbolsToRem = existingKeysArray.filter(function(p) {
      return !symbols2.includes(p);
    });
    return { symbolsToRem, symbolsToAdd, totalSymbols: symbols2 };
  };
  GrobDerivedNode.staticParseCalculationToOrigins = function(calc) {
    var _a;
    var calcValue = calc;
    var symbols2 = (_a = calcValue.match(TTRPGSystemsGraphDependencies_1.grobDerivedSymbolRegex)) !== null && _a !== void 0 ? _a : [];
    symbols2 = Array.from(new Set(symbols2));
    return symbols2;
  };
  GrobDerivedNode.prototype.recalculate = function(useTempValues) {
    if (useTempValues === void 0) {
      useTempValues = false;
    }
    var rec2 = useTempValues ? Object.fromEntries(this.origins.map(function(p) {
      return [p.symbol, p.standardValue];
    })) : Object.fromEntries(this.origins.map(function(p) {
      var _a;
      return [p.symbol, (_a = p.origin) === null || _a === void 0 ? void 0 : _a.getValue()];
    }));
    var statement2 = this.calc;
    var res2 = this._recalculate(rec2, statement2);
    this._value = res2.value;
    return res2.success;
  };
  GrobDerivedNode.prototype._recalculate = function(rec2, statement2) {
    if (rec2 === void 0) {
      rec2 = {};
    }
    return GrobDerivedNode.recalculate(rec2, statement2);
  };
  GrobDerivedNode.recalculate = function(rec, statement) {
    if (rec === void 0) {
      rec = {};
    }
    var symbols = statement.match(TTRPGSystemsGraphDependencies_1.grobDerivedSymbolRegex);
    var _statement = statement;
    symbols === null || symbols === void 0 ? void 0 : symbols.forEach(function(key) {
      var v = rec[key];
      _statement = _statement.replace(key, v + "");
    });
    var recalcSuccess = false;
    var value = 0;
    try {
      var res = eval(_statement);
      if (typeof res === "number") {
        recalcSuccess = true;
        value = res;
      } else {
        recalcSuccess = false;
        value = NaN;
      }
    } catch (e) {
      recalcSuccess = false;
      value = NaN;
    }
    return { success: recalcSuccess, value };
  };
  GrobDerivedNode.prototype.testCalculate = function(statement2) {
    var symbols2 = statement2.match(TTRPGSystemsGraphDependencies_1.grobDerivedSymbolRegex);
    var rec2 = symbols2 ? Object.fromEntries(symbols2.map(function(s) {
      return [s, 1];
    })) : {};
    var res2 = this._recalculate(rec2, statement2);
    return res2;
  };
  GrobDerivedNode.testCalculate = function(statement2, symbolsToValue) {
    if (symbolsToValue === void 0) {
      symbolsToValue = {};
    }
    var symbols2 = statement2.match(TTRPGSystemsGraphDependencies_1.grobDerivedSymbolRegex);
    function mapValueToSymbol(s, m) {
      if (m[s]) {
        return m[s];
      }
      return 1;
    }
    var rec2 = symbols2 ? Object.fromEntries(symbols2.map(function(s) {
      return [s, mapValueToSymbol(s, symbolsToValue)];
    })) : {};
    var res2 = GrobDerivedNode.recalculate(rec2, statement2);
    return res2;
  };
  GrobDerivedNode.prototype._update = function() {
    if (!this.isValid()) {
      console.error("Node isent Valid ".concat(this.getName(), " ").concat(this.getLocationKey(), " Stopping update"));
      return false;
    }
    this.recalculate();
    var success = true;
    for (var k in this.dependents) {
      var dep = this.dependents[k];
      success = success && dep.update();
    }
    return success;
  };
  GrobDerivedNode.prototype.updateDependecysLocation = function(dependency) {
    var orig = this.origins.find(function(p) {
      var _a;
      return ((_a = p.origin) === null || _a === void 0 ? void 0 : _a.getName()) == dependency.getName();
    });
    if (!orig)
      return;
    orig.originKey = dependency.getLocationKey();
  };
  return GrobDerivedNode;
}(AGrobNodte_1$1.AGrobNode);
GrobDerivedNode$1.GrobDerivedNode = GrobDerivedNode;
var hasRequiredGrobBonusNode;
function requireGrobBonusNode() {
  if (hasRequiredGrobBonusNode)
    return GrobBonusNode;
  hasRequiredGrobBonusNode = 1;
  Object.defineProperty(GrobBonusNode, "__esModule", { value: true });
  GrobBonusNode.GrobBonusNode = void 0;
  var tslib_12 = require$$0;
  var GrobDerivedNode_1 = GrobDerivedNode$1;
  var TTRPGSystemBonusDesigner_1 = requireTTRPGSystemBonusDesigner();
  var GrobBonusNode$1 = function(_super2) {
    tslib_12.__extends(GrobBonusNode2, _super2);
    function GrobBonusNode2(name, parent) {
      return _super2.call(this, name, parent) || this;
    }
    GrobBonusNode2.CreateNodeChain = function(sys, name) {
      return TTRPGSystemBonusDesigner_1.TTRPGSystemBonusDesigner.createBonusNodeChain(sys, name);
    };
    GrobBonusNode2.getTypeString = function() {
      return "bonusNode";
    };
    GrobBonusNode2.prototype.getTypeString = function() {
      return GrobBonusNode2.getTypeString();
    };
    return GrobBonusNode2;
  }(GrobDerivedNode_1.GrobDerivedNode);
  GrobBonusNode.GrobBonusNode = GrobBonusNode$1;
  return GrobBonusNode;
}
var hasRequiredTTRPGSystemBonusDesigner;
function requireTTRPGSystemBonusDesigner() {
  if (hasRequiredTTRPGSystemBonusDesigner)
    return TTRPGSystemBonusDesigner;
  hasRequiredTTRPGSystemBonusDesigner = 1;
  Object.defineProperty(TTRPGSystemBonusDesigner, "__esModule", { value: true });
  TTRPGSystemBonusDesigner.TTRPGSystemBonusDesigner = void 0;
  var GrobBonusNode_1 = requireGrobBonusNode();
  var TTRPGSystemBonusDesigner$1 = function() {
    function TTRPGSystemBonusDesigner2() {
    }
    TTRPGSystemBonusDesigner2.createBonusNodeChain = function(sys, name) {
      var instance2 = new TTRPGSystemBonusDesigner2();
      if (!sys.hasCollection("extra", "bonus")) {
        sys.createCollection("extra", "bonus");
      }
      var col = sys.getCollection("extra", "bonus");
      instance2.activeNode = instance2.createNewNode(name, col);
      return instance2;
    };
    TTRPGSystemBonusDesigner2.prototype.createNewNode = function(name, parent) {
      return new GrobBonusNode_1.GrobBonusNode(name, parent);
    };
    TTRPGSystemBonusDesigner2.prototype.addCalculation = function(calc) {
      this.activeNode.setCalc(calc);
      return this;
    };
    TTRPGSystemBonusDesigner2.prototype.addOrigin = function(symbol, node) {
      this.activeNode.setOrigin(symbol, node);
      return this;
    };
    TTRPGSystemBonusDesigner2.prototype.update = function() {
      this.activeNode.updateOrigins();
      return this;
    };
    TTRPGSystemBonusDesigner2.prototype.getNode = function() {
      return this.activeNode;
    };
    TTRPGSystemBonusDesigner2.prototype.getOriginStates = function() {
      return this.activeNode.parseCalculationToOrigins(this.activeNode.calc);
    };
    TTRPGSystemBonusDesigner2.prototype.isValidCalculation = function() {
      return this.activeNode.testCalculate(this.activeNode.calc);
    };
    TTRPGSystemBonusDesigner2.prototype.isValid = function() {
      return this.activeNode.isValid();
    };
    return TTRPGSystemBonusDesigner2;
  }();
  TTRPGSystemBonusDesigner.TTRPGSystemBonusDesigner = TTRPGSystemBonusDesigner$1;
  return TTRPGSystemBonusDesigner;
}
var GrobFixedNode$1 = {};
Object.defineProperty(GrobFixedNode$1, "__esModule", { value: true });
GrobFixedNode$1.GrobFixedNode = void 0;
var tslib_1 = require$$0;
var AGrobNodte_1 = AGrobNodte;
var GrobFixedNode = function(_super2) {
  tslib_1.__extends(GrobFixedNode2, _super2);
  function GrobFixedNode2(name, parent) {
    var _this = _super2.call(this, name, "NF", parent) || this;
    _this.___value = 1;
    return _this;
  }
  GrobFixedNode2.prototype._getValue = function() {
    return this.___value;
  };
  GrobFixedNode2.prototype.setValue = function(value2) {
    this.___value = value2;
    for (var key in this.dependents) {
      var curr = this.dependents[key];
      curr.update();
    }
  };
  GrobFixedNode2.getTypeString = function() {
    return "fixedNode";
  };
  GrobFixedNode2.prototype.getTypeString = function() {
    return GrobFixedNode2.getTypeString();
  };
  GrobFixedNode2.prototype.addDependency = function(node) {
    return false;
  };
  GrobFixedNode2.prototype.removeDependency = function(node) {
    return false;
  };
  GrobFixedNode2.prototype.nullifyDependency = function(node) {
    return false;
  };
  GrobFixedNode2.prototype._update = function() {
    for (var k in this.dependents) {
      var dep = this.dependents[k];
      dep.update();
    }
  };
  return GrobFixedNode2;
}(AGrobNodte_1.AGrobNode);
GrobFixedNode$1.GrobFixedNode = GrobFixedNode;
var DataTable = {};
Object.defineProperty(DataTable, "__esModule", { value: true });
DataTable.ADataRow = DataTable.ADataTable = void 0;
var ADataTable = function() {
  function ADataTable2() {
    this.data = {};
  }
  ADataTable2.prototype.setName = function(name) {
    throw new Error("Method not implemented.");
  };
  ADataTable2.prototype.getName = function() {
    throw new Error("Method not implemented.");
  };
  ADataTable2.prototype.dispose = function() {
    throw new Error("Method not implemented.");
  };
  ADataTable2.prototype.updateLocation = function() {
    throw new Error("Method not implemented.");
  };
  ADataTable2.prototype.getLocationKey = function() {
    var segs = this.getLocationKeySegments();
    return segs.join(".");
  };
  ADataTable2.prototype.getLocationKeySegments = function() {
    var _a, _b, _c, _d, _e, _f;
    var seg = ["", "", ""];
    seg[0] = (_c = (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.getName()) !== null && _c !== void 0 ? _c : "unknown";
    seg[1] = (_e = (_d = this.parent) === null || _d === void 0 ? void 0 : _d.getName()) !== null && _e !== void 0 ? _e : "unknown";
    seg[2] = (_f = this.getName()) !== null && _f !== void 0 ? _f : "unknown";
    return seg;
  };
  ADataTable2.prototype.update = function() {
  };
  return ADataTable2;
}();
DataTable.ADataTable = ADataTable;
var ADataRow = function() {
  function ADataRow2() {
  }
  return ADataRow2;
}();
DataTable.ADataRow = ADataRow;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist)
    return dist;
  hasRequiredDist = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uuidv4 = exports2.TTRPGSystemHelper = exports2.TTRPGSystem = exports2.ADataTable = exports2.ADataRow = exports2.GrobGroup = exports2.GrobCollection = exports2.GrobBonusNode = exports2.GrobDerivedNode = exports2.GrobDerivedOrigin = exports2.GrobFixedNode = exports2.keyManagerInstance = void 0;
    var KeyManager_12 = KeyManager$1;
    Object.defineProperty(exports2, "keyManagerInstance", { enumerable: true, get: function() {
      return KeyManager_12.keyManagerInstance;
    } });
    var TTRPGSystemGraphModel_1 = requireTTRPGSystemGraphModel();
    Object.defineProperty(exports2, "TTRPGSystem", { enumerable: true, get: function() {
      return TTRPGSystemGraphModel_1.TTRPGSystemGraphModel;
    } });
    var GrobCollection_12 = GrobCollection$1;
    Object.defineProperty(exports2, "GrobCollection", { enumerable: true, get: function() {
      return GrobCollection_12.GrobCollection;
    } });
    var GrobGroup_12 = GrobGroup$1;
    Object.defineProperty(exports2, "GrobGroup", { enumerable: true, get: function() {
      return GrobGroup_12.GrobGroup;
    } });
    var TTRPGSystemBonusDesigner_1 = requireTTRPGSystemBonusDesigner();
    Object.defineProperty(exports2, "TTRPGSystemHelper", { enumerable: true, get: function() {
      return TTRPGSystemBonusDesigner_1.TTRPGSystemBonusDesigner;
    } });
    var GrobBonusNode_1 = requireGrobBonusNode();
    Object.defineProperty(exports2, "GrobBonusNode", { enumerable: true, get: function() {
      return GrobBonusNode_1.GrobBonusNode;
    } });
    var GrobDerivedNode_1 = GrobDerivedNode$1;
    Object.defineProperty(exports2, "GrobDerivedNode", { enumerable: true, get: function() {
      return GrobDerivedNode_1.GrobDerivedNode;
    } });
    var GrobFixedNode_1 = GrobFixedNode$1;
    Object.defineProperty(exports2, "GrobFixedNode", { enumerable: true, get: function() {
      return GrobFixedNode_1.GrobFixedNode;
    } });
    var GrobOrigin_12 = GrobOrigin$1;
    Object.defineProperty(exports2, "GrobDerivedOrigin", { enumerable: true, get: function() {
      return GrobOrigin_12.GrobOrigin;
    } });
    var DataTable_1 = DataTable;
    Object.defineProperty(exports2, "ADataRow", { enumerable: true, get: function() {
      return DataTable_1.ADataRow;
    } });
    Object.defineProperty(exports2, "ADataTable", { enumerable: true, get: function() {
      return DataTable_1.ADataTable;
    } });
    function uuidv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    exports2.uuidv4 = uuidv4;
  })(dist);
  return dist;
}
var distExports = requireDist();
var BASE_SCHEME = "_base";
var NoOutput = {
  outError: function(msg) {
  },
  outLog: function(msg) {
  }
};
var JSON_TAGS;
(function(JSON_TAGS2) {
  JSON_TAGS2["JSON_PROPERTY"] = "JSON_PROPERTY";
  JSON_TAGS2["JSON_PROPERTY_TYPED"] = "JSON_PROPERTY_TYPED";
  JSON_TAGS2["JSON_PROPERTY_TYPED_SKIP_FORCED"] = "JSON_PROPERTY_TYPED_SKIP_FORCED";
  JSON_TAGS2["JSON_PROPERTY_NAME_MAP_IN"] = "JSON_PROPERTY_NAME_MAP_IN";
  JSON_TAGS2["JSON_PROPERTY_NAME_MAP_OUT"] = "JSON_PROPERTY_NAME_MAP_OUT";
  JSON_TAGS2["JSON_PROPERTY_FUNC_MAP_IN"] = "JSON_PROPERTY_FUNC_MAP_IN";
  JSON_TAGS2["JSON_PROPERTY_FUNC_MAP_OUT"] = "JSON_PROPERTY_FUNC_MAP_OUT";
  JSON_TAGS2["JSON_PROPERTY_FORCE_BASE_TYPE"] = "JSON_PROPERTY_FORCE_BASE_TYPE";
  JSON_TAGS2["JSON_PROPERTY_FORCE_ARRAY"] = "JSON_PROPERTY_FORCE_ARRAY";
  JSON_TAGS2["JSON_OBJECT_ON_AFTER_DE_SERIALIZATION"] = "JSON_OBJECT_ON_AFTER_DE_SERIALIZATION";
  JSON_TAGS2["JSON_OBJECT_ON_AFTER_SERIALIZATION_BEFORE_STRING"] = "JSON_OBJECT_ON_AFTER_SERIALIZATION_BEFORE_STRING";
  JSON_TAGS2["JSON_OBJECT_ON_AFTER_SERIALIZATION"] = "JSON_OBJECT_ON_AFTER_SERIALIZATION";
  JSON_TAGS2["JSON_OBJECT_ON_BEFORE_SERIALIZATION"] = "JSON_OBJECT_ON_BEFORE_SERIALIZATION";
  JSON_TAGS2["JSON_OBJECT_ON_BEFORE_DE_SERIALIZATION"] = "JSON_OBJECT_ON_BEFORE_DE_SERIALIZATION";
})(JSON_TAGS || (JSON_TAGS = {}));
var JSON_BASETYPES;
(function(JSON_BASETYPES2) {
  JSON_BASETYPES2["string"] = "string";
  JSON_BASETYPES2["bool"] = "bool";
  JSON_BASETYPES2["number"] = "number";
})(JSON_BASETYPES || (JSON_BASETYPES = {}));
function createGuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var selfKey = createGuid() + "SELF";
var Reflect$1 = function() {
  function Reflect2() {
  }
  Reflect2.getPrototype = function(obj) {
    var a;
    if (typeof obj == "function") {
      a = obj.prototype;
    } else {
      a = obj.constructor.prototype;
    }
    return a;
  };
  Reflect2.setPrototype = function(obj, prototype) {
    if (typeof obj == "function") {
      throw new Error("Not Implemented Error, please report the scenario to me");
    } else {
      Object.setPrototypeOf(obj, prototype);
    }
  };
  Reflect2.getOrCreateAllMetaData = function(obj, create) {
    if (create === void 0) {
      create = false;
    }
    var prototype = Reflect2.getPrototype(obj);
    if (prototype === Object.prototype) {
      return null;
    }
    if (prototype == null)
      return null;
    var a = prototype;
    if (!a["gjmd"]) {
      if (!create)
        return null;
      a["gjmd"] = {};
    }
    a = a["gjmd"];
    if (!a[prototype.constructor.name]) {
      if (!create)
        return null;
      a[prototype.constructor.name] = {};
    }
    a = a[prototype.constructor.name];
    return a;
  };
  Reflect2.getOrCreateDefinedMetaData = function(obj, scheme, create) {
    if (create === void 0) {
      create = false;
    }
    var a = Reflect2.getOrCreateAllMetaData(obj, create);
    if (!a)
      return null;
    if (!a[scheme]) {
      if (!create)
        return null;
      a[scheme] = {};
    }
    return a[scheme];
  };
  Reflect2.getMetadataKeys = function(obj, key, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var a = Reflect2.getOrCreateDefinedMetaData(obj, scheme);
    if (!a || !a[key]) {
      return [];
    }
    return Object.keys(a[key]);
  };
  Reflect2.getOwnMetaDataKeys = function(obj, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    return Reflect2.getMetadataKeys(obj, selfKey, scheme);
  };
  Reflect2.getMetadata = function(metaTag, target, propertyKey, scheme) {
    var _a;
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var a = Reflect2.getOrCreateDefinedMetaData(target, scheme);
    if (!a[propertyKey])
      return null;
    return (_a = a[propertyKey][metaTag]) !== null && _a !== void 0 ? _a : null;
  };
  Reflect2.getOwnMetaData = function(metaTag, target, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    return Reflect2.getMetadata(metaTag, target, selfKey, scheme);
  };
  Reflect2.defineMetaData = function(metaTag, data, target, propertyKey, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var a = Reflect2.getOrCreateDefinedMetaData(target, scheme, true);
    if (!a[propertyKey])
      a[propertyKey] = {};
    a[propertyKey][metaTag] = data;
  };
  Reflect2.defineOwnMetaData = function(metaTag, data, target, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    return Reflect2.defineMetaData(metaTag, data, target, selfKey, scheme);
  };
  Reflect2.hasMetaData = function(metaTag, target, key, scheme) {
    var _a;
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var a = Reflect2.getOrCreateDefinedMetaData(target, scheme);
    if (a == null)
      return false;
    if (!a[key])
      return false;
    return (_a = a[key][metaTag]) !== null && _a !== void 0 ? _a : false;
  };
  Reflect2.hasOwnMetaData = function(metaTag, target, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    return Reflect2.hasMetaData(metaTag, target, selfKey, scheme);
  };
  Reflect2.getAllMeta = function(obj, scheme) {
    if (scheme) {
      return Reflect2.getOrCreateDefinedMetaData(obj, scheme);
    } else {
      return Reflect2.getOrCreateAllMetaData(obj, true);
    }
  };
  return Reflect2;
}();
function getMetadata(metaTag, target, propertyKey, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  return Reflect$1.getMetadata(metaTag, target, propertyKey, scheme);
}
function getOwnMetaData(metaTag, target, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  return Reflect$1.getOwnMetaData(metaTag, target, scheme);
}
function setMetadata(metaTag, value2, target, propertyKey, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  Reflect$1.defineMetaData(metaTag, value2, target, propertyKey, scheme);
}
function setOwnMetaData(metaTag, target, value2, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  Reflect$1.defineOwnMetaData(metaTag, value2, target, scheme);
}
function getOwnMetaDataKeys(target, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  var keys = Reflect$1.getOwnMetaDataKeys(target, scheme);
  return keys;
}
function getMetaDataKeys(target, key, scheme) {
  if (scheme === void 0) {
    scheme = BASE_SCHEME;
  }
  var keys = Reflect$1.getMetadataKeys(target, key, scheme);
  return keys;
}
function hasMetaData(target, scheme) {
  var a = Reflect$1.getAllMeta(target, scheme);
  if (!a)
    return false;
  return true;
}
function getPrototype(obj) {
  return Reflect$1.getPrototype(obj);
}
function setPrototype(obj, prototype) {
  Reflect$1.setPrototype(obj, prototype);
  return Reflect$1.getPrototype(obj) == prototype;
}
function cleanNonAccesibleSettings(option) {
  if (!option)
    return {};
  if (!option.scheme || option.scheme.length == 0)
    option.scheme = [BASE_SCHEME];
  option.mappingFunctions = null;
  option.type = null;
  option.isArray = null;
  option.forceBaseType = null;
  return option;
}
function JsonProperty(option) {
  return function(target, propertyKey) {
    var schemes;
    if (!(option === null || option === void 0 ? void 0 : option.scheme)) {
      schemes = [BASE_SCHEME];
    } else if (Array.isArray(option.scheme)) {
      if (option.scheme.length == 0) {
        schemes = [BASE_SCHEME];
      } else {
        schemes = option.scheme;
      }
    } else {
      schemes = [option.scheme];
    }
    for (var i = 0; i < schemes.length; i++) {
      var scheme = schemes[i];
      setMetadata(JSON_TAGS.JSON_PROPERTY, true, target, propertyKey, scheme);
      if (!option) {
        return;
      }
      if (option.forceBaseType) {
        switch (option.forceBaseType) {
          case JSON_BASETYPES.string:
          case JSON_BASETYPES.number:
          case JSON_BASETYPES.bool:
            setMetadata(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE, option.forceBaseType, target, propertyKey, scheme);
        }
      }
      if (option.isArray) {
        setMetadata(JSON_TAGS.JSON_PROPERTY_FORCE_ARRAY, true, target, propertyKey, scheme);
      }
      if (option.name) {
        setMetadata(JSON_TAGS.JSON_PROPERTY_NAME_MAP_IN, propertyKey, target, option.name, scheme);
        setMetadata(JSON_TAGS.JSON_PROPERTY_NAME_MAP_OUT, option.name, target, propertyKey, scheme);
      }
      if (option.mappingFunctions) {
        setMetadata(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_IN, option.mappingFunctions.in, target, propertyKey, scheme);
        setMetadata(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_OUT, option.mappingFunctions.out, target, propertyKey, scheme);
      }
      if (option.type) {
        setMetadata(JSON_TAGS.JSON_PROPERTY_TYPED, option.type, target, propertyKey, scheme);
      }
      if (option.skipForceType) {
        setMetadata(JSON_TAGS.JSON_PROPERTY_TYPED_SKIP_FORCED, true, target, propertyKey, scheme);
      }
    }
  };
}
function JsonNumber(option) {
  option = cleanNonAccesibleSettings(option);
  option.forceBaseType = JSON_BASETYPES.number;
  return JsonProperty(option);
}
function JsonString(option) {
  option = cleanNonAccesibleSettings(option);
  option.forceBaseType = JSON_BASETYPES.string;
  return JsonProperty(option);
}
function JsonBoolean(option) {
  option = cleanNonAccesibleSettings(option);
  option.forceBaseType = JSON_BASETYPES.bool;
  return JsonProperty(option);
}
function JsonClassTyped(type, option) {
  option = cleanNonAccesibleSettings(option);
  option.type = type;
  return JsonProperty(option);
}
function JsonArrayClassTyped(type, option) {
  option = cleanNonAccesibleSettings(option);
  option.isArray = true;
  option.type = type;
  return JsonProperty(option);
}
function JsonMappingRecordInArrayOut(option) {
  var type = option.type;
  option = cleanNonAccesibleSettings(option !== null && option !== void 0 ? option : {});
  var outfunc = function(col, s) {
    return Object.values(col).map(function(p) {
      return s(p);
    });
  };
  var infunc = function(col, d) {
    var r = {};
    col.map(function(p) {
      var o = d(p);
      var v = o[option.KeyPropertyName];
      if (typeof v == "function") {
        try {
          v = o[option.KeyPropertyName]();
          if (v === null || v === void 0) {
            throw new Error("after calling function ".concat(option.KeyPropertyName, " key value was '").concat(v, "' "));
          }
        } catch (e) {
          var messageAddon = v.length > 0 ? ", Note that message must have 0 Arguments, that arent either optional or have default values" : "";
          var message = "Something went wrong with callign method '".concat(option.KeyPropertyName, "'").concat(messageAddon);
          throw new Error(message);
        }
      }
      r[v] = o;
    });
    return r;
  };
  if (type) {
    option.type = type;
  }
  option.mappingFunctions = {
    out: outfunc,
    in: infunc
  };
  return JsonProperty(option);
}
function cleanObjectOptions(option) {
  if (!option)
    option = {};
  if (!option.onAfterDeSerialization) {
    option.onAfterDeSerialization = function(o) {
    };
  }
  if (!option.scheme || option.scheme.length == 0)
    option.scheme = [BASE_SCHEME];
  return option;
}
function JsonObject(option) {
  option = cleanObjectOptions(option);
  return function(target) {
    var schemes = option === null || option === void 0 ? void 0 : option.scheme;
    if (!schemes || schemes.length == 0)
      schemes = [BASE_SCHEME];
    for (var i = 0; i < schemes.length; i++) {
      var scheme = schemes[i];
      if (option.onAfterDeSerialization)
        setOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_DE_SERIALIZATION, target, option.onAfterDeSerialization, scheme);
      if (option.onAfterSerialization_beforeString)
        setOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION_BEFORE_STRING, target, option.onAfterSerialization_beforeString, scheme);
      if (option.onAfterSerialization)
        setOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION, target, option.onAfterSerialization, scheme);
      if (option.onBeforeSerialization)
        setOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_BEFORE_SERIALIZATION, target, option.onBeforeSerialization, scheme);
      if (option.onBeforeDeSerialization)
        setOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_BEFORE_DE_SERIALIZATION, target, option.onBeforeDeSerialization, scheme);
    }
  };
}
var JSONHandler = function() {
  function JSONHandler2() {
  }
  JSONHandler2.serialize = function(obj, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var o = JSONHandler2.serializeRaw(obj, scheme);
    var str = JSON.stringify(o);
    var ObjectMeta = getOwnMetaDataKeys(obj);
    if (ObjectMeta.includes(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION)) {
      var f = getOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION, obj, scheme);
      if (f)
        str = f(str);
    }
    return str;
  };
  JSONHandler2.serializeRaw = function(obj, scheme, parentName) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    if (parentName === void 0) {
      parentName = "FIRST";
    }
    if (!obj) {
      return obj;
    }
    var type = typeof obj;
    switch (type) {
      case "string":
        return JSONHandler2.deserializeAndForceSimple("string", obj, scheme);
      case "boolean":
      case "number":
        return obj;
    }
    if (!hasMetaData(obj, scheme)) {
      try {
        return obj;
      } catch (e) {
        return {};
      }
    }
    var result = {};
    var ObjectMeta = getOwnMetaDataKeys(obj);
    if (ObjectMeta.includes(JSON_TAGS.JSON_OBJECT_ON_BEFORE_SERIALIZATION)) {
      var f = getOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_BEFORE_SERIALIZATION, obj, scheme);
      if (f)
        f(obj);
    }
    var propertyNames;
    propertyNames = Object.getOwnPropertyNames(obj);
    var _loop_1 = function(i2) {
      var key = propertyNames[i2];
      var meta = getMetaDataKeys(obj, key, scheme);
      if (!meta.includes(JSON_TAGS.JSON_PROPERTY)) {
        return "continue";
      }
      var PropertyName = key;
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_NAME_MAP_OUT)) {
        PropertyName = getMetadata(JSON_TAGS.JSON_PROPERTY_NAME_MAP_OUT, obj, key, scheme);
      }
      var typedconversion = function(v, ser) {
        return v;
      };
      var skipForceType = false;
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_TYPED_SKIP_FORCED)) {
        skipForceType = getMetadata(JSON_TAGS.JSON_PROPERTY_TYPED_SKIP_FORCED, obj, key, scheme);
      }
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_TYPED) && !skipForceType) {
        typedconversion = function(v, ser) {
          var during = getMetadata(JSON_TAGS.JSON_PROPERTY_TYPED, obj, key, scheme).prototype;
          var before = getPrototype(v);
          setPrototype(v, during);
          var r = ser(v);
          setPrototype(v, before);
          return r;
        };
      }
      var out = null;
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_OUT)) {
        var outFunction_1 = getMetadata(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_OUT, obj, key, scheme);
        var _outF = function(o1) {
          return outFunction_1(o1, function(o2) {
            return typedconversion(o2, function(o3) {
              return JSONHandler2.serializeRaw(o3, scheme, parentName + ":" + key);
            });
          });
        };
        out = _outF(obj[key]);
      } else if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_ARRAY)) {
        out = [];
        if (obj[key]) {
          if (Array.isArray(obj[key])) {
            var _loop_2 = function(j2) {
              var e = typedconversion(obj[key][j2], function(o) {
                return JSONHandler2.serializeRaw(o, scheme, parentName + ":[" + j2 + "]:" + key);
              });
              out.push(e);
            };
            for (var j = 0; j < obj[key].length; j++) {
              _loop_2(j);
            }
          } else {
            out.push(typedconversion(obj[key], function(o) {
              return JSONHandler2.serializeRaw(o, scheme, parentName + ":" + key);
            }));
          }
        }
      } else {
        out = typedconversion(obj[key], function(o) {
          return JSONHandler2.serializeRaw(o, scheme, parentName + ":" + key);
        });
      }
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE)) {
        var typekey_1 = getMetadata(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE, obj, key, scheme);
        var convFunc = function(e) {
          return JSONHandler2.deserializeAndForceSimple(typekey_1, e, scheme);
        };
        if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_ARRAY)) {
          var temp = out;
          var newout = [];
          for (var i_1 = 0; i_1 < temp.length; i_1++) {
            newout.push(convFunc(temp[i_1]));
          }
          out = newout;
        } else {
          out = convFunc(obj[key]);
        }
      }
      result[PropertyName] = out;
    };
    for (var i = 0; i < propertyNames.length; i++) {
      _loop_1(i);
    }
    if (ObjectMeta.includes(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION_BEFORE_STRING)) {
      var f = getOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_SERIALIZATION_BEFORE_STRING, obj, scheme);
      if (f)
        f(result);
    }
    return result;
  };
  JSONHandler2.deserialize = function(target, json, scheme, writeOut) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    if (!writeOut) {
      writeOut = NoOutput;
    }
    var type = typeof json;
    if (type == "string") {
      json = JSON.parse(json);
    }
    switch (type) {
      case "boolean":
      case "number":
        writeOut.outError("Cannot derserialize type of " + type);
        return;
    }
    if (Array.isArray(json)) {
      var arr = [];
      for (var i = 0; i < json.length; i++) {
        arr.push(this.deserializeRaw(target, json[i], scheme));
      }
      return arr;
    } else {
      return this.deserializeRaw(target, json, scheme);
    }
  };
  JSONHandler2.deserializeAndForceSimple = function(typekey, obj, scheme) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    var out = obj;
    var convFunc = function(e) {
      return e;
    };
    switch (typekey) {
      case JSON_BASETYPES.bool:
        convFunc = function(input) {
          return Boolean(input);
        };
        break;
      case JSON_BASETYPES.string:
        if (obj == null)
          return "";
        if (typeof obj == "string") {
          return obj;
        } else if (Array.isArray(obj)) {
          var str = JSON.stringify(obj);
          return str;
        } else if (typeof obj == "object") {
          if (hasMetaData(obj, scheme)) {
            return JSONHandler2.serialize(obj, scheme);
          } else {
            return JSON.stringify(obj);
          }
        }
        convFunc = function(input) {
          return String(input);
        };
        break;
      case JSON_BASETYPES.number:
        if (obj == null) {
          return 0;
        }
        if (typeof obj == "object") {
          return 1;
        }
        convFunc = function(e) {
          var numberValue = Number(e);
          return isNaN(numberValue) ? 0 : numberValue;
        };
        break;
    }
    out = convFunc(out);
    return out;
  };
  JSONHandler2.deserializeRaw = function(target, obj, scheme, parentName) {
    if (scheme === void 0) {
      scheme = BASE_SCHEME;
    }
    if (!obj) {
      return obj;
    }
    var result = new target();
    var prototype = target.prototype;
    var ObjectMeta = getOwnMetaDataKeys(target);
    if (ObjectMeta.includes(JSON_TAGS.JSON_OBJECT_ON_BEFORE_DE_SERIALIZATION)) {
      var f = getOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_BEFORE_DE_SERIALIZATION, result, scheme);
      if (f)
        result = f(result, obj);
      if (!JSONHandler2.areSamePrototypes(result, target)) {
        target = getPrototype(result).constructor;
      }
    }
    var propertyNames = Object.getOwnPropertyNames(obj);
    var _loop_3 = function(i2) {
      var key = propertyNames[i2];
      var inKey = key;
      var meta = getMetaDataKeys(target, key, scheme);
      var PropertyName = key;
      if (meta.length == 0) {
        return "continue";
      }
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_NAME_MAP_IN)) {
        key = getMetadata(JSON_TAGS.JSON_PROPERTY_NAME_MAP_IN, prototype, key, scheme);
        meta = getMetaDataKeys(target, key, scheme);
        PropertyName = key;
      }
      var out = null;
      var constr = getMetadata(JSON_TAGS.JSON_PROPERTY_TYPED, prototype, key, scheme);
      if (meta.includes(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_IN)) {
        var inFunction = getMetadata(JSON_TAGS.JSON_PROPERTY_FUNC_MAP_IN, prototype, key, scheme);
        if (constr) {
          out = inFunction(obj[inKey], function(obj2) {
            var res2 = JSONHandler2.deserializeRaw(constr, obj2, scheme, key);
            return res2;
          });
        } else {
          out = inFunction(obj[inKey], function(obj2) {
            return obj2;
          });
        }
      } else if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_ARRAY)) {
        var convert_1 = function(e2) {
          return e2;
        };
        if (constr) {
          convert_1 = function(e2) {
            return JSONHandler2.deserializeRaw(constr, e2, scheme, key);
          };
        }
        var convert2 = function(e2, typekey2) {
          return convert_1(e2);
        };
        if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE)) {
          convert2 = function(e2, typekey2) {
            return JSONHandler2.deserializeAndForceSimple(typekey2, e2);
          };
        }
        out = [];
        var typekey = getMetadata(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE, prototype, key, scheme);
        for (var j = 0; j < obj[inKey].length; j++) {
          var e = obj[inKey][j];
          var r = convert2(e, typekey);
          out.push(r);
        }
      } else {
        if (constr) {
          out = JSONHandler2.deserializeRaw(constr, obj[inKey], scheme, key);
        } else if (meta.includes(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE)) {
          var typeKey = getMetadata(JSON_TAGS.JSON_PROPERTY_FORCE_BASE_TYPE, target, key, scheme);
          out = JSONHandler2.deserializeAndForceSimple(typeKey, obj[inKey]);
        } else {
          out = obj[inKey];
        }
      }
      result[PropertyName] = out;
    };
    for (var i = 0; i < propertyNames.length; i++) {
      _loop_3(i);
    }
    ObjectMeta = getOwnMetaDataKeys(result);
    if (ObjectMeta.includes(JSON_TAGS.JSON_OBJECT_ON_AFTER_DE_SERIALIZATION)) {
      var f = getOwnMetaData(JSON_TAGS.JSON_OBJECT_ON_AFTER_DE_SERIALIZATION, result, scheme);
      if (f)
        f(result);
    }
    return result;
  };
  JSONHandler2.changePrototype = function(target, source) {
    var prototype = getPrototype(source);
    setPrototype(target, prototype);
  };
  JSONHandler2.areSamePrototypes = function(target, source) {
    var prototype1 = getPrototype(source);
    var prototype2 = getPrototype(target);
    return prototype1 == prototype2;
  };
  return JSONHandler2;
}();
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
class GrobJDerivedOrigin extends distExports.GrobDerivedOrigin {
  constructor() {
    super(...arguments);
    __publicField(this, "symbol");
    __publicField(this, "originKey");
  }
}
__decorateClass$2([
  JsonString()
], GrobJDerivedOrigin.prototype, "symbol", 2);
__decorateClass$2([
  JsonString()
], GrobJDerivedOrigin.prototype, "originKey", 2);
class GrobJDerivedNode extends distExports.GrobDerivedNode {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "calc");
    __publicField(this, "origins");
  }
}
__decorateClass$2([
  JsonString()
], GrobJDerivedNode.prototype, "name", 2);
__decorateClass$2([
  JsonString({ name: "calculationString" })
], GrobJDerivedNode.prototype, "calc", 2);
__decorateClass$2([
  JsonArrayClassTyped(GrobJDerivedOrigin, { name: "calcOrigins" })
], GrobJDerivedNode.prototype, "origins", 2);
class GrobJFixedNode extends distExports.GrobFixedNode {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "___value");
  }
}
__decorateClass$2([
  JsonString()
], GrobJFixedNode.prototype, "name", 2);
__decorateClass$2([
  JsonNumber({ name: "standardValue" })
], GrobJFixedNode.prototype, "___value", 2);
class GrobCollectionDerived extends distExports.GrobCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "nodes_names", {});
  }
}
__decorateClass$2([
  JsonString()
], GrobCollectionDerived.prototype, "name", 2);
__decorateClass$2([
  JsonMappingRecordInArrayOut({ KeyPropertyName: "getName", name: "data", type: GrobJDerivedNode })
], GrobCollectionDerived.prototype, "nodes_names", 2);
class GrobCollectionFixed extends distExports.GrobCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "nodes_names", {});
  }
}
__decorateClass$2([
  JsonString()
], GrobCollectionFixed.prototype, "name", 2);
__decorateClass$2([
  JsonMappingRecordInArrayOut({ KeyPropertyName: "getName", name: "data", type: GrobJFixedNode })
], GrobCollectionFixed.prototype, "nodes_names", 2);
class GrobGroupDerived extends distExports.GrobGroup {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "collections_names", {});
  }
}
__decorateClass$2([
  JsonString()
], GrobGroupDerived.prototype, "name", 2);
__decorateClass$2([
  JsonMappingRecordInArrayOut({ KeyPropertyName: "getName", name: "data", type: GrobCollectionDerived })
], GrobGroupDerived.prototype, "collections_names", 2);
class GrobGroupFixed extends distExports.GrobGroup {
  constructor() {
    super(...arguments);
    __publicField(this, "name");
    __publicField(this, "collections_names", {});
  }
}
__decorateClass$2([
  JsonString()
], GrobGroupFixed.prototype, "name", 2);
__decorateClass$2([
  JsonMappingRecordInArrayOut({ KeyPropertyName: "getName", name: "data", type: GrobCollectionFixed })
], GrobGroupFixed.prototype, "collections_names", 2);
class TTRPG_SCHEMES {
}
__publicField(TTRPG_SCHEMES, "PREVIEW", "mini");
let TTRPGSystemJSONFormatting = class extends distExports.TTRPGSystem {
  constructor() {
    super();
    __publicField(this, "fixed");
    __publicField(this, "derived");
    __publicField(this, "author", "");
    __publicField(this, "version", "");
    __publicField(this, "systemCodeName", distExports.uuidv4());
    __publicField(this, "systemName", "");
  }
  setDefaultValues(defualtValues) {
    const colKeys = Object.keys(this.derived.collections_names);
    for (let c = 0; c < Object.keys(this.derived.collections_names).length; c++) {
      const colKey = colKeys[c];
      const collection = this.derived.collections_names[colKey];
      const nodeKeys = Object.keys(collection.nodes_names);
      for (let i = 0; i < nodeKeys.length; i++) {
        const nodeKey = nodeKeys[i];
        collection.nodes_names[nodeKey];
      }
    }
  }
};
__decorateClass$2([
  JsonClassTyped(GrobGroupFixed)
], TTRPGSystemJSONFormatting.prototype, "fixed", 2);
__decorateClass$2([
  JsonClassTyped(GrobGroupDerived)
], TTRPGSystemJSONFormatting.prototype, "derived", 2);
__decorateClass$2([
  JsonString(),
  JsonString({ scheme: [BASE_SCHEME, TTRPG_SCHEMES.PREVIEW] })
], TTRPGSystemJSONFormatting.prototype, "author", 2);
__decorateClass$2([
  JsonString(),
  JsonString({ scheme: [BASE_SCHEME, TTRPG_SCHEMES.PREVIEW] })
], TTRPGSystemJSONFormatting.prototype, "version", 2);
__decorateClass$2([
  JsonString(),
  JsonString({ scheme: [BASE_SCHEME, TTRPG_SCHEMES.PREVIEW] })
], TTRPGSystemJSONFormatting.prototype, "systemCodeName", 2);
__decorateClass$2([
  JsonString(),
  JsonString({ scheme: [BASE_SCHEME, TTRPG_SCHEMES.PREVIEW] })
], TTRPGSystemJSONFormatting.prototype, "systemName", 2);
TTRPGSystemJSONFormatting = __decorateClass$2([
  JsonObject({
    onBeforeSerialization: (self) => {
    },
    onAfterDeSerialization: (self, ...args) => {
      var _a;
      if (!self.fixed) {
        self._createGroup("fixed");
        self.fixed = self._getGroup("fixed");
      } else {
        self.data["fixed"] = self.fixed;
      }
      if (!self.derived) {
        self._createGroup("derived");
        self.derived = self._getGroup("derived");
      } else {
        self.data["derived"] = self.derived;
      }
      for (const group_key in self.data) {
        const group = self.data[group_key];
        group.parent = self;
        for (const col_key in group.collections_names) {
          const collection = group.collections_names[col_key];
          collection.parent = group;
          group.collections_names[collection.getName()] = collection;
          for (const node_key in collection.nodes_names) {
            const node = collection.nodes_names[node_key];
            node.parent = collection;
            collection.nodes_names[node.getName()] = node;
            const origins = (_a = node.origins) != null ? _a : [];
            origins.forEach((origin2) => {
              let keys = origin2.originKey.split(".");
              const target = self.getNode(keys[0], keys[1], keys[2]);
              origin2.origin = target;
              node.addDependency(target);
            });
          }
        }
      }
      Object.values(self.data);
    }
  })
], TTRPGSystemJSONFormatting);
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
class SystemPreviewSchemes {
}
__publicField(SystemPreviewSchemes, "BASE", BASE_SCHEME);
__publicField(SystemPreviewSchemes, "PAGE", "PAGE");
let SystemPreview = class {
  constructor() {
    __publicField(this, "id");
    __publicField(this, "filePath");
    __publicField(this, "isEditable", true);
    __publicField(this, "author");
    __publicField(this, "version");
    __publicField(this, "code");
    __publicField(this, "name");
    __publicField(this, "folderPath");
    __publicField(this, "folderName");
  }
  init() {
    this.author = "grobax";
    this.version = "0.0.1";
    this.code = "grobdnd";
    this.name = "Grobax' DnD TTPRPG";
  }
};
__decorateClass$1([
  JsonNumber({ scheme: [SystemPreviewSchemes.BASE, SystemPreviewSchemes.PAGE] })
], SystemPreview.prototype, "id", 2);
__decorateClass$1([
  JsonBoolean({ scheme: [SystemPreviewSchemes.BASE] })
], SystemPreview.prototype, "isEditable", 2);
__decorateClass$1([
  JsonString({ scheme: [SystemPreviewSchemes.BASE] })
], SystemPreview.prototype, "author", 2);
__decorateClass$1([
  JsonString({ scheme: [SystemPreviewSchemes.BASE, SystemPreviewSchemes.PAGE] })
], SystemPreview.prototype, "version", 2);
__decorateClass$1([
  JsonString({ scheme: [SystemPreviewSchemes.BASE, SystemPreviewSchemes.PAGE] })
], SystemPreview.prototype, "code", 2);
__decorateClass$1([
  JsonString({ scheme: [SystemPreviewSchemes.BASE, SystemPreviewSchemes.PAGE] })
], SystemPreview.prototype, "name", 2);
SystemPreview = __decorateClass$1([
  JsonObject({})
], SystemPreview);
function create_fragment$j(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let p;
  let t2;
  let div2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("X2");
      t1 = space();
      div1 = element("div");
      p = element("p");
      t2 = text(ctx[1]);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, "data-active": true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "X2");
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      p = claim_element(div1_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, ctx[1]);
      p_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "MenuBtnIcon");
      attr(div1, "class", "MenuBtnText");
      attr(div2, "class", div2_class_value = ctx[0] ? "MenuSBtn" : "MenuBtn");
      attr(div2, "data-active", ctx[2]);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, p);
      append_hydration(p, t2);
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[3]),
          listen(div2, "keypress", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t2, ctx2[1]);
      if (dirty & 1 && div2_class_value !== (div2_class_value = ctx2[0] ? "MenuSBtn" : "MenuBtn")) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty & 4) {
        attr(div2, "data-active", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { special = false } = $$props;
  let { text: text2 = "Basic information and settings" } = $$props;
  let { title = "Home" } = $$props;
  let active2;
  function setActive(to) {
    $$invalidate(2, active2 = to);
  }
  let dispatch2 = createEventDispatcher();
  function onClick() {
    dispatch2("click");
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("special" in $$props2)
      $$invalidate(0, special = $$props2.special);
    if ("text" in $$props2)
      $$invalidate(4, text2 = $$props2.text);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
  };
  return [special, title, active2, onClick, text2, setActive, keypress_handler];
}
class MenuBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
      special: 0,
      text: 4,
      title: 1,
      setActive: 5
    });
  }
  get setActive() {
    return this.$$.ctx[5];
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[12] = list;
  child_ctx[13] = i;
  return child_ctx;
}
function create_if_block$c(ctx) {
  let div;
  let p;
  let t;
  return {
    c() {
      div = element("div");
      p = element("p");
      t = text(ctx[0]);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      p = claim_element(div_nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, ctx[0]);
      p_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "MenuTitle");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, p);
      append_hydration(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$4(ctx) {
  let menubtn;
  let i = ctx[13];
  let current;
  const assign_menubtn = () => ctx[7](menubtn, i);
  const unassign_menubtn = () => ctx[7](null, i);
  function click_handler() {
    return ctx[8](ctx[13]);
  }
  let menubtn_props = {
    special: ctx[1].includes(ctx[11]),
    title: ctx[11]
  };
  menubtn = new MenuBtn({ props: menubtn_props });
  assign_menubtn();
  menubtn.$on("click", click_handler);
  return {
    c() {
      create_component(menubtn.$$.fragment);
    },
    l(nodes) {
      claim_component(menubtn.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(menubtn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (i !== ctx[13]) {
        unassign_menubtn();
        i = ctx[13];
        assign_menubtn();
      }
      const menubtn_changes = {};
      if (dirty & 10)
        menubtn_changes.special = ctx[1].includes(ctx[11]);
      if (dirty & 8)
        menubtn_changes.title = ctx[11];
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      unassign_menubtn();
      destroy_component(menubtn, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div;
  let t;
  let section;
  let current;
  let if_block = ctx[0] && create_if_block$c(ctx);
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      section = element("section");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      section = claim_element(div_nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(section_nodes);
      }
      section_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(section, "class", "MenuBtnContainer");
      attr(div, "class", "Menu");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration(div, t);
      append_hydration(div, section);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$c(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 30) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(section, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let options;
  let { title = null } = $$props;
  let { regularOptions = [] } = $$props;
  let { specialOptions = [] } = $$props;
  let { startChosen = "" } = $$props;
  let dispatch2 = createEventDispatcher();
  let btnArr = [];
  let chosen = null;
  function onBtnClick(i) {
    const btn = btnArr[i];
    if (btn == chosen) {
      return;
    }
    if (chosen)
      chosen.setActive(false);
    btn.setActive(true);
    chosen = btn;
    dispatch2("changePage", options[i]);
  }
  onMount(() => {
    let i = options.findIndex((p) => p == startChosen);
    if (i != -1) {
      onBtnClick(i);
    }
  });
  function menubtn_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btnArr[i] = $$value;
      $$invalidate(2, btnArr);
    });
  }
  const click_handler = (i) => onBtnClick(i);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("regularOptions" in $$props2)
      $$invalidate(5, regularOptions = $$props2.regularOptions);
    if ("specialOptions" in $$props2)
      $$invalidate(1, specialOptions = $$props2.specialOptions);
    if ("startChosen" in $$props2)
      $$invalidate(6, startChosen = $$props2.startChosen);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 34) {
      $$invalidate(3, options = regularOptions.concat(...specialOptions));
    }
  };
  return [
    title,
    specialOptions,
    btnArr,
    options,
    onBtnClick,
    regularOptions,
    startChosen,
    menubtn_binding,
    click_handler
  ];
}
class Menu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, {
      title: 0,
      regularOptions: 5,
      specialOptions: 1,
      startChosen: 6
    });
  }
}
function pageSlide(node, params) {
  const rect = node.getBoundingClientRect();
  const height = rect.height;
  const width = rect.width;
  const parent = params.parent;
  if (parent) {
    const origTransition = parent.style.transition;
    const origHeight = parent.style.height;
    parent.style.transition += " ease " + (params.duration || 400) / 1e3 + "s height";
    parent.style.height = height + "px";
    setTimeout(
      () => {
        parent.style.transition = origTransition;
        parent.style.height = origHeight;
      },
      params.duration || 400
    );
  }
  return {
    delay: params.delay || 0,
    duration: params.duration || 400,
    easing: params.easing || cubicOut,
    css: (t, u) => `
			height:${height}px;
			width:${width}px;
			position:absolute;
			transform-origin: top;
			transform: translateX(${u * width}px);
			`
  };
}
class AItemController {
  constructor() {
    __publicField(this, "uiNode");
    __publicField(this, "node");
    __publicField(this, "system");
    __publicField(this, "messageHandler", null);
    __publicField(this, "isValid", writable(true));
    __publicField(this, "name", writable(""));
    __publicField(this, "standardValue", writable(1));
    __publicField(this, "_outList", /* @__PURE__ */ new Set());
  }
  setControllerDeps(uiNode, system, out) {
    var _a, _b;
    this.uiNode = uiNode;
    this.node = uiNode.link;
    this.system = system;
    this.isValid.set(true);
    this.name.set((_b = (_a = this.uiNode) == null ? void 0 : _a.name) != null ? _b : "");
    this.standardValue.set(0);
  }
  validateName(name, out) {
    let isValid = true;
    if (name == "") {
      isValid = false;
      out("The name cannot be empty");
    } else if (name.includes(".")) {
      isValid = false;
      out('The name cannot contain "."');
    } else if (this.uiNode.parent.hasNode(name) && name != this.uiNode.name) {
      isValid = false;
      out("The name is already in use, in the same collection");
    }
    return isValid;
  }
  _checkIsValid(output = true) {
    var _a;
    if (!this.uiNode || !this.system) {
      return false;
    }
    let isValid = true;
    let _out = output ? (msg) => {
      this._outList.add(msg);
    } : (msg) => {
    };
    isValid = isValid && this.validateName((_a = get_store_value(this.name)) != null ? _a : "", _out);
    return isValid;
  }
  checkIsValid(output = true) {
    var _a;
    if (output) {
      (_a = this.messageHandler) == null ? void 0 : _a.removeAllMessages();
    }
    let valid = this._checkIsValid(output);
    this.isValid.set(valid);
    return valid;
  }
}
class FixedItemController extends AItemController {
  saveNodeChanges() {
    let success = this.checkIsValid(true);
    if (!success) {
      return false;
    }
    this.node.setValue(get_store_value(this.standardValue));
    this.node.setName(get_store_value(this.name));
    return true;
  }
}
class DerivedItemController extends AItemController {
  constructor() {
    super(...arguments);
    __publicField(this, "calc", writable(""));
    __publicField(this, "resultValue", writable(0));
    __publicField(this, "resultSuccess", writable(true));
    __publicField(this, "mappedOrigins", writable([]));
  }
  setControllerDeps(node, system, out) {
    var _a, _b;
    super.setControllerDeps(node, system, out);
    this.calc.set((_b = (_a = this.uiNode.link) == null ? void 0 : _a.calc) != null ? _b : "");
    this.resultValue.set(0);
    this.resultSuccess.set(true);
    this.updateMappedOrigins();
  }
  updateMappedOrigins() {
    var _a, _b, _c, _d;
    let m = (_d = (_c = (_b = (_a = this.uiNode) == null ? void 0 : _a.link) == null ? void 0 : _b.origins) == null ? void 0 : _c.map(
      (p) => {
        return {
          key: p.symbol,
          segments: p.originKey.split("."),
          active: get_store_value(this.calc).includes(p.symbol),
          testValue: p.standardValue,
          inCalc: get_store_value(this.calc).includes(p.symbol),
          target: p.origin,
          isSelectAllTarget: true
        };
      }
    )) != null ? _d : [];
    this.mappedOrigins.set(m);
  }
  validateOrigins(mappedOrigins, calc, out) {
    let isValid = true;
    mappedOrigins.forEach((obj) => {
      if (obj.inCalc && !obj.target) {
        out(`Cannot save until all dependencies used in the calc is defined 
 ${obj.key} Had no target 
`);
        isValid = false;
      }
    });
    if (!isValid) {
      return false;
    }
    let NMap = mappedOrigins.filter((p) => calc.includes(p.key));
    NMap.forEach((o) => {
      if (!o.segments) {
        out(`Contents of ${o.key}'s segments was Null!'`);
        isValid = false;
        return false;
      }
      let dep = this.system.getNode(o.segments[0], o.segments[1], o.segments[2]);
      if (!dep) {
        out(`Target of ${o.key} location ${o.segments[0] + "." + o.segments[1] + "." + o.segments[2]} was invalid!'`);
        isValid = false;
        return false;
      }
    });
    return isValid;
  }
  validateCalculation(calc, mappedOrigins, out) {
    let o = {};
    let mappedKeys = [];
    mappedOrigins.forEach((p) => {
      o[p.key] = p.testValue;
      mappedKeys.push(p.key);
    });
    let calcres = GrobJDerivedNode.testCalculate(calc, o);
    let succes = calcres.success;
    let value2 = calcres.value;
    if (!succes) {
      out(`Calculation is invalid, meaning it could not parse`);
    }
    this.resultValue.set(value2);
    this.resultSuccess.set(succes);
    return succes;
  }
  validateCalculationOrigins(calc, mappedOrigins, out) {
    let symbols2 = GrobJDerivedNode.staticParseCalculationToOrigins(calc);
    mappedOrigins.forEach((o) => {
      symbols2 = symbols2.filter((p) => p != o.key);
      out(o.key + "missing");
    });
    let isValid = true;
    symbols2.forEach((s) => {
      isValid = false;
      out(`symbol ${s} was missing from origins `);
    });
    return isValid;
  }
  _checkIsValid(output = true) {
    let _out = output ? (msg) => {
      this._outList.add(msg);
    } : (msg) => {
    };
    let isValid = super._checkIsValid(output);
    isValid = isValid && this.validateOrigins(get_store_value(this.mappedOrigins), get_store_value(this.calc), _out);
    isValid = isValid && this.validateCalculationOrigins(get_store_value(this.calc), get_store_value(this.mappedOrigins), _out);
    isValid = isValid && this.validateCalculation(get_store_value(this.calc), get_store_value(this.mappedOrigins), _out);
    return isValid;
  }
  checkIsValid(output = true) {
    var _a;
    if (output) {
      (_a = this.messageHandler) == null ? void 0 : _a.removeAllMessages();
    }
    let valid = this._checkIsValid(output);
    this.isValid.set(valid);
    return valid;
  }
  saveNodeChanges() {
    let success = this.checkIsValid(true);
    if (!success) {
      return false;
    }
    this.node.setValue(get_store_value(this.standardValue));
    this.node.setCalc(get_store_value(this.calc));
    let NMap = get_store_value(this.mappedOrigins).filter((p) => p.inCalc);
    NMap.forEach((o) => {
      var _a;
      let dep = this.system.sys.getNode(o.segments[0], o.segments[1], o.segments[2]);
      this.node.setOrigin(o.key, dep, (_a = o.testValue) != null ? _a : 0);
    });
    this.node.setName(get_store_value(this.name));
    this.uiNode.name = get_store_value(this.name);
    return true;
  }
  onKeyExchange(e) {
    this.mappedOrigins.update((mappedOrigins) => {
      const s0 = e.detail.old;
      const s1 = e.detail.new;
      let t0 = mappedOrigins.find((p) => p.key == s0);
      if (!t0)
        return mappedOrigins;
      let t1 = mappedOrigins.find((p) => p.key == s1);
      if (!t1)
        return mappedOrigins;
      t0.key = s1;
      t0.inCalc = get_store_value(this.calc).includes(s1);
      t1.key = s0;
      t1.inCalc = get_store_value(this.calc).includes(s0);
      return mappedOrigins;
    });
    return;
  }
  onKeyDelete(e) {
    this.mappedOrigins.update((mappedOrigins) => {
      const key = e.detail;
      let old = mappedOrigins.find((p) => p.key == key);
      if (!old)
        return mappedOrigins;
      if (!old.active || !old.inCalc) {
        mappedOrigins = mappedOrigins.filter((p) => p.key != old.key);
      } else {
        old.active = false;
        old.segments = new Array(3).fill(null);
      }
      return mappedOrigins;
    });
  }
  recalculateCalcAndOrigins() {
    let o = {};
    get_store_value(this.mappedOrigins).forEach((p) => {
      o[p.key] = p.testValue;
    });
    let calc = get_store_value(this.calc);
    let res2 = GrobJDerivedNode.testCalculate(calc, o);
    this.resultValue.set(res2.value);
    this.resultSuccess.set(res2.success);
    let symbols2 = GrobJDerivedNode.staticParseCalculationToOrigins(calc);
    this.mappedOrigins.update((mappedOrigins) => {
      mappedOrigins.forEach((d) => {
        let inCalc = symbols2.includes(d.key);
        if (inCalc) {
          symbols2 = symbols2.filter((p) => p != d.key);
          d.inCalc = true;
        } else {
          d.inCalc = false;
        }
      });
      symbols2.forEach((s) => {
        mappedOrigins.push({ key: s, segments: new Array(3).fill(null), active: false, testValue: 1, inCalc: true, target: null, isSelectAllTarget: true });
      });
      return mappedOrigins;
    });
  }
}
class StringFunctions {
  static isValidWindowsFileString(str) {
    if (!str)
      return false;
    const invalidCharsRegex = /[<>:"/\\|?*\x00-\x1F]/g;
    return !invalidCharsRegex.test(str) && !/^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i.test(str) && str.length <= 255;
  }
  static isValidSystemCodeName(str) {
    if (!str)
      return false;
    const regex = /[^a-zA-Z0-9]/;
    return !regex.test(str);
  }
  static ConvertToValidWindowsFileString(str) {
    const invalidCharsRegex = /[<>:"/\\|?*\x00-\x1F]/g;
    const validStr = str.replace(invalidCharsRegex, "_");
    return validStr.slice(0, 255);
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  static uuidShort() {
    return "xxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  static recursiveFindNewName_LOOP(testName, counter, array, getName) {
    let i = array.findIndex((p) => getName(p) == testName + counter);
    if (i == -1)
      return testName + counter;
    return this.recursiveFindNewName_LOOP(testName, ++counter, array, getName);
  }
  static recursiveFindNewName(testName, array, getName) {
    let i = array.findIndex((p) => getName(p) == testName);
    if (i == -1)
      return testName;
    return this.recursiveFindNewName_LOOP(testName, 0, array, getName);
  }
}
class UpdateListener {
  constructor() {
    __publicField(this, "guid", StringFunctions.uuidv4());
    __publicField(this, "listenersKeyed", {});
    __publicField(this, "listenersEvents", {});
  }
  callUpdateListeners(event) {
    if (!this.listenersEvents[event]) {
      return;
    }
    const keys = Object.keys(this.listenersEvents[event]);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.listenersEvents[event][key].call();
    }
  }
  addEventListener(key, event, listener) {
    if (!this.listenersEvents[event]) {
      this.listenersEvents[event] = {};
    }
    if (!this.listenersKeyed[key]) {
      this.listenersKeyed[key] = {};
    }
    this.listenersKeyed[key][event] = listener;
    this.listenersEvents[event][key] = listener;
  }
  removeEventListener(key) {
    var _a;
    let events = Object.keys((_a = this.listenersKeyed[key]) != null ? _a : {});
    for (let i = 0; i < events.length; i++) {
      const e = events[i];
      delete this.listenersEvents[e][key];
    }
    delete this.listenersKeyed[key];
  }
  removeAllEventListeners() {
    this.listenersKeyed = {};
    this.listenersEvents = {};
  }
}
var updateEvents = /* @__PURE__ */ ((updateEvents2) => {
  updateEvents2["validChange"] = "ValidUpdated";
  updateEvents2["update"] = "update";
  return updateEvents2;
})(updateEvents || {});
class UINode extends UpdateListener {
  constructor(system, node) {
    super();
    __publicField(this, "sys");
    __publicField(this, "link");
    __publicField(this, "key");
    __publicField(this, "name");
    __publicField(this, "nameEdit");
    __publicField(this, "valid");
    __publicField(this, "parent");
    __publicField(this, "_isConstructed", false);
    var names = Object.keys(node.updateListeners);
    if (names.includes(node.getKey())) {
      throw new Error("was was already created");
    }
    this.link = node;
    this.sys = system;
    this.key = node.getKey();
    this.name = node.getName();
    this.nameEdit = node.getName();
    this.valid = node.isValid();
    this.link.addUpdateListener(this.key, this.update.bind(this));
    this._isConstructed = true;
  }
  update() {
    if (!this._isConstructed) {
      return;
    }
    let validOrig = this.valid;
    this.key = this.link.getKey();
    this.name = this.link.getName();
    this.nameEdit = this.link.getName();
    this.valid = this.link.isValid();
    if (validOrig != this.valid) {
      this.callUpdateListeners(updateEvents.validChange);
    }
    this.callUpdateListeners(updateEvents.update);
  }
  dispose() {
    this.removeAllEventListeners();
    this.link.removeUpdateListener(this.key);
    this.link = null;
    this.sys = null;
    this.parent = null;
  }
}
class UICollection extends UpdateListener {
  constructor(system, col) {
    super();
    __publicField(this, "sys");
    __publicField(this, "link");
    __publicField(this, "derivedCol");
    __publicField(this, "nodes", []);
    __publicField(this, "key");
    __publicField(this, "name");
    __publicField(this, "nameEdit");
    __publicField(this, "valid");
    __publicField(this, "parent");
    __publicField(this, "_isConstructed", false);
    this.sys = system;
    this.link = col;
    this.key = col.getKey();
    this.name = col.getName();
    this.nameEdit = this.name;
    var isValid = true;
    var nodeNames = col.getNodeNames();
    for (let i = 0; i < nodeNames.length; i++) {
      const n = nodeNames[i];
      const node = col.getNode(n);
      if (!node)
        continue;
      const uinode = this._addNode(node, this.sys);
      isValid = isValid && uinode.valid;
    }
    this.valid = isValid;
    this._isConstructed = true;
  }
  isValidUpdate() {
    var orig = this.valid;
    var isValid = true;
    this.nodes.forEach((p) => {
      isValid = isValid && p.valid;
    });
    this.valid = isValid;
    if (orig != this.valid) {
      this.callUpdateListeners(updateEvents.validChange);
    }
  }
  update() {
    if (!this._isConstructed) {
      return;
    }
    this.key = this.link.getKey();
    this.name = this.link.getName();
    this.nameEdit = this.link.getName();
    const nodeNames = this.link.getNodeNames();
    for (let i = 0; i < nodeNames.length; i++) {
      const n = nodeNames[i];
      if (this._hasNode(n)) {
        continue;
      }
      const nod = this.link.getNode(n);
      if (!nod)
        continue;
      console.log(nod.getKey());
      this._addNode(nod, this.sys);
    }
    this.isValidUpdate();
    this.callUpdateListeners(updateEvents.update);
  }
  dispose() {
    this.link.removeUpdateListener(this.key);
    this.removeAllEventListeners();
    this.nodes.forEach((n) => n.dispose());
    this.link = null;
    this.sys = null;
    this.nodes = [];
    this.parent = null;
  }
  getNode(name) {
    return this.parent.parent.getNode(this.parent.name, this.name, name);
  }
  hasNode(name) {
    return this.parent.parent.hasNode(this.parent.name, this.name, name);
  }
  addNode(name) {
    return this.parent.parent.addNode(this.parent.name, this.name, name);
  }
  remNode(name) {
    return this.parent.parent.remNode(this.parent.name, this.name, name);
  }
  renameNode(name, rename) {
    return this.parent.parent.renameNode(this.parent.name, this.name, name, rename);
  }
  _getNode(name) {
    return this.nodes.find((p) => p.name == name);
  }
  _hasNode(name) {
    return !!this.nodes.find((p) => p.name == name);
  }
  _addNode(link, system) {
    let uNode = new UINode(system, link);
    this.nodes.push(uNode);
    uNode.addEventListener(this.key, updateEvents.validChange, this.isValidUpdate.bind(this));
    uNode.parent = this;
    this.update();
    return uNode;
  }
  _remNode(name) {
    let uNode = this.nodes.find((p) => p.name == name);
    this.nodes = this.nodes.filter((p) => p.name != name);
    uNode == null ? void 0 : uNode.removeEventListener(this.key);
    uNode == null ? void 0 : uNode.dispose();
    this.update();
  }
}
class UIGroup extends UpdateListener {
  constructor(system, group) {
    super();
    __publicField(this, "sys");
    __publicField(this, "link");
    __publicField(this, "collections", []);
    __publicField(this, "key");
    __publicField(this, "name");
    __publicField(this, "nameEdit");
    __publicField(this, "valid");
    __publicField(this, "parent");
    __publicField(this, "_isConstructed", false);
    this.sys = system;
    this.link = group;
    this.key = group.getKey();
    this.name = group.getName();
    this.nameEdit = this.name;
    var isValid = true;
    var colNames = group.getCollectionsNames();
    for (let i = 0; i < colNames.length; i++) {
      const n = colNames[i];
      const col = group.getCollection(n);
      if (!col)
        continue;
      const uicol = this._addCollection(this.sys, col);
      isValid = isValid && uicol.valid;
    }
    this.link.addUpdateListener(this.key, this.update.bind(this));
    this.valid = isValid;
    this._isConstructed = true;
  }
  isValidUpdate() {
    let orig = this.valid;
    var isValid = true;
    this.collections.forEach((p) => {
      isValid = isValid && p.valid;
    });
    this.valid = isValid;
    if (orig != this.valid) {
      this.callUpdateListeners(updateEvents.validChange);
    }
  }
  update() {
    if (!this._isConstructed) {
      return;
    }
    this.key = this.link.getKey();
    this.name = this.link.getName();
    this.nameEdit = this.link.getName();
    var colNames = this.link.getCollectionsNames();
    for (let i = 0; i < colNames.length; i++) {
      const n = colNames[i];
      if (this._hasCollection(n)) {
        continue;
      }
      const col = this.link.getCollection(n);
      if (!col)
        continue;
      this._addCollection(this.sys, col);
    }
    this.isValidUpdate();
    this.callUpdateListeners(updateEvents.update);
  }
  dispose() {
    this.removeAllEventListeners();
    this.collections.forEach((n) => n.dispose());
    this.link = null;
    this.sys = null;
    this.collections = [];
    this.parent = null;
  }
  getCollection(group, col) {
    this.parent.getCollection(group, col);
  }
  hasCollection(group, col) {
    this.parent.hasCollection(group, col);
  }
  addCollection(group, col) {
    this.parent.addCollection(group, col);
  }
  remCollection(group, col) {
    this.parent.remCollection(group, col);
  }
  _getCollection(col) {
    return this.collections.find((p) => p.name == col);
  }
  _hasCollection(col) {
    return !!this.collections.find((p) => p.name == col);
  }
  _addCollection(system, col) {
    let uCol = new UICollection(system, col);
    this.collections.push(uCol);
    uCol.addEventListener(this.key, updateEvents.validChange, this.isValidUpdate.bind(this));
    uCol.parent = this;
    return uCol;
  }
  _remCollection(col) {
    let uCol = this.collections.find((p) => p.name == col);
    this.collections = this.collections.filter((p) => p.name != col);
    uCol == null ? void 0 : uCol.removeEventListener(this.key);
    uCol == null ? void 0 : uCol.dispose();
    this.update();
  }
}
class UISystem extends UpdateListener {
  constructor(system) {
    super();
    __publicField(this, "sys");
    __publicField(this, "groups", []);
    __publicField(this, "valid", true);
    this.sys = system;
    this.valid = true;
    let groups = ["derived", "fixed"];
    for (let i = 0; i < groups.length; i++) {
      const grp = this.sys.data[groups[i]];
      const uigrp = new UIGroup(this, grp);
      this.groups.push(uigrp);
      this.valid = this.valid && uigrp.valid;
      uigrp.addEventListener(this.guid, updateEvents.validChange, this.update.bind(this));
      uigrp.parent = this;
    }
  }
  update() {
    let orig = this.valid;
    var isValid = true;
    this.groups.forEach((p) => {
      isValid = isValid && p.valid;
    });
    this.valid = isValid;
    if (orig != this.valid) {
      this.callUpdateListeners(updateEvents.validChange);
    }
    this.callUpdateListeners(updateEvents.update);
  }
  getGroup(name) {
    return this.groups.find((p) => p.name == name);
  }
  hasGroup(name) {
    return !!this.getGroup(name);
  }
  getCollection(group, col) {
    var _a;
    return (_a = this.getGroup(group)) == null ? void 0 : _a._getCollection(col);
  }
  hasCollection(group, col) {
    return !!this.getCollection(group, col);
  }
  addCollection(group, col) {
    if (!col) {
      const names = this.sys.getCollectionNames(group);
      col = StringFunctions.recursiveFindNewName("new Collection", names, (e) => e);
    }
    this.sys.createCollection(group, col);
  }
  remCollection(group, col) {
    var _a;
    (_a = this.getGroup(group)) == null ? void 0 : _a._remCollection(col);
  }
  renameCollection(group, col, rename) {
    this.sys.renameCollection(group, col, rename);
  }
  getNode(group, col, name) {
    var _a, _b;
    return (_b = (_a = this.getGroup(group)) == null ? void 0 : _a._getCollection(col)) == null ? void 0 : _b._getNode(name);
  }
  hasNode(group, col, name) {
    return !!this.getNode(group, col, name);
  }
  addNode(group, col, name) {
    var _a, _b, _c;
    if (!name) {
      const names = (_a = this.sys.getNodeNames(group, col)) != null ? _a : [];
      name = StringFunctions.recursiveFindNewName("new node", names, (e) => e);
    }
    this.sys.createNode(group, col, name);
    const node = this.sys.getNode(group, col, name);
    if (!node) {
      console.error("could not add new node");
      return;
    }
    (_c = (_b = this.getGroup(group)) == null ? void 0 : _b._getCollection(col)) == null ? void 0 : _c._addNode(node, this);
  }
  remNode(group, col, name) {
    var _a, _b;
    this.sys.deleteNode(group, col, name);
    (_b = (_a = this.getGroup(group)) == null ? void 0 : _a._getCollection(col)) == null ? void 0 : _b._remNode(name);
  }
  renameNode(group, col, name, rename) {
    this.sys.renameItem(group, col, name, rename);
  }
}
function create_fragment$h(ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let div7;
  let div0;
  let p;
  let t0;
  let t1;
  let div5;
  let div1;
  let t2;
  let t3;
  let input0;
  let t4;
  let div2;
  let t5;
  let t6;
  let div3;
  let t7_value = ((_d = (_c = (_b = (_a = ctx[0].link) == null ? void 0 : _a.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.name) != null ? _d : "unknown collection") + "." + ((_g = (_f = (_e = ctx[0].link) == null ? void 0 : _e.parent) == null ? void 0 : _f.name) != null ? _g : "unknown collection") + "." + ((_h = ctx[0]) == null ? void 0 : _h.name);
  let t7;
  let t8;
  let div4;
  let t9;
  let t10;
  let input1;
  let t11;
  let div6;
  let button0;
  let t12;
  let button0_disabled_value;
  let t13;
  let button1;
  let t14;
  let t15;
  let br0;
  let br1;
  let mounted;
  let dispose;
  return {
    c() {
      div7 = element("div");
      div0 = element("div");
      p = element("p");
      t0 = text("Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      t1 = space();
      div5 = element("div");
      div1 = element("div");
      t2 = text("Node Name");
      t3 = space();
      input0 = element("input");
      t4 = space();
      div2 = element("div");
      t5 = text("Node Location");
      t6 = space();
      div3 = element("div");
      t7 = text(t7_value);
      t8 = space();
      div4 = element("div");
      t9 = text("Standard Value");
      t10 = space();
      input1 = element("input");
      t11 = space();
      div6 = element("div");
      button0 = element("button");
      t12 = text("save changes");
      t13 = space();
      button1 = element("button");
      t14 = text("delete");
      t15 = space();
      br0 = element("br");
      br1 = element("br");
      this.h();
    },
    l(nodes) {
      div7 = claim_element(nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div0 = claim_element(div7_nodes, "DIV", {});
      var div0_nodes = children(div0);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, "Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      p_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t1 = claim_space(div7_nodes);
      div5 = claim_element(div7_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div1 = claim_element(div5_nodes, "DIV", {});
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "Node Name");
      div1_nodes.forEach(detach);
      t3 = claim_space(div5_nodes);
      input0 = claim_element(div5_nodes, "INPUT", {
        type: true,
        class: true,
        contenteditable: true
      });
      t4 = claim_space(div5_nodes);
      div2 = claim_element(div5_nodes, "DIV", {});
      var div2_nodes = children(div2);
      t5 = claim_text(div2_nodes, "Node Location");
      div2_nodes.forEach(detach);
      t6 = claim_space(div5_nodes);
      div3 = claim_element(div5_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      t7 = claim_text(div3_nodes, t7_value);
      div3_nodes.forEach(detach);
      t8 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", {});
      var div4_nodes = children(div4);
      t9 = claim_text(div4_nodes, "Standard Value");
      div4_nodes.forEach(detach);
      t10 = claim_space(div5_nodes);
      input1 = claim_element(div5_nodes, "INPUT", {
        type: true,
        class: true,
        contenteditable: true
      });
      div5_nodes.forEach(detach);
      t11 = claim_space(div7_nodes);
      div6 = claim_element(div7_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      button0 = claim_element(div6_nodes, "BUTTON", {});
      var button0_nodes = children(button0);
      t12 = claim_text(button0_nodes, "save changes");
      button0_nodes.forEach(detach);
      t13 = claim_space(div6_nodes);
      button1 = claim_element(div6_nodes, "BUTTON", {});
      var button1_nodes = children(button1);
      t14 = claim_text(button1_nodes, "delete");
      button1_nodes.forEach(detach);
      div6_nodes.forEach(detach);
      t15 = claim_space(div7_nodes);
      br0 = claim_element(div7_nodes, "BR", {});
      br1 = claim_element(div7_nodes, "BR", {});
      div7_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input0, "type", "text");
      attr(input0, "class", "ItemDesignerInput");
      attr(input0, "contenteditable", "");
      attr(div3, "class", "ItemDesignerInput");
      attr(input1, "type", "number");
      attr(input1, "class", "ItemDesignerInput");
      attr(input1, "contenteditable", "");
      attr(div5, "class", "ItemDesignerDataColumns");
      button0.disabled = button0_disabled_value = !ctx[6];
      attr(div6, "class", "ItemDesignerButtonRow");
      attr(div7, "class", "itemDesigner");
    },
    m(target, anchor) {
      insert_hydration(target, div7, anchor);
      append_hydration(div7, div0);
      append_hydration(div0, p);
      append_hydration(p, t0);
      append_hydration(div7, t1);
      append_hydration(div7, div5);
      append_hydration(div5, div1);
      append_hydration(div1, t2);
      append_hydration(div5, t3);
      append_hydration(div5, input0);
      set_input_value(input0, ctx[4]);
      append_hydration(div5, t4);
      append_hydration(div5, div2);
      append_hydration(div2, t5);
      append_hydration(div5, t6);
      append_hydration(div5, div3);
      append_hydration(div3, t7);
      append_hydration(div5, t8);
      append_hydration(div5, div4);
      append_hydration(div4, t9);
      append_hydration(div5, t10);
      append_hydration(div5, input1);
      set_input_value(input1, ctx[5]);
      append_hydration(div7, t11);
      append_hydration(div7, div6);
      append_hydration(div6, button0);
      append_hydration(button0, t12);
      append_hydration(div6, t13);
      append_hydration(div6, button1);
      append_hydration(button1, t14);
      append_hydration(div7, t15);
      append_hydration(div7, br0);
      append_hydration(div7, br1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[7]),
          listen(input0, "input", ctx[17]),
          listen(input1, "input", ctx[8]),
          listen(input1, "input", ctx[18]),
          listen(button0, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      if (dirty & 16 && input0.value !== ctx2[4]) {
        set_input_value(input0, ctx2[4]);
      }
      if (dirty & 1 && t7_value !== (t7_value = ((_d2 = (_c2 = (_b2 = (_a2 = ctx2[0].link) == null ? void 0 : _a2.parent) == null ? void 0 : _b2.parent) == null ? void 0 : _c2.name) != null ? _d2 : "unknown collection") + "." + ((_g2 = (_f2 = (_e2 = ctx2[0].link) == null ? void 0 : _e2.parent) == null ? void 0 : _f2.name) != null ? _g2 : "unknown collection") + "." + ((_h2 = ctx2[0]) == null ? void 0 : _h2.name)))
        set_data(t7, t7_value);
      if (dirty & 32 && to_number(input1.value) !== ctx2[5]) {
        set_input_value(input1, ctx2[5]);
      }
      if (dirty & 64 && button0_disabled_value !== (button0_disabled_value = !ctx2[6])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div7);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let origName;
  let $controllerName, $$unsubscribe_controllerName = noop, $$subscribe_controllerName = () => ($$unsubscribe_controllerName(), $$unsubscribe_controllerName = subscribe(controllerName, ($$value) => $$invalidate(4, $controllerName = $$value)), controllerName);
  let $controllerValue, $$unsubscribe_controllerValue = noop, $$subscribe_controllerValue = () => ($$unsubscribe_controllerValue(), $$unsubscribe_controllerValue = subscribe(controllerValue, ($$value) => $$invalidate(5, $controllerValue = $$value)), controllerValue);
  let $controllerIsValid, $$unsubscribe_controllerIsValid = noop, $$subscribe_controllerIsValid = () => ($$unsubscribe_controllerIsValid(), $$unsubscribe_controllerIsValid = subscribe(controllerIsValid, ($$value) => $$invalidate(6, $controllerIsValid = $$value)), controllerIsValid);
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerName());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerValue());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerIsValid());
  var _a;
  let { node } = $$props;
  let { system } = $$props;
  let { secondSlideInReady = false } = $$props;
  let { goodTitle = "No Error" } = $$props;
  let { badTitle = "Error" } = $$props;
  let { messageHandler } = $$props;
  const dispatch2 = createEventDispatcher();
  let controller = new FixedItemController();
  let controllerName;
  let controllerValue;
  let controllerIsValid;
  function onNameInput(event) {
    let name = event.target.value;
    controller.name.set(name);
    controller.checkIsValid();
  }
  function onStandardValueInput(event) {
    let name = event.target.value;
    controller.name.set(name);
    controller.checkIsValid();
  }
  function onSave() {
    if (controller.saveNodeChanges()) {
      const oldName = origName;
      const newName = get_store_value(controller.name);
      dispatch2("save", { oldName, newName });
      origName = newName;
    }
  }
  onMount(mount);
  function mount() {
    controller.setControllerDeps(node, system, (msg) => {
    });
    controller.checkIsValid();
    $$subscribe_controllerName($$invalidate(1, controllerName = controller.name));
    origName = $controllerName;
    $$subscribe_controllerValue($$invalidate(2, controllerValue = controller.standardValue));
    $$subscribe_controllerIsValid($$invalidate(3, controllerIsValid = controller.isValid));
  }
  function forceUpdate() {
    mount();
  }
  function input0_input_handler() {
    $controllerName = this.value;
    controllerName.set($controllerName);
  }
  function input1_input_handler() {
    $controllerValue = to_number(this.value);
    controllerValue.set($controllerValue);
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("system" in $$props2)
      $$invalidate(10, system = $$props2.system);
    if ("secondSlideInReady" in $$props2)
      $$invalidate(11, secondSlideInReady = $$props2.secondSlideInReady);
    if ("goodTitle" in $$props2)
      $$invalidate(12, goodTitle = $$props2.goodTitle);
    if ("badTitle" in $$props2)
      $$invalidate(13, badTitle = $$props2.badTitle);
    if ("messageHandler" in $$props2)
      $$invalidate(14, messageHandler = $$props2.messageHandler);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65537) {
      origName = $$invalidate(16, _a = node === null || node === void 0 ? void 0 : node.name) !== null && _a !== void 0 ? _a : "";
    }
  };
  return [
    node,
    controllerName,
    controllerValue,
    controllerIsValid,
    $controllerName,
    $controllerValue,
    $controllerIsValid,
    onNameInput,
    onStandardValueInput,
    onSave,
    system,
    secondSlideInReady,
    goodTitle,
    badTitle,
    messageHandler,
    forceUpdate,
    _a,
    input0_input_handler,
    input1_input_handler
  ];
}
class FixedItemDesigner extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, {
      node: 0,
      system: 10,
      secondSlideInReady: 11,
      goodTitle: 12,
      badTitle: 13,
      messageHandler: 14,
      forceUpdate: 15
    });
  }
  get forceUpdate() {
    return this.$$.ctx[15];
  }
}
function selectSlide(node, params, isInTransition = false) {
  var container = params.container;
  var button = params.button;
  const a = getComputedStyle(node).position == "fixed";
  if (a || !container) {
    node.style.transform = "";
    node.style.maxHeight = "";
    console.log("nospecial transition");
    return slide(node, params);
  }
  var existingTransform;
  var transformOrigin;
  if (isInTransition) {
    const mrect = container.getBoundingClientRect();
    const lrect = node.getBoundingClientRect();
    const measureBeneathBottom = lrect.bottom - mrect.bottom;
    const beneathBottom = measureBeneathBottom > 0;
    const measureAboveTop = -1 * (lrect.top - lrect.height) + mrect.top;
    const aboveTop = measureAboveTop > 0;
    var goUp;
    if (beneathBottom && aboveTop) {
      if (measureAboveTop < measureBeneathBottom) {
        goUp = true;
      } else {
        goUp = false;
      }
    } else if (beneathBottom) {
      goUp = true;
    } else {
      goUp = false;
    }
    var maxHeight;
    if (goUp) {
      maxHeight = measureAboveTop > 0 ? lrect.height - measureAboveTop : null;
    } else {
      maxHeight = measureBeneathBottom > 0 ? lrect.height - measureBeneathBottom : null;
    }
    if (maxHeight) {
      node.style.maxHeight = maxHeight;
    }
    if (maxHeight) {
      node.style.maxHeight = maxHeight;
    }
    var height = maxHeight != null ? maxHeight : lrect.height;
    height = goUp ? height * -1 : 0;
    const transform = `translateY(${height}px) translateY(${button.getBoundingClientRect().height * (goUp ? -1 : 0) - (goUp ? 20 : 0)}px) `;
    node.style.transform = transform;
    node.style.width = button.getBoundingClientRect().width + "px";
    node.style.maxHeight = maxHeight + "px";
    transformOrigin = goUp ? "bottom left" : "top left";
    existingTransform = getComputedStyle(node).transform.replace("none", "");
  } else {
    transformOrigin = getComputedStyle(node).transformOrigin;
    existingTransform = getComputedStyle(node).transform.replace("none", "");
  }
  return {
    delay: params.delay || 0,
    duration: params.duration || 400,
    easing: params.easing || cubicOut,
    css: (t, u) => `transform-origin: ${transformOrigin}; transform: ${existingTransform}  scaleY(${t}); opacity: ${t};`
  };
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_key_block$2(ctx) {
  let div;
  let t_value = (ctx[0] == null ? ctx[2] : ctx[0]) + "";
  let t;
  let div_data_isdisabled_value;
  let div_data_iserror_value;
  let div_data_selected_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-isdisabled": true,
        "data-iserror": true,
        "data-selected": true,
        tabindex: true
      });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      var _a, _b, _c;
      attr(div, "class", "GrobSelectLabel effect");
      attr(div, "data-isdisabled", div_data_isdisabled_value = (_a = ctx[3]) != null ? _a : false);
      attr(div, "data-iserror", div_data_iserror_value = (_b = ctx[4]) != null ? _b : false);
      attr(div, "data-selected", div_data_selected_value = (_c = ctx[0]) != null ? _c : false);
      attr(div, "tabindex", "-1");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, t);
      ctx[16](div);
      if (!mounted) {
        dispose = [
          listen(div, "focus", ctx[12]),
          listen(div, "blur", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a, _b, _c;
      if (dirty & 5 && t_value !== (t_value = (ctx2[0] == null ? ctx2[2] : ctx2[0]) + ""))
        set_data(t, t_value);
      if (dirty & 8 && div_data_isdisabled_value !== (div_data_isdisabled_value = (_a = ctx2[3]) != null ? _a : false)) {
        attr(div, "data-isdisabled", div_data_isdisabled_value);
      }
      if (dirty & 16 && div_data_iserror_value !== (div_data_iserror_value = (_b = ctx2[4]) != null ? _b : false)) {
        attr(div, "data-iserror", div_data_iserror_value);
      }
      if (dirty & 1 && div_data_selected_value !== (div_data_selected_value = (_c = ctx2[0]) != null ? _c : false)) {
        attr(div, "data-selected", div_data_selected_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$b(ctx) {
  let div2;
  let div1;
  let t;
  let div0;
  let div2_transition;
  let current;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].length == 0)
      return create_if_block_1$8;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if_block.c();
      t = space();
      div0 = element("div");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, "data-direction": true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "selectEndTracker");
      attr(div2, "class", "SelectPopUp");
      attr(div2, "data-direction", "down");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div1);
      if_block.m(div1, null);
      append_hydration(div1, t);
      append_hydration(div1, div0);
      ctx[18](div0);
      ctx[19](div2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div1, t);
        }
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        var _a;
        if (!current)
          return;
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(
            div2,
            selectSlide,
            {
              container: (_a = ctx[6]) == null ? void 0 : _a.mainAppContainer,
              button: ctx[10]
            },
            true
          );
        div2_transition.run(1);
      });
      current = true;
    },
    o(local) {
      var _a;
      if (!div2_transition)
        div2_transition = create_bidirectional_transition(
          div2,
          selectSlide,
          {
            container: (_a = ctx[6]) == null ? void 0 : _a.mainAppContainer,
            button: ctx[10]
          },
          false
        );
      div2_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
      ctx[18](null);
      ctx[19](null);
      if (detaching && div2_transition)
        div2_transition.end();
    }
  };
}
function create_else_block$4(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[23];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16387) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
      }
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$8(ctx) {
  let i;
  let t;
  return {
    c() {
      i = element("i");
      t = text("No Options");
      this.h();
    },
    l(nodes) {
      i = claim_element(nodes, "I", { class: true });
      var i_nodes = children(i);
      t = claim_text(i_nodes, "No Options");
      i_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(i, "class", "GrobSelectInfo");
    },
    m(target, anchor) {
      insert_hydration(target, i, anchor);
      append_hydration(i, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i);
    }
  };
}
function create_each_block$3(key_1, ctx) {
  let button;
  let t0_value = ctx[23] + "";
  let t0;
  let t1;
  let button_data_selected_value;
  let button_data_value_value;
  let mounted;
  let dispose;
  function focus_handler(...args) {
    return ctx[17](ctx[23], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "data-selected": true,
        "data-value": true
      });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "GrobSelectOption");
      attr(button, "data-selected", button_data_selected_value = ctx[0] == ctx[23]);
      attr(button, "data-value", button_data_value_value = ctx[23]);
      this.first = button;
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, t0);
      append_hydration(button, t1);
      if (!mounted) {
        dispose = listen(button, "focus", focus_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[23] + ""))
        set_data(t0, t0_value);
      if (dirty & 3 && button_data_selected_value !== (button_data_selected_value = ctx[0] == ctx[23])) {
        attr(button, "data-selected", button_data_selected_value);
      }
      if (dirty & 2 && button_data_value_value !== (button_data_value_value = ctx[23])) {
        attr(button, "data-value", button_data_value_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$g(ctx) {
  let div1;
  let previous_key = ctx[0];
  let t;
  let div0;
  let current;
  let key_block = create_key_block$2(ctx);
  let if_block = (ctx[8] || ctx[5]) && create_if_block$b(ctx);
  return {
    c() {
      div1 = element("div");
      key_block.c();
      t = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      key_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "GrobSelect");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      key_block.m(div1, null);
      append_hydration(div1, t);
      append_hydration(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      ctx[20](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        key_block.d(1);
        key_block = create_key_block$2(ctx2);
        key_block.c();
        key_block.m(div1, t);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[8] || ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 288) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      key_block.d(detaching);
      if (if_block)
        if_block.d();
      ctx[20](null);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let dispatch2 = createEventDispatcher();
  let { options } = $$props;
  let { selected = null } = $$props;
  let { unSelectedplaceholder = "None Selected" } = $$props;
  let { disabled = false } = $$props;
  let { isError = false } = $$props;
  let { forceOpen = false } = $$props;
  let { maxHeight = 500 } = $$props;
  let { context } = $$props;
  let label;
  let isFocussed = false;
  let endTracker;
  let self;
  let popUp;
  function onFocus() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(8, isFocussed = true);
    });
  }
  function blur(e) {
    $$invalidate(8, isFocussed = false);
  }
  function clickOption(opt, ...params) {
    let value2 = opt;
    if (selected != value2) {
      $$invalidate(0, selected = value2);
      dispatch2("onSelect", selected);
    }
    $$invalidate(8, isFocussed = false);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      label = $$value;
      $$invalidate(7, label);
    });
  }
  const focus_handler = (opt, ...params) => clickOption(opt, ...params);
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      endTracker = $$value;
      $$invalidate(9, endTracker);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popUp = $$value;
      $$invalidate(11, popUp);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      self = $$value;
      $$invalidate(10, self);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("unSelectedplaceholder" in $$props2)
      $$invalidate(2, unSelectedplaceholder = $$props2.unSelectedplaceholder);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("isError" in $$props2)
      $$invalidate(4, isError = $$props2.isError);
    if ("forceOpen" in $$props2)
      $$invalidate(5, forceOpen = $$props2.forceOpen);
    if ("maxHeight" in $$props2)
      $$invalidate(15, maxHeight = $$props2.maxHeight);
    if ("context" in $$props2)
      $$invalidate(6, context = $$props2.context);
  };
  return [
    selected,
    options,
    unSelectedplaceholder,
    disabled,
    isError,
    forceOpen,
    context,
    label,
    isFocussed,
    endTracker,
    self,
    popUp,
    onFocus,
    blur,
    clickOption,
    maxHeight,
    div_binding,
    focus_handler,
    div0_binding,
    div2_binding,
    div1_binding
  ];
}
class CustomSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, {
      options: 1,
      selected: 0,
      unSelectedplaceholder: 2,
      disabled: 3,
      isError: 4,
      forceOpen: 5,
      maxHeight: 15,
      context: 6
    });
  }
}
function create_fragment$f(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M3 6h18");
      attr(path1, "d", "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6");
      attr(path2, "d", "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2");
      attr(line0, "x1", "10");
      attr(line0, "y1", "11");
      attr(line0, "x2", "10");
      attr(line0, "y2", "17");
      attr(line1, "x1", "14");
      attr(line1, "y1", "11");
      attr(line1, "x2", "14");
      attr(line1, "y2", "17");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svg-icon lucide-trash-2");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path0);
      append_hydration(svg, path1);
      append_hydration(svg, path2);
      append_hydration(svg, line0);
      append_hydration(svg, line1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { color = "black" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color];
}
class Trash extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, { color: 0 });
  }
}
function create_else_block_1$1(ctx) {
  let div2;
  let div0;
  let t0_value = ctx[0].key + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[0].inCalc && create_if_block_2$6(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text("Click To Add a Origin");
      t3 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        "data-styleactive": true,
        role: true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, t0_value);
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "Click To Add a Origin");
      div1_nodes.forEach(detach);
      t3 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "derivedOriginRow");
      attr(div2, "data-styleactive", "false");
      attr(div2, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
      append_hydration(div2, t3);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[11]),
          listen(div2, "keydown", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].key + ""))
        set_data(t0, t0_value);
      if (!ctx2[0].inCalc) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(div2, slide, {}, true);
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, slide, {}, false);
        div2_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$a(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t0;
  let input;
  let t1;
  let customselect0;
  let updating_selected;
  let t2;
  let customselect1;
  let updating_selected_1;
  let t3;
  let customselect2;
  let updating_selected_2;
  let t4;
  let imagecontainer;
  let trash;
  let imagecontainer_data_color_value;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$7, create_else_block$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1].length == 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function customselect0_selected_binding(value2) {
    ctx[18](value2);
  }
  let customselect0_props = {
    options: ctx[6],
    context: ctx[2]
  };
  if (ctx[0].segments[0] !== void 0) {
    customselect0_props.selected = ctx[0].segments[0];
  }
  customselect0 = new CustomSelect({ props: customselect0_props });
  binding_callbacks.push(() => bind(customselect0, "selected", customselect0_selected_binding));
  customselect0.$on("onSelect", ctx[19]);
  customselect0.$on("onDeselect", ctx[20]);
  function customselect1_selected_binding(value2) {
    ctx[21](value2);
  }
  let customselect1_props = {
    options: ctx[3],
    disabled: !ctx[6],
    context: ctx[2]
  };
  if (ctx[0].segments[1] !== void 0) {
    customselect1_props.selected = ctx[0].segments[1];
  }
  customselect1 = new CustomSelect({ props: customselect1_props });
  binding_callbacks.push(() => bind(customselect1, "selected", customselect1_selected_binding));
  customselect1.$on("onSelect", ctx[22]);
  customselect1.$on("onDeselect", ctx[23]);
  function customselect2_selected_binding(value2) {
    ctx[24](value2);
  }
  let customselect2_props = {
    options: ctx[4],
    disabled: !ctx[3],
    context: ctx[2]
  };
  if (ctx[0].segments[2] !== void 0) {
    customselect2_props.selected = ctx[0].segments[2];
  }
  customselect2 = new CustomSelect({ props: customselect2_props });
  binding_callbacks.push(() => bind(customselect2, "selected", customselect2_selected_binding));
  customselect2.$on("onSelect", ctx[25]);
  customselect2.$on("onDeselect", ctx[26]);
  trash = new Trash({ props: { color: "white" } });
  return {
    c() {
      div = element("div");
      if_block.c();
      t0 = space();
      input = element("input");
      t1 = space();
      create_component(customselect0.$$.fragment);
      t2 = space();
      create_component(customselect1.$$.fragment);
      t3 = space();
      create_component(customselect2.$$.fragment);
      t4 = space();
      imagecontainer = element("imagecontainer");
      create_component(trash.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-styleactive": true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      input = claim_element(div_nodes, "INPUT", { type: true, class: true });
      t1 = claim_space(div_nodes);
      claim_component(customselect0.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(customselect1.$$.fragment, div_nodes);
      t3 = claim_space(div_nodes);
      claim_component(customselect2.$$.fragment, div_nodes);
      t4 = claim_space(div_nodes);
      imagecontainer = claim_element(div_nodes, "IMAGECONTAINER", {
        class: true,
        role: true,
        "data-color": true
      });
      var imagecontainer_nodes = children(imagecontainer);
      claim_component(trash.$$.fragment, imagecontainer_nodes);
      imagecontainer_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "number");
      attr(input, "class", "derivedOriginRowInteractionField");
      attr(imagecontainer, "class", "derivedOriginRowInteractionField");
      attr(imagecontainer, "role", "none");
      attr(imagecontainer, "data-color", imagecontainer_data_color_value = ctx[0].inCalc ? "verbose" : "error");
      attr(div, "class", "derivedOriginRow");
      attr(div, "data-styleactive", "true");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration(div, t0);
      append_hydration(div, input);
      set_input_value(input, ctx[0].testValue);
      append_hydration(div, t1);
      mount_component(customselect0, div, null);
      append_hydration(div, t2);
      mount_component(customselect1, div, null);
      append_hydration(div, t3);
      mount_component(customselect2, div, null);
      append_hydration(div, t4);
      append_hydration(div, imagecontainer);
      mount_component(trash, imagecontainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[16]),
          listen(input, "input", ctx[17]),
          listen(imagecontainer, "click", ctx[9]),
          listen(imagecontainer, "keydown", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t0);
      }
      if (dirty & 1 && to_number(input.value) !== ctx2[0].testValue) {
        set_input_value(input, ctx2[0].testValue);
      }
      const customselect0_changes = {};
      if (dirty & 4)
        customselect0_changes.context = ctx2[2];
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        customselect0_changes.selected = ctx2[0].segments[0];
        add_flush_callback(() => updating_selected = false);
      }
      customselect0.$set(customselect0_changes);
      const customselect1_changes = {};
      if (dirty & 8)
        customselect1_changes.options = ctx2[3];
      if (dirty & 4)
        customselect1_changes.context = ctx2[2];
      if (!updating_selected_1 && dirty & 1) {
        updating_selected_1 = true;
        customselect1_changes.selected = ctx2[0].segments[1];
        add_flush_callback(() => updating_selected_1 = false);
      }
      customselect1.$set(customselect1_changes);
      const customselect2_changes = {};
      if (dirty & 16)
        customselect2_changes.options = ctx2[4];
      if (dirty & 8)
        customselect2_changes.disabled = !ctx2[3];
      if (dirty & 4)
        customselect2_changes.context = ctx2[2];
      if (!updating_selected_2 && dirty & 1) {
        updating_selected_2 = true;
        customselect2_changes.selected = ctx2[0].segments[2];
        add_flush_callback(() => updating_selected_2 = false);
      }
      customselect2.$set(customselect2_changes);
      if (!current || dirty & 1 && imagecontainer_data_color_value !== (imagecontainer_data_color_value = ctx2[0].inCalc ? "verbose" : "error")) {
        attr(imagecontainer, "data-color", imagecontainer_data_color_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(customselect0.$$.fragment, local);
      transition_in(customselect1.$$.fragment, local);
      transition_in(customselect2.$$.fragment, local);
      transition_in(trash.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(customselect0.$$.fragment, local);
      transition_out(customselect1.$$.fragment, local);
      transition_out(customselect2.$$.fragment, local);
      transition_out(trash.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      destroy_component(customselect0);
      destroy_component(customselect1);
      destroy_component(customselect2);
      destroy_component(trash);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$6(ctx) {
  let imagecontainer;
  let trash;
  let imagecontainer_data_color_value;
  let current;
  let mounted;
  let dispose;
  trash = new Trash({ props: { color: "white" } });
  return {
    c() {
      imagecontainer = element("imagecontainer");
      create_component(trash.$$.fragment);
      this.h();
    },
    l(nodes) {
      imagecontainer = claim_element(nodes, "IMAGECONTAINER", {
        class: true,
        role: true,
        "data-color": true
      });
      var imagecontainer_nodes = children(imagecontainer);
      claim_component(trash.$$.fragment, imagecontainer_nodes);
      imagecontainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imagecontainer, "class", "derivedOriginRowInteractionField");
      attr(imagecontainer, "role", "none");
      attr(imagecontainer, "data-color", imagecontainer_data_color_value = ctx[0].inCalc ? "verbose" : "error");
    },
    m(target, anchor) {
      insert_hydration(target, imagecontainer, anchor);
      mount_component(trash, imagecontainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imagecontainer, "click", ctx[9]),
          listen(imagecontainer, "keydown", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1 && imagecontainer_data_color_value !== (imagecontainer_data_color_value = ctx2[0].inCalc ? "verbose" : "error")) {
        attr(imagecontainer, "data-color", imagecontainer_data_color_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trash.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trash.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imagecontainer);
      destroy_component(trash);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$3(ctx) {
  let customselect;
  let current;
  customselect = new CustomSelect({
    props: {
      context: ctx[2],
      selected: ctx[0].key,
      options: [...ctx[1], ctx[0].key]
    }
  });
  customselect.$on("onSelect", ctx[15]);
  return {
    c() {
      create_component(customselect.$$.fragment);
    },
    l(nodes) {
      claim_component(customselect.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(customselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const customselect_changes = {};
      if (dirty & 4)
        customselect_changes.context = ctx2[2];
      if (dirty & 1)
        customselect_changes.selected = ctx2[0].key;
      if (dirty & 3)
        customselect_changes.options = [...ctx2[1], ctx2[0].key];
      customselect.$set(customselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(customselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(customselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(customselect, detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let div;
  let t_value = ctx[0].key + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "derivedOriginRowInteractionField");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].key + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$e(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$a, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].active)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { system } = $$props;
  let { rowData } = $$props;
  let { availableSymbols = [] } = $$props;
  let { allowSelectAll = false } = $$props;
  let { SelectAllText = "--Select All--" } = $$props;
  let { context } = $$props;
  let dispatch2 = createEventDispatcher();
  onMount(() => {
    var _a, _b;
    if (origin && rowData.segments) {
      if (!rowData.segments[0]) {
        return;
      }
      $$invalidate(3, options_level1 = (_a = system.data[rowData.segments[0]].getCollectionsNames()) !== null && _a !== void 0 ? _a : []);
      if (!rowData.segments[1]) {
        return;
      }
      $$invalidate(4, options_level2 = (_b = system.data[rowData.segments[0]].getCollection(rowData.segments[1]).getNodeNames()) !== null && _b !== void 0 ? _b : []);
    }
  });
  let options_level0 = ["fixed", "derived"];
  let options_level1 = [];
  let options_level2 = [];
  function onSelect(level, value2) {
    var _a;
    $$invalidate(0, rowData.isSelectAllTarget = false, rowData);
    switch (level) {
      case 0:
        $$invalidate(3, options_level1 = system.data[value2].getCollectionsNames());
        $$invalidate(0, rowData.segments[1] = null, rowData);
        $$invalidate(0, rowData.segments[2] = null, rowData);
        $$invalidate(4, options_level2 = []);
        if (origin) {
          dispatch2("deselectTargetNode");
        }
        $$invalidate(0, rowData.target = null, rowData);
        break;
      case 1:
        $$invalidate(4, options_level2 = (_a = system.getCollection(rowData.segments[0], value2)) === null || _a === void 0 ? void 0 : _a.getNodeNames());
        if (allowSelectAll && options_level2.length != 0) {
          $$invalidate(4, options_level2 = [SelectAllText, ...options_level2]);
        }
        $$invalidate(0, rowData.segments[2] = null, rowData);
        if (origin) {
          dispatch2("deselectTargetNode");
        }
        $$invalidate(0, rowData.target = null, rowData);
        break;
      case 2:
        if (allowSelectAll && value2 === SelectAllText) {
          $$invalidate(0, rowData.isSelectAllTarget = true, rowData);
          dispatch2("foundSelectAllTargetNode");
          return;
        }
        let targetNode2 = system.getNode(rowData.segments[0], rowData.segments[1], value2);
        $$invalidate(0, rowData.target = targetNode2, rowData);
        dispatch2("foundTargetNode", targetNode2);
        break;
    }
  }
  function onDeselect(level) {
    if (origin) {
      dispatch2("deselectTargetNode");
    }
    switch (level) {
      case 0:
        $$invalidate(3, options_level1 = []);
        $$invalidate(4, options_level2 = []);
        $$invalidate(0, rowData.target = null, rowData);
        $$invalidate(0, rowData.segments[1] = null, rowData);
        $$invalidate(0, rowData.segments[2] = null, rowData);
        break;
      case 1:
        $$invalidate(4, options_level2 = []);
        $$invalidate(0, rowData.segments[2] = null, rowData);
        $$invalidate(0, rowData.target = null, rowData);
        break;
      case 2:
        targetNode = null;
        break;
    }
  }
  function ondelete() {
    dispatch2("onDelete", rowData.key);
  }
  function onChangeSymbol(s) {
    dispatch2("onSymbolSelected", { old: rowData.key, new: s });
  }
  function fromPreOriginToOrigin() {
    console.log("asdasd");
    $$invalidate(0, rowData.active = true, rowData);
    $$invalidate(0, rowData.segments = new Array(3).fill(null), rowData);
  }
  const onSelect_handler = (e) => {
    onChangeSymbol(e.detail);
  };
  const change_handler = () => dispatch2("change");
  function input_input_handler() {
    rowData.testValue = to_number(this.value);
    $$invalidate(0, rowData);
  }
  function customselect0_selected_binding(value2) {
    if ($$self.$$.not_equal(rowData.segments[0], value2)) {
      rowData.segments[0] = value2;
      $$invalidate(0, rowData);
    }
  }
  const onSelect_handler_1 = (e) => onSelect(0, e.detail);
  const onDeselect_handler = () => onDeselect(0);
  function customselect1_selected_binding(value2) {
    if ($$self.$$.not_equal(rowData.segments[1], value2)) {
      rowData.segments[1] = value2;
      $$invalidate(0, rowData);
    }
  }
  const onSelect_handler_2 = (e) => onSelect(1, e.detail);
  const onDeselect_handler_1 = () => onDeselect(0);
  function customselect2_selected_binding(value2) {
    if ($$self.$$.not_equal(rowData.segments[2], value2)) {
      rowData.segments[2] = value2;
      $$invalidate(0, rowData);
    }
  }
  const onSelect_handler_3 = (e) => onSelect(2, e.detail);
  const onDeselect_handler_2 = () => onDeselect(0);
  $$self.$$set = ($$props2) => {
    if ("system" in $$props2)
      $$invalidate(12, system = $$props2.system);
    if ("rowData" in $$props2)
      $$invalidate(0, rowData = $$props2.rowData);
    if ("availableSymbols" in $$props2)
      $$invalidate(1, availableSymbols = $$props2.availableSymbols);
    if ("allowSelectAll" in $$props2)
      $$invalidate(13, allowSelectAll = $$props2.allowSelectAll);
    if ("SelectAllText" in $$props2)
      $$invalidate(14, SelectAllText = $$props2.SelectAllText);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
  };
  return [
    rowData,
    availableSymbols,
    context,
    options_level1,
    options_level2,
    dispatch2,
    options_level0,
    onSelect,
    onDeselect,
    ondelete,
    onChangeSymbol,
    fromPreOriginToOrigin,
    system,
    allowSelectAll,
    SelectAllText,
    onSelect_handler,
    change_handler,
    input_input_handler,
    customselect0_selected_binding,
    onSelect_handler_1,
    onDeselect_handler,
    customselect1_selected_binding,
    onSelect_handler_2,
    onDeselect_handler_1,
    customselect2_selected_binding,
    onSelect_handler_3,
    onDeselect_handler_2
  ];
}
class OriginRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
      system: 12,
      rowData: 0,
      availableSymbols: 1,
      allowSelectAll: 13,
      SelectAllText: 14,
      context: 2
    });
  }
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[34] = list;
  child_ctx[35] = i;
  return child_ctx;
}
function create_if_block$9(ctx) {
  let div1;
  let div0;
  let current;
  let if_block = ctx[15] && create_if_block_1$6(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "derivedOriginRowsContainer");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[15]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 32768) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[15];
  const get_key = (ctx2) => (ctx2[33].key, ctx2[33].segments);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1868822) {
        each_value = ctx2[15];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$2(key_1, ctx) {
  let div;
  let originrow;
  let updating_rowData;
  let t;
  let div_transition;
  let rect;
  let stop_animation = noop;
  let current;
  function originrow_rowData_binding(value2) {
    ctx[28](value2, ctx[33], ctx[34], ctx[35]);
  }
  let originrow_props = {
    availableSymbols: ctx[10],
    system: ctx[1].sys,
    context: ctx[2]
  };
  if (ctx[33] !== void 0) {
    originrow_props.rowData = ctx[33];
  }
  originrow = new OriginRow({ props: originrow_props });
  binding_callbacks.push(() => bind(originrow, "rowData", originrow_rowData_binding));
  originrow.$on("change", ctx[18]);
  originrow.$on("onDelete", ctx[19]);
  originrow.$on("onSymbolSelected", ctx[20]);
  originrow.$on("foundTargetNode", ctx[29]);
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(originrow.$$.fragment);
      t = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(originrow.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "derivedOriginRowContainer");
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(originrow, div, null);
      append_hydration(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const originrow_changes = {};
      if (dirty[0] & 1024)
        originrow_changes.availableSymbols = ctx[10];
      if (dirty[0] & 2)
        originrow_changes.system = ctx[1].sys;
      if (dirty[0] & 4)
        originrow_changes.context = ctx[2];
      if (!updating_rowData && dirty[0] & 32768) {
        updating_rowData = true;
        originrow_changes.rowData = ctx[33];
        add_flush_callback(() => updating_rowData = false);
      }
      originrow.$set(originrow_changes);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
      add_transform(div, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, {});
    },
    i(local) {
      if (current)
        return;
      transition_in(originrow.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(originrow.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(originrow);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$d(ctx) {
  var _a, _b, _c, _d, _e, _f, _g;
  let div10;
  let div0;
  let staticmessagehandler;
  let t0;
  let div1;
  let p;
  let t1;
  let t2;
  let div7;
  let div2;
  let t3;
  let t4;
  let input;
  let t5;
  let div3;
  let t6;
  let t7;
  let div4;
  let t8_value = ((_d = (_c = (_b = (_a = ctx[0]) == null ? void 0 : _a.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.name) != null ? _d : "unknown collection") + "." + ((_g = (_f = (_e = ctx[0]) == null ? void 0 : _e.parent) == null ? void 0 : _f.name) != null ? _g : "unknown collection") + "." + ctx[11];
  let t8;
  let t9;
  let div5;
  let t10;
  let t11;
  let textarea;
  let t12;
  let div6;
  let t13;
  let t14;
  let br0;
  let t15;
  let div8;
  let t16;
  let br1;
  let t17;
  let div9;
  let button;
  let t18;
  let t19;
  let br2;
  let br3;
  let current;
  let mounted;
  let dispose;
  let staticmessagehandler_props = {};
  staticmessagehandler = new StaticMessageHandler({ props: staticmessagehandler_props });
  ctx[25](staticmessagehandler);
  let if_block = ctx[0] && ctx[1] && create_if_block$9(ctx);
  return {
    c() {
      div10 = element("div");
      div0 = element("div");
      create_component(staticmessagehandler.$$.fragment);
      t0 = space();
      div1 = element("div");
      p = element("p");
      t1 = text("Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      t2 = space();
      div7 = element("div");
      div2 = element("div");
      t3 = text("Node Name");
      t4 = space();
      input = element("input");
      t5 = space();
      div3 = element("div");
      t6 = text("Node Location");
      t7 = space();
      div4 = element("div");
      t8 = text(t8_value);
      t9 = space();
      div5 = element("div");
      t10 = text("Calc");
      t11 = space();
      textarea = element("textarea");
      t12 = space();
      div6 = element("div");
      t13 = text(ctx[14]);
      t14 = space();
      br0 = element("br");
      t15 = space();
      div8 = element("div");
      if (if_block)
        if_block.c();
      t16 = space();
      br1 = element("br");
      t17 = space();
      div9 = element("div");
      button = element("button");
      t18 = text("save changes");
      t19 = space();
      br2 = element("br");
      br3 = element("br");
      this.h();
    },
    l(nodes) {
      div10 = claim_element(nodes, "DIV", {});
      var div10_nodes = children(div10);
      div0 = claim_element(div10_nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(staticmessagehandler.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(div10_nodes);
      div1 = claim_element(div10_nodes, "DIV", {});
      var div1_nodes = children(div1);
      p = claim_element(div1_nodes, "P", {});
      var p_nodes = children(p);
      t1 = claim_text(p_nodes, "Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      p_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t2 = claim_space(div10_nodes);
      div7 = claim_element(div10_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div2 = claim_element(div7_nodes, "DIV", {});
      var div2_nodes = children(div2);
      t3 = claim_text(div2_nodes, "Node Name");
      div2_nodes.forEach(detach);
      t4 = claim_space(div7_nodes);
      input = claim_element(div7_nodes, "INPUT", {
        type: true,
        class: true,
        contenteditable: true
      });
      t5 = claim_space(div7_nodes);
      div3 = claim_element(div7_nodes, "DIV", {});
      var div3_nodes = children(div3);
      t6 = claim_text(div3_nodes, "Node Location");
      div3_nodes.forEach(detach);
      t7 = claim_space(div7_nodes);
      div4 = claim_element(div7_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      t8 = claim_text(div4_nodes, t8_value);
      div4_nodes.forEach(detach);
      t9 = claim_space(div7_nodes);
      div5 = claim_element(div7_nodes, "DIV", {});
      var div5_nodes = children(div5);
      t10 = claim_text(div5_nodes, "Calc");
      div5_nodes.forEach(detach);
      t11 = claim_space(div7_nodes);
      textarea = claim_element(div7_nodes, "TEXTAREA", { class: true, placeholder: true });
      children(textarea).forEach(detach);
      t12 = claim_space(div7_nodes);
      div6 = claim_element(div7_nodes, "DIV", { class: true, "data-succes": true });
      var div6_nodes = children(div6);
      t13 = claim_text(div6_nodes, ctx[14]);
      div6_nodes.forEach(detach);
      div7_nodes.forEach(detach);
      t14 = claim_space(div10_nodes);
      br0 = claim_element(div10_nodes, "BR", {});
      t15 = claim_space(div10_nodes);
      div8 = claim_element(div10_nodes, "DIV", {});
      var div8_nodes = children(div8);
      if (if_block)
        if_block.l(div8_nodes);
      div8_nodes.forEach(detach);
      t16 = claim_space(div10_nodes);
      br1 = claim_element(div10_nodes, "BR", {});
      t17 = claim_space(div10_nodes);
      div9 = claim_element(div10_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      button = claim_element(div9_nodes, "BUTTON", {});
      var button_nodes = children(button);
      t18 = claim_text(button_nodes, "save changes");
      button_nodes.forEach(detach);
      div9_nodes.forEach(detach);
      t19 = claim_space(div10_nodes);
      br2 = claim_element(div10_nodes, "BR", {});
      br3 = claim_element(div10_nodes, "BR", {});
      div10_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "text");
      attr(input, "class", "ItemDesignerInput");
      attr(input, "contenteditable", "");
      attr(div4, "class", "ItemDesignerInput");
      attr(textarea, "class", "calcInput");
      textarea.value = ctx[12];
      attr(textarea, "placeholder", "insert calcStatement here");
      attr(div6, "class", "derivedCalcStatementResult");
      attr(div6, "data-succes", ctx[13]);
      attr(div7, "class", "ItemDesignerDataColumns3");
      attr(div9, "class", "ItemDesignerButtonRow");
    },
    m(target, anchor) {
      insert_hydration(target, div10, anchor);
      append_hydration(div10, div0);
      mount_component(staticmessagehandler, div0, null);
      append_hydration(div10, t0);
      append_hydration(div10, div1);
      append_hydration(div1, p);
      append_hydration(p, t1);
      append_hydration(div10, t2);
      append_hydration(div10, div7);
      append_hydration(div7, div2);
      append_hydration(div2, t3);
      append_hydration(div7, t4);
      append_hydration(div7, input);
      set_input_value(input, ctx[11]);
      append_hydration(div7, t5);
      append_hydration(div7, div3);
      append_hydration(div3, t6);
      append_hydration(div7, t7);
      append_hydration(div7, div4);
      append_hydration(div4, t8);
      append_hydration(div7, t9);
      append_hydration(div7, div5);
      append_hydration(div5, t10);
      append_hydration(div7, t11);
      append_hydration(div7, textarea);
      append_hydration(div7, t12);
      append_hydration(div7, div6);
      append_hydration(div6, t13);
      append_hydration(div10, t14);
      append_hydration(div10, br0);
      append_hydration(div10, t15);
      append_hydration(div10, div8);
      if (if_block)
        if_block.m(div8, null);
      append_hydration(div10, t16);
      append_hydration(div10, br1);
      append_hydration(div10, t17);
      append_hydration(div10, div9);
      append_hydration(div9, button);
      append_hydration(button, t18);
      append_hydration(div10, t19);
      append_hydration(div10, br2);
      append_hydration(div10, br3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[26]),
          listen(input, "input", ctx[27]),
          listen(textarea, "input", ctx[17]),
          listen(button, "click", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      const staticmessagehandler_changes = {};
      staticmessagehandler.$set(staticmessagehandler_changes);
      if (dirty[0] & 2048 && input.value !== ctx2[11]) {
        set_input_value(input, ctx2[11]);
      }
      if ((!current || dirty[0] & 2049) && t8_value !== (t8_value = ((_d2 = (_c2 = (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.parent) == null ? void 0 : _b2.parent) == null ? void 0 : _c2.name) != null ? _d2 : "unknown collection") + "." + ((_g2 = (_f2 = (_e2 = ctx2[0]) == null ? void 0 : _e2.parent) == null ? void 0 : _f2.name) != null ? _g2 : "unknown collection") + "." + ctx2[11]))
        set_data(t8, t8_value);
      if (!current || dirty[0] & 4096) {
        textarea.value = ctx2[12];
      }
      if (!current || dirty[0] & 16384)
        set_data(t13, ctx2[14]);
      if (!current || dirty[0] & 8192) {
        attr(div6, "data-succes", ctx2[13]);
      }
      if (ctx2[0] && ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div8, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(staticmessagehandler.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(staticmessagehandler.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div10);
      ctx[25](null);
      destroy_component(staticmessagehandler);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let availableSymbols;
  let $controllerName, $$unsubscribe_controllerName = noop, $$subscribe_controllerName = () => ($$unsubscribe_controllerName(), $$unsubscribe_controllerName = subscribe(controllerName, ($$value) => $$invalidate(11, $controllerName = $$value)), controllerName);
  let $controllerCalc, $$unsubscribe_controllerCalc = noop, $$subscribe_controllerCalc = () => ($$unsubscribe_controllerCalc(), $$unsubscribe_controllerCalc = subscribe(controllerCalc, ($$value) => $$invalidate(12, $controllerCalc = $$value)), controllerCalc);
  let $controllerResultSucces, $$unsubscribe_controllerResultSucces = noop, $$subscribe_controllerResultSucces = () => ($$unsubscribe_controllerResultSucces(), $$unsubscribe_controllerResultSucces = subscribe(controllerResultSucces, ($$value) => $$invalidate(13, $controllerResultSucces = $$value)), controllerResultSucces);
  let $controllerResultValue, $$unsubscribe_controllerResultValue = noop, $$subscribe_controllerResultValue = () => ($$unsubscribe_controllerResultValue(), $$unsubscribe_controllerResultValue = subscribe(controllerResultValue, ($$value) => $$invalidate(14, $controllerResultValue = $$value)), controllerResultValue);
  let $controllerMappedOrigin, $$unsubscribe_controllerMappedOrigin = noop, $$subscribe_controllerMappedOrigin = () => ($$unsubscribe_controllerMappedOrigin(), $$unsubscribe_controllerMappedOrigin = subscribe(controllerMappedOrigin, ($$value) => $$invalidate(15, $controllerMappedOrigin = $$value)), controllerMappedOrigin);
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerName());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerCalc());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerResultSucces());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerResultValue());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerMappedOrigin());
  let { node } = $$props;
  let { system } = $$props;
  let { goodTitle = "No Error" } = $$props;
  let { badTitle = "Error" } = $$props;
  let { context } = $$props;
  let messageHandler;
  const dispatch2 = createEventDispatcher();
  let controller = new DerivedItemController();
  function forceUpdate() {
    controller.updateMappedOrigins();
  }
  let controllerMappedOrigin;
  let controllerResultValue;
  let controllerResultSucces;
  let controllerName;
  let controllerCalc;
  let origName;
  function onNameInput(event) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    let name = event.target.value;
    controller.name.set(name);
    controller.checkIsValid(false);
  }
  function onCalcInput(event) {
    let calc = event.target.value;
    controller.calc.set(calc);
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.recalculateCalcAndOrigins();
    controller.checkIsValid(false);
  }
  function recalc() {
    controller.recalculateCalcAndOrigins();
    controller.checkIsValid(false);
  }
  function onDeleteClicked(e) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.onKeyDelete(e);
    controller.checkIsValid(false);
  }
  function onKeyExchange(e) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.onKeyExchange(e);
    controller.checkIsValid(false);
  }
  function onSave() {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    if (controller.saveNodeChanges()) {
      const oldName = origName;
      const newName = get_store_value(controller.name);
      dispatch2("save", { oldName, newName });
      origName = newName;
    }
  }
  onMount(() => {
    controller.setControllerDeps(node, system, (msg) => {
    });
    controller.recalculateCalcAndOrigins();
    controller.checkIsValid();
    $$subscribe_controllerMappedOrigin($$invalidate(5, controllerMappedOrigin = controller.mappedOrigins));
    $$subscribe_controllerResultValue($$invalidate(6, controllerResultValue = controller.resultValue));
    $$subscribe_controllerResultSucces($$invalidate(7, controllerResultSucces = controller.resultSuccess));
    $$subscribe_controllerName($$invalidate(8, controllerName = controller.name));
    $$subscribe_controllerCalc($$invalidate(9, controllerCalc = controller.calc));
    controller.isValid;
    origName = get_store_value(controller.name);
  });
  function staticmessagehandler_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      messageHandler = $$value;
      $$invalidate(3, messageHandler);
    });
  }
  const input_handler = (e) => {
    onNameInput(e);
  };
  function input_input_handler() {
    $controllerName = this.value;
    controllerName.set($controllerName);
  }
  function originrow_rowData_binding(value2, origin2, each_value, origin_index) {
    each_value[origin_index] = value2;
    controllerMappedOrigin.set($controllerMappedOrigin);
  }
  const foundTargetNode_handler = (e) => {
    controller.checkIsValid(false);
  };
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("system" in $$props2)
      $$invalidate(1, system = $$props2.system);
    if ("goodTitle" in $$props2)
      $$invalidate(22, goodTitle = $$props2.goodTitle);
    if ("badTitle" in $$props2)
      $$invalidate(23, badTitle = $$props2.badTitle);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8) {
      $$invalidate(4, controller.messageHandler = messageHandler, controller);
    }
    if ($$self.$$.dirty[0] & 19) {
      controller.setControllerDeps(node, system, (msg) => {
      });
    }
    if ($$self.$$.dirty[0] & 16) {
      $$invalidate(10, availableSymbols = get_store_value(controller.mappedOrigins).filter((p) => !p.active).map((p) => p.key));
    }
  };
  return [
    node,
    system,
    context,
    messageHandler,
    controller,
    controllerMappedOrigin,
    controllerResultValue,
    controllerResultSucces,
    controllerName,
    controllerCalc,
    availableSymbols,
    $controllerName,
    $controllerCalc,
    $controllerResultSucces,
    $controllerResultValue,
    $controllerMappedOrigin,
    onNameInput,
    onCalcInput,
    recalc,
    onDeleteClicked,
    onKeyExchange,
    onSave,
    goodTitle,
    badTitle,
    forceUpdate,
    staticmessagehandler_binding,
    input_handler,
    input_input_handler,
    originrow_rowData_binding,
    foundTargetNode_handler
  ];
}
class DerivedItemDesigner extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$d,
      create_fragment$d,
      safe_not_equal,
      {
        node: 0,
        system: 1,
        goodTitle: 22,
        badTitle: 23,
        context: 2,
        forceUpdate: 24
      },
      null,
      [-1, -1]
    );
  }
  get forceUpdate() {
    return this.$$.ctx[24];
  }
}
const selAllInCollectionString = "- - Select all - -";
class DerivedCollectionController {
  constructor() {
    __publicField(this, "system", null);
    __publicField(this, "messageHandler");
    __publicField(this, "name", writable(""));
    __publicField(this, "nameCalc", writable(""));
    __publicField(this, "tempValue", writable(1));
    __publicField(this, "calc", writable(""));
    __publicField(this, "resultValue", writable(0));
    __publicField(this, "resultSuccess", writable(true));
    __publicField(this, "resultNameValue", writable(""));
    __publicField(this, "resultNameSuccess", writable(true));
    __publicField(this, "isValid", writable(true));
    __publicField(this, "mappedOrigins", writable([]));
    __publicField(this, "generativeNameListData", writable([]));
  }
  setControllerDeps(system) {
    this.system = system;
    this.name.set("");
    this.nameCalc.set("");
    this.calc.set("");
    this.tempValue.set(0);
    this.resultSuccess.set(true);
    this.resultValue.set(0);
    this.resultNameSuccess.set(true);
    this.resultNameValue.set("");
    this.isValid.set(true);
    this.mappedOrigins.set([]);
  }
  validateName(name, messageHandler = null, output) {
    var _a, _b;
    let out = (key, msg, error) => {
      if (output) {
        messageHandler == null ? void 0 : messageHandler.addMessageManual(key, msg, error);
      }
    };
    let isValid = true;
    console.log(name);
    if (name == "") {
      isValid = false;
      out("name", "The name cannot be empty", "error");
    } else if (name.includes(".")) {
      isValid = false;
      out("name", 'The name cannot contain "."', "error");
    } else if (((_a = this.system) == null ? void 0 : _a.hasCollection("derived", name)) || ((_b = this.system) == null ? void 0 : _b.hasCollection("fixed", name))) {
      isValid = false;
      out("name", "The Collection name is already in use ", "error");
    } else {
      messageHandler == null ? void 0 : messageHandler.removeError("name");
    }
    return isValid;
  }
  validateItemName(nameCalc, calc, originData, messageHandler = null, output) {
    let out = (key, msg, error) => {
      if (output) {
        messageHandler == null ? void 0 : messageHandler.addMessageManual(key, msg, error);
      }
    };
    let symbolsCalc = GrobJDerivedNode.staticParseCalculationToOrigins(calc);
    let symbolsName = GrobJDerivedNode.staticParseCalculationToOrigins(nameCalc);
    symbolsName = symbolsName.filter((p) => symbolsCalc.includes(p));
    let symbolsMissing = symbolsCalc.filter((p) => !nameCalc.includes(p));
    let isValid = true;
    if (symbolsMissing.length != 0) {
      symbolsMissing.forEach((s) => {
        let isAllSetting = originData.findIndex((p) => p.isSelectAllTarget && p.key == s) != -1;
        if (isAllSetting) {
          out("NoSymbolName" + s, s + " was missing from name calculation \nAll Select All Settings must be in the name ", "error");
          isValid = false;
        }
      });
    }
    let nameRES = nameCalc;
    symbolsName.forEach((s) => {
      nameRES = nameRES.replace(s, "[" + s + "]");
    });
    this.resultNameSuccess.set(isValid);
    this.resultNameValue.set(nameRES);
    return isValid;
  }
  validateOrigins(mappedOrigins, calc, system, messageHandler = null, output) {
    let out = (key, msg, error) => {
      if (output) {
        messageHandler == null ? void 0 : messageHandler.addMessageManual(key, msg, error);
      }
    };
    let isValid = true;
    mappedOrigins.forEach((obj) => {
      if (obj.inCalc && !obj.target && !obj.isSelectAllTarget) {
        out(obj.key + "1", `Cannot save until all dependencies used in the calc is defined 
 ${obj.key} Had no target`, "error");
        isValid = false;
      } else {
        messageHandler == null ? void 0 : messageHandler.removeError(obj.key + "1");
      }
    });
    if (!isValid) {
      return false;
    }
    let NMap = mappedOrigins.filter((p) => calc.includes(p.key));
    NMap.forEach((o) => {
      if (!o.segments) {
        out(o.key, `Contents of ${o.key}'s segments was Null!'`, "error");
        isValid = false;
        return;
      }
      if (!o.isSelectAllTarget) {
        let dep = system.getNode(o.segments[0], o.segments[1], o.segments[2]);
        if (!dep) {
          out(o.key, `Target of ${o.key} location ${o.segments[0] + "." + o.segments[1] + "." + o.segments[2]} was invalid!'`, "error");
          isValid = false;
          return;
        }
      }
      messageHandler == null ? void 0 : messageHandler.removeError(o.key);
    });
    return isValid;
  }
  validateCalculation(calc, mappedOrigins, messageHandler = null, output) {
    let out = (key, msg, error) => {
      if (output) {
        messageHandler == null ? void 0 : messageHandler.addMessageManual(key, msg, error);
      }
    };
    if (calc.trim() == "") {
      out("calc", `Calculation cannot be empty`, "error");
      return false;
    }
    if (calc.trim() == "") {
      out("calc", `Calculation cannot be empty`, "error");
      return false;
    }
    let o = {};
    let mappedKeys = [];
    mappedOrigins.forEach((p) => {
      o[p.key] = p.testValue;
      mappedKeys.push(p.key);
    });
    let calcres = GrobJDerivedNode.testCalculate(calc, o);
    let succes = calcres.success;
    let value2 = calcres.value;
    if (!succes) {
      out("calc", `Calculation is invalid, meaning it could not parse`, "error");
    } else {
      messageHandler == null ? void 0 : messageHandler.removeError("calc");
    }
    this.resultValue.set(value2);
    this.resultSuccess.set(succes);
    return succes;
  }
  validateCalculationOrigins(calc, mappedOrigins, messageHandler = null, output) {
    let out = (key, msg, error) => {
      if (output) {
        messageHandler == null ? void 0 : messageHandler.addMessageManual(key, msg, error);
      }
    };
    let symbols2 = GrobJDerivedNode.staticParseCalculationToOrigins(calc);
    mappedOrigins.forEach((o) => {
      const index = symbols2.indexOf(o.key);
      if (index !== -1) {
        symbols2.splice(index, 1);
      }
      messageHandler == null ? void 0 : messageHandler.removeError(o.key + "missing");
    });
    let isValid = true;
    symbols2.forEach((s) => {
      isValid = false;
      out(s + "missing", `symbol ${s} was missing from origins `, "error");
    });
    return isValid;
  }
  _checkIsValid(output = true) {
    var _a;
    if (!this.system) {
      return false;
    }
    let isValid = true;
    isValid = isValid && this.validateName((_a = get_store_value(this.name)) != null ? _a : "", this.messageHandler, output);
    isValid = isValid && this.validateOrigins(get_store_value(this.mappedOrigins), get_store_value(this.calc), this.system.sys, this.messageHandler, output);
    isValid = isValid && this.validateCalculationOrigins(get_store_value(this.calc), get_store_value(this.mappedOrigins), this.messageHandler, output);
    let d = this.validateItemName(get_store_value(this.nameCalc), get_store_value(this.calc), get_store_value(this.mappedOrigins), this.messageHandler, output);
    isValid = isValid && d;
    isValid = isValid && this.validateCalculation(get_store_value(this.calc), get_store_value(this.mappedOrigins), this.messageHandler, output);
    return isValid;
  }
  checkIsValid(output = true) {
    var _a;
    (_a = this.messageHandler) == null ? void 0 : _a.removeAllMessages();
    let valid = this._checkIsValid(output);
    this.isValid.set(valid);
    return valid;
  }
  saveCollection() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    let success = this.checkIsValid(true);
    if (!success) {
      (_a = this.messageHandler) == null ? void 0 : _a.addMessageManual("save", "Was Not valid, so could not save", "error");
      return false;
    } else {
      try {
        debugger;
        let colName = get_store_value(this.name);
        (_b = this.system) == null ? void 0 : _b.addCollection("derived", colName);
        let nodesToCreate = (_c = this.generateNamePreview()) != null ? _c : [];
        nodesToCreate.forEach((node) => {
          var _a2, _b2, _c2;
          (_a2 = this.system) == null ? void 0 : _a2.addNode("derived", colName, node.name);
          let createdNode = (_c2 = (_b2 = this.system) == null ? void 0 : _b2.sys) == null ? void 0 : _c2.getNode("derived", colName, node.name);
          let calc = get_store_value(this.calc);
          createdNode == null ? void 0 : createdNode.setCalc(calc);
          if (createdNode) {
            Object.keys(node.deps).forEach((key) => {
              let dep = node.deps[key];
              createdNode.setOrigin(key, dep, 0);
            });
          }
        });
        (_e = (_d = this.system) == null ? void 0 : _d.getGroup("derived")) == null ? void 0 : _e.update();
        (_g = (_f = this.system) == null ? void 0 : _f.getCollection("derived", colName)) == null ? void 0 : _g.update();
      } catch (e) {
        success = false;
      }
    }
    if (success) {
      (_h = this.messageHandler) == null ? void 0 : _h.addMessageManual("save", "Saved Node", "good");
      return true;
    } else {
      (_i = this.messageHandler) == null ? void 0 : _i.addMessageManual("save", "Exception while trying to save Node in UI", "error");
      return false;
    }
  }
  onKeyExchange(e) {
    this.mappedOrigins.update((mappedOrigins) => {
      const s0 = e.detail.old;
      const s1 = e.detail.new;
      let t0 = mappedOrigins.find((p) => p.key == s0);
      if (!t0)
        return mappedOrigins;
      let t1 = mappedOrigins.find((p) => p.key == s1);
      if (!t1)
        return mappedOrigins;
      t0.key = s1;
      t0.inCalc = get_store_value(this.calc).includes(s1);
      t1.key = s0;
      t1.inCalc = get_store_value(this.calc).includes(s0);
      return mappedOrigins;
    });
    return;
  }
  onKeyDelete(e) {
    this.mappedOrigins.update((mappedOrigins) => {
      const key = e.detail;
      let old = mappedOrigins.find((p) => p.key == key);
      if (!old)
        return mappedOrigins;
      if (!old.active || !old.inCalc) {
        mappedOrigins.filter((p) => p.key != old.key);
      } else {
        old.active = false;
        old.segments = new Array(3).fill(null);
      }
      return mappedOrigins;
    });
  }
  recalculateCalcAndOrigins() {
    let o = {};
    get_store_value(this.mappedOrigins).forEach((p) => {
      o[p.key] = p.testValue;
    });
    let calc = get_store_value(this.calc);
    let res2 = GrobJDerivedNode.testCalculate(calc, o);
    this.resultValue.set(res2.value);
    this.resultSuccess.set(res2.success);
    let symbols2 = GrobJDerivedNode.staticParseCalculationToOrigins(calc);
    this.mappedOrigins.update((mappedOrigins) => {
      mappedOrigins.forEach((d) => {
        let inCalc = symbols2.includes(d.key);
        if (inCalc) {
          symbols2 = symbols2.filter((p) => p != d.key);
          d.inCalc = true;
        } else {
          d.inCalc = false;
        }
      });
      symbols2.forEach((s) => {
        mappedOrigins.push({ key: s, segments: new Array(3).fill(null), active: false, testValue: 1, inCalc: true, target: null, isSelectAllTarget: false });
      });
      return mappedOrigins;
    });
  }
  generateNamePreview() {
    if (!this.system) {
      this.generativeNameListData.set([]);
      return;
    }
    try {
      let recursiveNameFinder = function(self, nameCalc2, index = 0, arr, res22, deps) {
        var _a;
        let currentName = nameCalc2;
        let nodes;
        let curr = arr[index];
        if (!curr) {
          if (res22.data.findIndex((p) => p.name == currentName) != -1) {
            throw new Error("Double Name, in names generated Detected");
          }
          res22.data.push({ name: currentName, deps });
          return;
        }
        if (curr.segments[2] == selAllInCollectionString) {
          const sys = self.system.sys;
          let collection = sys.getCollection(curr.segments[0], curr.segments[1]);
          let n = (_a = collection == null ? void 0 : collection.getNodes()) != null ? _a : [];
          nodes = n;
        } else {
          const sys = self.system.sys;
          let collection = sys.getCollection(curr.segments[0], curr.segments[1]);
          let n = collection == null ? void 0 : collection.getNode(curr.segments[2]);
          nodes = n ? [n] : [];
        }
        nodes.forEach((node) => {
          let currNameCalc = currentName.replace(curr.key, node.getName());
          let _deps = Object.assign({}, deps);
          _deps[curr.key] = node;
          recursiveNameFinder(self, currNameCalc, index + 1, arr, res22, _deps);
        });
      };
      let origins = get_store_value(this.mappedOrigins);
      let nameCalc = get_store_value(this.nameCalc);
      let res2 = { data: [] };
      recursiveNameFinder(this, nameCalc, 0, origins, res2, {});
      this.generativeNameListData.set(res2.data.map((p) => p.name));
      return res2.data;
    } catch (e) {
      return null;
    }
  }
}
function create_if_block$8(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$c(ctx) {
  let div3;
  let div1;
  let p;
  let t0;
  let t1;
  let section;
  let t2;
  let t3;
  let div0;
  let t4;
  let div2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block$8(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      p = element("p");
      t0 = text(ctx[0]);
      t1 = space();
      section = element("section");
      t2 = text("\xA0");
      t3 = space();
      div0 = element("div");
      t4 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", {});
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true, "data-toogled": true });
      var div1_nodes = children(div1);
      p = claim_element(div1_nodes, "P", { style: true });
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, ctx[0]);
      p_nodes.forEach(detach);
      t1 = claim_space(div1_nodes);
      section = claim_element(div1_nodes, "SECTION", { style: true, class: true });
      var section_nodes = children(section);
      t2 = claim_text(section_nodes, "\xA0");
      section_nodes.forEach(detach);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { style: true, class: true });
      children(div0).forEach(detach);
      div1_nodes.forEach(detach);
      t4 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_style(p, "grid-area", "name");
      set_style(section, "grid-area", "icon");
      attr(section, "class", "toogleSectionIcon");
      set_style(div0, "grid-area", "line");
      attr(div0, "class", "toogleSectinLine");
      attr(div1, "class", "toogleSectionHeader");
      attr(div1, "data-toogled", ctx[2]);
      attr(div2, "class", "toogleSectionBody");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, div1);
      append_hydration(div1, p);
      append_hydration(p, t0);
      append_hydration(div1, t1);
      append_hydration(div1, section);
      append_hydration(section, t2);
      append_hydration(div1, t3);
      append_hydration(div1, div0);
      append_hydration(div3, t4);
      append_hydration(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (!current || dirty & 4) {
        attr(div1, "data-toogled", ctx2[2]);
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let dispatch2 = createEventDispatcher();
  let toogled = false;
  function toogle(forceState = null) {
    let origState = toogled;
    if (forceState == null) {
      $$invalidate(2, toogled = !toogled);
    } else {
      $$invalidate(2, toogled = forceState);
    }
    if (toogled == origState)
      return;
    if (toogled) {
      dispatch2("close");
    } else {
      dispatch2("open");
    }
  }
  const click_handler = () => toogle();
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [title, toogle, toogled, $$scope, slots, click_handler];
}
class ToogleSection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, { title: 0, toogle: 1 });
  }
  get toogle() {
    return this.$$.ctx[1];
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  child_ctx[44] = list;
  child_ctx[45] = i;
  return child_ctx;
}
function create_if_block$7(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[23];
  const get_key = (ctx2) => ctx2[43].key;
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1619034161) {
        each_value_1 = ctx2[23];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let div;
  let originrow;
  let updating_rowData;
  let t;
  let div_transition;
  let current;
  function originrow_rowData_binding(value2) {
    ctx[38](value2, ctx[43], ctx[44], ctx[45]);
  }
  let originrow_props = {
    availableSymbols: ctx[15],
    system: ctx[0].sys,
    context: ctx[4],
    allowSelectAll: true,
    SelectAllText: selAllInCollectionString
  };
  if (ctx[43] !== void 0) {
    originrow_props.rowData = ctx[43];
  }
  originrow = new OriginRow({ props: originrow_props });
  binding_callbacks.push(() => bind(originrow, "rowData", originrow_rowData_binding));
  originrow.$on("onDelete", ctx[29]);
  originrow.$on("onSymbolSelected", ctx[30]);
  originrow.$on("foundTargetNode", ctx[39]);
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(originrow.$$.fragment);
      t = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(originrow.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "derivedOriginRowContainer");
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(originrow, div, null);
      append_hydration(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const originrow_changes = {};
      if (dirty[0] & 32768)
        originrow_changes.availableSymbols = ctx[15];
      if (dirty[0] & 1)
        originrow_changes.system = ctx[0].sys;
      if (dirty[0] & 16)
        originrow_changes.context = ctx[4];
      if (!updating_rowData && dirty[0] & 8388608) {
        updating_rowData = true;
        originrow_changes.rowData = ctx[43];
        add_flush_callback(() => updating_rowData = false);
      }
      originrow.$set(originrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(originrow.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(originrow.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(originrow);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let div;
  let t0_value = ctx[40] + "";
  let t0;
  let t1;
  let div_transition;
  let rect;
  let stop_animation = noop;
  let current;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "derivedOriginRowContainer");
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, t0);
      append_hydration(div, t1);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & 16777216) && t0_value !== (t0_value = ctx[40] + ""))
        set_data(t0, t0_value);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
      add_transform(div, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, {});
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot$1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[24];
  const get_key = (ctx2) => ctx2[40];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16777216) {
        each_value = ctx2[24];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$b(ctx) {
  let div14;
  let div0;
  let t0;
  let t1;
  let div1;
  let p;
  let t2;
  let t3;
  let div2;
  let t4;
  let div11;
  let div10;
  let div8;
  let div3;
  let t5;
  let t6;
  let textarea0;
  let t7;
  let div4;
  let t8;
  let t9;
  let textarea1;
  let t10;
  let div5;
  let t11;
  let t12;
  let div6;
  let t13;
  let t14;
  let textarea2;
  let t15;
  let div7;
  let t16;
  let t17;
  let div9;
  let t18;
  let br;
  let t19;
  let div12;
  let button0;
  let t20;
  let t21;
  let button1;
  let t22;
  let t23;
  let div13;
  let tooglesection;
  let div14_data_state_value;
  let div14_data_state_text_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[23] && ctx[1] && create_if_block$7(ctx);
  tooglesection = new ToogleSection({
    props: {
      title: "preview Names",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div14 = element("div");
      div0 = element("div");
      t0 = text("X");
      t1 = space();
      div1 = element("div");
      p = element("p");
      t2 = text("Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      t3 = space();
      div2 = element("div");
      t4 = space();
      div11 = element("div");
      div10 = element("div");
      div8 = element("div");
      div3 = element("div");
      t5 = text("new Collection Name");
      t6 = space();
      textarea0 = element("textarea");
      t7 = space();
      div4 = element("div");
      t8 = text("Name");
      t9 = space();
      textarea1 = element("textarea");
      t10 = space();
      div5 = element("div");
      t11 = text(ctx[19]);
      t12 = space();
      div6 = element("div");
      t13 = text("Calc");
      t14 = space();
      textarea2 = element("textarea");
      t15 = space();
      div7 = element("div");
      t16 = text(ctx[22]);
      t17 = space();
      div9 = element("div");
      if (if_block)
        if_block.c();
      t18 = space();
      br = element("br");
      t19 = space();
      div12 = element("div");
      button0 = element("button");
      t20 = text("save changes");
      t21 = space();
      button1 = element("button");
      t22 = text("Generate Name Preview");
      t23 = space();
      div13 = element("div");
      create_component(tooglesection.$$.fragment);
      this.h();
    },
    l(nodes) {
      div14 = claim_element(nodes, "DIV", {
        class: true,
        "data-state": true,
        "data-state-text": true
      });
      var div14_nodes = children(div14);
      div0 = claim_element(div14_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "X");
      div0_nodes.forEach(detach);
      t1 = claim_space(div14_nodes);
      div1 = claim_element(div14_nodes, "DIV", {});
      var div1_nodes = children(div1);
      p = claim_element(div1_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, "Editing node.\n			Here you can edit settings for this specific node. this edit is unique to this specific item.");
      p_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t3 = claim_space(div14_nodes);
      div2 = claim_element(div14_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div2_nodes.forEach(detach);
      t4 = claim_space(div14_nodes);
      div11 = claim_element(div14_nodes, "DIV", {});
      var div11_nodes = children(div11);
      div10 = claim_element(div11_nodes, "DIV", { class: true });
      var div10_nodes = children(div10);
      div8 = claim_element(div10_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      div3 = claim_element(div8_nodes, "DIV", {});
      var div3_nodes = children(div3);
      t5 = claim_text(div3_nodes, "new Collection Name");
      div3_nodes.forEach(detach);
      t6 = claim_space(div8_nodes);
      textarea0 = claim_element(div8_nodes, "TEXTAREA", { class: true, contenteditable: true });
      children(textarea0).forEach(detach);
      t7 = claim_space(div8_nodes);
      div4 = claim_element(div8_nodes, "DIV", { "data-succes": true });
      var div4_nodes = children(div4);
      t8 = claim_text(div4_nodes, "Name");
      div4_nodes.forEach(detach);
      t9 = claim_space(div8_nodes);
      textarea1 = claim_element(div8_nodes, "TEXTAREA", { class: true, placeholder: true });
      children(textarea1).forEach(detach);
      t10 = claim_space(div8_nodes);
      div5 = claim_element(div8_nodes, "DIV", { class: true, "data-succes": true });
      var div5_nodes = children(div5);
      t11 = claim_text(div5_nodes, ctx[19]);
      div5_nodes.forEach(detach);
      t12 = claim_space(div8_nodes);
      div6 = claim_element(div8_nodes, "DIV", { "data-succes": true });
      var div6_nodes = children(div6);
      t13 = claim_text(div6_nodes, "Calc");
      div6_nodes.forEach(detach);
      t14 = claim_space(div8_nodes);
      textarea2 = claim_element(div8_nodes, "TEXTAREA", { class: true, placeholder: true });
      children(textarea2).forEach(detach);
      t15 = claim_space(div8_nodes);
      div7 = claim_element(div8_nodes, "DIV", { class: true, "data-succes": true });
      var div7_nodes = children(div7);
      t16 = claim_text(div7_nodes, ctx[22]);
      div7_nodes.forEach(detach);
      div8_nodes.forEach(detach);
      t17 = claim_space(div10_nodes);
      div9 = claim_element(div10_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      if (if_block)
        if_block.l(div9_nodes);
      div9_nodes.forEach(detach);
      div10_nodes.forEach(detach);
      div11_nodes.forEach(detach);
      t18 = claim_space(div14_nodes);
      br = claim_element(div14_nodes, "BR", {});
      t19 = claim_space(div14_nodes);
      div12 = claim_element(div14_nodes, "DIV", { class: true });
      var div12_nodes = children(div12);
      button0 = claim_element(div12_nodes, "BUTTON", {});
      var button0_nodes = children(button0);
      t20 = claim_text(button0_nodes, "save changes");
      button0_nodes.forEach(detach);
      t21 = claim_space(div12_nodes);
      button1 = claim_element(div12_nodes, "BUTTON", {});
      var button1_nodes = children(button1);
      t22 = claim_text(button1_nodes, "Generate Name Preview");
      button1_nodes.forEach(detach);
      div12_nodes.forEach(detach);
      t23 = claim_space(div14_nodes);
      div13 = claim_element(div14_nodes, "DIV", {});
      var div13_nodes = children(div13);
      claim_component(tooglesection.$$.fragment, div13_nodes);
      div13_nodes.forEach(detach);
      div14_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "DerivedCollectionDesignerCloseBtn");
      attr(div2, "class", "ItemDesigner_TwoColumnData");
      attr(textarea0, "class", "calcInput ItemDesignerInput");
      attr(textarea0, "contenteditable", "");
      attr(div4, "data-succes", ctx[18]);
      attr(textarea1, "class", "calcInput");
      attr(textarea1, "placeholder", "insert Name Calc Statement here");
      attr(div5, "class", "derivedCalcStatementResult");
      attr(div5, "data-succes", ctx[18]);
      attr(div6, "data-succes", ctx[20]);
      attr(textarea2, "class", "calcInput");
      textarea2.value = ctx[21];
      attr(textarea2, "placeholder", "insert calcStatement here");
      attr(div7, "class", "derivedCalcStatementResult");
      attr(div7, "data-succes", ctx[20]);
      attr(div8, "class", "derivedCollectionCalcStatementMatrix");
      attr(div9, "class", "derivedOriginRowsContainer");
      attr(div10, "class", "OriginEditor");
      attr(div12, "class", "ItemDesignerButtonRow");
      attr(div14, "class", "DerivedCollectionDesigner");
      attr(div14, "data-state", div14_data_state_value = ctx[16] ? "good" : "error");
      attr(div14, "data-state-text", div14_data_state_text_value = ctx[16] ? ctx[2] : ctx[3]);
    },
    m(target, anchor) {
      insert_hydration(target, div14, anchor);
      append_hydration(div14, div0);
      append_hydration(div0, t0);
      append_hydration(div14, t1);
      append_hydration(div14, div1);
      append_hydration(div1, p);
      append_hydration(p, t2);
      append_hydration(div14, t3);
      append_hydration(div14, div2);
      append_hydration(div14, t4);
      append_hydration(div14, div11);
      append_hydration(div11, div10);
      append_hydration(div10, div8);
      append_hydration(div8, div3);
      append_hydration(div3, t5);
      append_hydration(div8, t6);
      append_hydration(div8, textarea0);
      set_input_value(textarea0, ctx[17]);
      append_hydration(div8, t7);
      append_hydration(div8, div4);
      append_hydration(div4, t8);
      append_hydration(div8, t9);
      append_hydration(div8, textarea1);
      append_hydration(div8, t10);
      append_hydration(div8, div5);
      append_hydration(div5, t11);
      append_hydration(div8, t12);
      append_hydration(div8, div6);
      append_hydration(div6, t13);
      append_hydration(div8, t14);
      append_hydration(div8, textarea2);
      append_hydration(div8, t15);
      append_hydration(div8, div7);
      append_hydration(div7, t16);
      append_hydration(div10, t17);
      append_hydration(div10, div9);
      if (if_block)
        if_block.m(div9, null);
      append_hydration(div14, t18);
      append_hydration(div14, br);
      append_hydration(div14, t19);
      append_hydration(div14, div12);
      append_hydration(div12, button0);
      append_hydration(button0, t20);
      append_hydration(div12, t21);
      append_hydration(div12, button1);
      append_hydration(button1, t22);
      append_hydration(div14, t23);
      append_hydration(div14, div13);
      mount_component(tooglesection, div13, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[35]),
          listen(div0, "keypress", ctx[34]),
          listen(textarea0, "input", ctx[36]),
          listen(textarea0, "input", ctx[37]),
          listen(textarea1, "input", ctx[27]),
          listen(textarea2, "input", ctx[28]),
          listen(button0, "click", ctx[31]),
          listen(button1, "click", ctx[32])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 131072) {
        set_input_value(textarea0, ctx2[17]);
      }
      if (!current || dirty[0] & 262144) {
        attr(div4, "data-succes", ctx2[18]);
      }
      if (!current || dirty[0] & 524288)
        set_data(t11, ctx2[19]);
      if (!current || dirty[0] & 262144) {
        attr(div5, "data-succes", ctx2[18]);
      }
      if (!current || dirty[0] & 1048576) {
        attr(div6, "data-succes", ctx2[20]);
      }
      if (!current || dirty[0] & 2097152) {
        textarea2.value = ctx2[21];
      }
      if (!current || dirty[0] & 4194304)
        set_data(t16, ctx2[22]);
      if (!current || dirty[0] & 1048576) {
        attr(div7, "data-succes", ctx2[20]);
      }
      if (ctx2[23] && ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8388610) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div9, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const tooglesection_changes = {};
      if (dirty[0] & 16777216 | dirty[1] & 32768) {
        tooglesection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooglesection.$set(tooglesection_changes);
      if (!current || dirty[0] & 65536 && div14_data_state_value !== (div14_data_state_value = ctx2[16] ? "good" : "error")) {
        attr(div14, "data-state", div14_data_state_value);
      }
      if (!current || dirty[0] & 65548 && div14_data_state_text_value !== (div14_data_state_text_value = ctx2[16] ? ctx2[2] : ctx2[3])) {
        attr(div14, "data-state-text", div14_data_state_text_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(tooglesection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(tooglesection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div14);
      if (if_block)
        if_block.d();
      destroy_component(tooglesection);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let availableSymbols;
  let $controllerIsValid, $$unsubscribe_controllerIsValid = noop, $$subscribe_controllerIsValid = () => ($$unsubscribe_controllerIsValid(), $$unsubscribe_controllerIsValid = subscribe(controllerIsValid, ($$value) => $$invalidate(16, $controllerIsValid = $$value)), controllerIsValid);
  let $controllerName, $$unsubscribe_controllerName = noop, $$subscribe_controllerName = () => ($$unsubscribe_controllerName(), $$unsubscribe_controllerName = subscribe(controllerName, ($$value) => $$invalidate(17, $controllerName = $$value)), controllerName);
  let $controllerNameResultSucces, $$unsubscribe_controllerNameResultSucces = noop, $$subscribe_controllerNameResultSucces = () => ($$unsubscribe_controllerNameResultSucces(), $$unsubscribe_controllerNameResultSucces = subscribe(controllerNameResultSucces, ($$value) => $$invalidate(18, $controllerNameResultSucces = $$value)), controllerNameResultSucces);
  let $controllerNameResultValue, $$unsubscribe_controllerNameResultValue = noop, $$subscribe_controllerNameResultValue = () => ($$unsubscribe_controllerNameResultValue(), $$unsubscribe_controllerNameResultValue = subscribe(controllerNameResultValue, ($$value) => $$invalidate(19, $controllerNameResultValue = $$value)), controllerNameResultValue);
  let $controllerResultSucces, $$unsubscribe_controllerResultSucces = noop, $$subscribe_controllerResultSucces = () => ($$unsubscribe_controllerResultSucces(), $$unsubscribe_controllerResultSucces = subscribe(controllerResultSucces, ($$value) => $$invalidate(20, $controllerResultSucces = $$value)), controllerResultSucces);
  let $controllerCalc, $$unsubscribe_controllerCalc = noop, $$subscribe_controllerCalc = () => ($$unsubscribe_controllerCalc(), $$unsubscribe_controllerCalc = subscribe(controllerCalc, ($$value) => $$invalidate(21, $controllerCalc = $$value)), controllerCalc);
  let $controllerResultValue, $$unsubscribe_controllerResultValue = noop, $$subscribe_controllerResultValue = () => ($$unsubscribe_controllerResultValue(), $$unsubscribe_controllerResultValue = subscribe(controllerResultValue, ($$value) => $$invalidate(22, $controllerResultValue = $$value)), controllerResultValue);
  let $controllerMappedOrigin, $$unsubscribe_controllerMappedOrigin = noop, $$subscribe_controllerMappedOrigin = () => ($$unsubscribe_controllerMappedOrigin(), $$unsubscribe_controllerMappedOrigin = subscribe(controllerMappedOrigin, ($$value) => $$invalidate(23, $controllerMappedOrigin = $$value)), controllerMappedOrigin);
  let $generativeNameListData, $$unsubscribe_generativeNameListData = noop, $$subscribe_generativeNameListData = () => ($$unsubscribe_generativeNameListData(), $$unsubscribe_generativeNameListData = subscribe(generativeNameListData, ($$value) => $$invalidate(24, $generativeNameListData = $$value)), generativeNameListData);
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerIsValid());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerName());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerNameResultSucces());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerNameResultValue());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerResultSucces());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerCalc());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerResultValue());
  $$self.$$.on_destroy.push(() => $$unsubscribe_controllerMappedOrigin());
  $$self.$$.on_destroy.push(() => $$unsubscribe_generativeNameListData());
  const dispatch2 = createEventDispatcher();
  let { system } = $$props;
  let { secondSlideInReady = false } = $$props;
  let { goodTitle = "No Error" } = $$props;
  let { badTitle = "Error" } = $$props;
  let { context } = $$props;
  let { messageHandler } = $$props;
  let controller = new DerivedCollectionController();
  let controllerMappedOrigin;
  let controllerResultValue;
  let controllerResultSucces;
  let controllerNameResultSucces;
  let controllerNameResultValue;
  let controllerName;
  let controllerCalc;
  let controllerIsValid;
  let generativeNameListData;
  function onNameInput(event) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    let name = event.target.value;
    controller.name.set(name);
    controller.checkIsValid(false);
  }
  function onCalcNameInput(event) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    let nameCalc = event.target.value;
    controller.nameCalc.set(nameCalc);
    controller.checkIsValid(false);
  }
  function onCalcInput(event) {
    let calc = event.target.value;
    controller.calc.set(calc);
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.recalculateCalcAndOrigins();
    controller.checkIsValid(false);
  }
  function onDeleteClicked(e) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.onKeyDelete(e);
    controller.checkIsValid(false);
  }
  function onKeyExchange(e) {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.onKeyExchange(e);
    controller.checkIsValid(false);
  }
  function onSave() {
    messageHandler === null || messageHandler === void 0 ? void 0 : messageHandler.removeError("save");
    controller.saveCollection();
    dispatch2("save");
  }
  function onGenPreviewToogle() {
    controller.generateNamePreview();
  }
  onMount(() => {
    controller.setControllerDeps(system);
    controller.recalculateCalcAndOrigins();
    controller.checkIsValid();
    $$subscribe_controllerMappedOrigin($$invalidate(6, controllerMappedOrigin = controller.mappedOrigins));
    $$subscribe_controllerResultValue($$invalidate(7, controllerResultValue = controller.resultValue));
    $$subscribe_controllerResultSucces($$invalidate(8, controllerResultSucces = controller.resultSuccess));
    $$subscribe_controllerNameResultSucces($$invalidate(9, controllerNameResultSucces = controller.resultNameSuccess));
    $$subscribe_controllerNameResultValue($$invalidate(10, controllerNameResultValue = controller.resultNameValue));
    $$subscribe_controllerName($$invalidate(11, controllerName = controller.name));
    $$subscribe_controllerCalc($$invalidate(12, controllerCalc = controller.calc));
    $$subscribe_controllerIsValid($$invalidate(13, controllerIsValid = controller.isValid));
    $$subscribe_generativeNameListData($$invalidate(14, generativeNameListData = controller.generativeNameListData));
  });
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => dispatch2("close");
  const input_handler = (e) => {
    onNameInput(e);
  };
  function textarea0_input_handler() {
    $controllerName = this.value;
    controllerName.set($controllerName);
  }
  function originrow_rowData_binding(value2, origin2, each_value_1, origin_index) {
    each_value_1[origin_index] = value2;
    controllerMappedOrigin.set($controllerMappedOrigin);
  }
  const foundTargetNode_handler = (e) => {
    controller.checkIsValid(false);
  };
  $$self.$$set = ($$props2) => {
    if ("system" in $$props2)
      $$invalidate(0, system = $$props2.system);
    if ("secondSlideInReady" in $$props2)
      $$invalidate(1, secondSlideInReady = $$props2.secondSlideInReady);
    if ("goodTitle" in $$props2)
      $$invalidate(2, goodTitle = $$props2.goodTitle);
    if ("badTitle" in $$props2)
      $$invalidate(3, badTitle = $$props2.badTitle);
    if ("context" in $$props2)
      $$invalidate(4, context = $$props2.context);
    if ("messageHandler" in $$props2)
      $$invalidate(33, messageHandler = $$props2.messageHandler);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 4) {
      $$invalidate(5, controller.messageHandler = messageHandler, controller);
    }
    if ($$self.$$.dirty[0] & 33) {
      controller.setControllerDeps(system);
    }
    if ($$self.$$.dirty[0] & 32) {
      $$invalidate(15, availableSymbols = get_store_value(controller.mappedOrigins).filter((p) => !p.active).map((p) => p.key));
    }
  };
  return [
    system,
    secondSlideInReady,
    goodTitle,
    badTitle,
    context,
    controller,
    controllerMappedOrigin,
    controllerResultValue,
    controllerResultSucces,
    controllerNameResultSucces,
    controllerNameResultValue,
    controllerName,
    controllerCalc,
    controllerIsValid,
    generativeNameListData,
    availableSymbols,
    $controllerIsValid,
    $controllerName,
    $controllerNameResultSucces,
    $controllerNameResultValue,
    $controllerResultSucces,
    $controllerCalc,
    $controllerResultValue,
    $controllerMappedOrigin,
    $generativeNameListData,
    dispatch2,
    onNameInput,
    onCalcNameInput,
    onCalcInput,
    onDeleteClicked,
    onKeyExchange,
    onSave,
    onGenPreviewToogle,
    messageHandler,
    keypress_handler,
    click_handler,
    input_handler,
    textarea0_input_handler,
    originrow_rowData_binding,
    foundTargetNode_handler
  ];
}
class DerivedCollectionDesigner extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$b,
      create_fragment$b,
      safe_not_equal,
      {
        system: 0,
        secondSlideInReady: 1,
        goodTitle: 2,
        badTitle: 3,
        context: 4,
        messageHandler: 33
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$a(ctx) {
  let svg;
  let circle;
  let line;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      var circle_nodes = children(circle);
      circle_nodes.forEach(detach);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      var line_nodes = children(line);
      line_nodes.forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(line, "x1", "8");
      attr(line, "y1", "12");
      attr(line, "x2", "16");
      attr(line, "y2", "12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svg-icon lucide-plus-circle");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, circle);
      append_hydration(svg, line);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { color = "black" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color];
}
class Minus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { color: 0 });
  }
}
function create_fragment$9(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        height: true,
        width: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M12 20h9");
      attr(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "height", "100%");
      attr(svg, "width", "100%");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svg-icon lucide-plus-circle");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path0);
      append_hydration(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { color = "black" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color];
}
class Edit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { color: 0 });
  }
}
function create_fragment$8(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
      attr(polyline, "points", "7 10 12 15 17 10");
      attr(line, "x1", "12");
      attr(line, "y1", "15");
      attr(line, "x2", "12");
      attr(line, "y2", "3");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svg-icon lucide-plus-circle");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path);
      append_hydration(svg, polyline);
      append_hydration(svg, line);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { color = "black" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  return [color];
}
class Download extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, { color: 0 });
  }
}
const toolTip = "";
function create_if_block$6(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ctx[0]);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "tooltipInnerBox");
      attr(div, "data-type", ctx[3]);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & 1)
        set_data(t, ctx[0]);
      if (!current || dirty & 8) {
        attr(div, "data-type", ctx[3]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fly, { x: ctx[1], y: ctx[2] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fly, { x: ctx[1], y: ctx[2] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let current;
  let if_block = ctx[4] && create_if_block$6(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { animX = 20 } = $$props;
  let { animY = 0 } = $$props;
  let { type } = $$props;
  let mounted = false;
  onMount(() => {
    setTimeout(
      () => {
        $$invalidate(4, mounted = true);
      },
      100
    );
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("animX" in $$props2)
      $$invalidate(1, animX = $$props2.animX);
    if ("animY" in $$props2)
      $$invalidate(2, animY = $$props2.animY);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
  };
  return [text2, animX, animY, type, mounted];
}
class ToolTip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, { text: 0, animX: 1, animY: 2, type: 3 });
  }
}
function tooltip(node, { text: text2, type = "none", animX = 20, animY = 0, Xoffset = 0, Yoffset = 0 }) {
  let tooltipElement;
  let tooltipComponent;
  function showTooltip() {
    tooltipElement = document.createElement("div");
    tooltipElement.style.position = "absolute";
    tooltipElement.style.zIndex = "2000";
    tooltipComponent = new ToolTip({
      target: tooltipElement,
      props: { text: text2, type, animX, animY }
    });
    document.body.appendChild(tooltipElement);
    const { top, left, width, height } = node.getBoundingClientRect();
    tooltipElement.style.top = `${top + height + window.scrollY + Yoffset}px`;
    tooltipElement.style.left = `${left + width / 2 - tooltipElement.offsetWidth / 2 + window.scrollX + Xoffset}px`;
  }
  function hideTooltip() {
    if (tooltipComponent) {
      tooltipComponent.$destroy();
      tooltipComponent = null;
    }
    if (tooltipElement) {
      tooltipElement.remove();
      tooltipElement = null;
    }
  }
  node.addEventListener("mouseenter", showTooltip);
  node.addEventListener("mouseleave", hideTooltip);
  return {
    update({ text: text3, type: type2 = "none", animX: animX2 = 20, animY: animY2 = 0, Xoffset: Xoffset2 = 0, Yoffset: Yoffset2 = 0 }) {
      text3 = newText;
      if (tooltipComponent) {
        tooltipComponent.$set({ text: text3, type: type2, animX: animX2, animY: animY2 });
      }
    },
    destroy() {
      node.removeEventListener("mouseenter", showTooltip);
      node.removeEventListener("mouseleave", hideTooltip);
      if (tooltipComponent) {
        tooltipComponent.$destroy();
      }
    }
  };
}
function create_else_block_1(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {
        tabindex: true,
        role: true,
        contenteditable: true,
        autofocus: true
      });
      var div_nodes = children(div);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "tabindex", "1");
      attr(div, "role", "cell");
      attr(div, "contenteditable", "true");
      attr(div, "autofocus", true);
      if (ctx[0].nameEdit === void 0)
        add_render_callback(() => ctx[14].call(div));
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (ctx[0].nameEdit !== void 0) {
        div.textContent = ctx[0].nameEdit;
      }
      div.focus();
      if (!mounted) {
        dispose = [
          listen(div, "focus", function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          }),
          listen(div, "input", ctx[14])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && ctx[0].nameEdit !== div.textContent) {
        div.textContent = ctx[0].nameEdit;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$5(ctx) {
  let div;
  let t_value = ctx[0].name + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {
        tabindex: true,
        contenteditable: true,
        role: true
      });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "tabindex", "-1");
      attr(div, "contenteditable", "false");
      attr(div, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[13]),
          listen(div, "keyup", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].name + ""))
        set_data_maybe_contenteditable(t, t_value, "false");
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$2(ctx) {
  let imageContainer;
  return {
    c() {
      imageContainer = element("imageContainer");
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", {});
      var imageContainer_nodes = children(imageContainer);
      imageContainer_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(imageContainer);
    }
  };
}
function create_if_block_1$5(ctx) {
  let imageContainer;
  let image_minus;
  let imageContainer_transition;
  let current;
  let mounted;
  let dispose;
  image_minus = new Minus({ props: { color: "white" } });
  return {
    c() {
      imageContainer = element("imageContainer");
      create_component(image_minus.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer_nodes = children(imageContainer);
      claim_component(image_minus.$$.fragment, imageContainer_nodes);
      imageContainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
      mount_component(image_minus, imageContainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer, "click", ctx[16]),
          listen(imageContainer, "keyup", ctx[11]),
          action_destroyer(tooltip.call(null, imageContainer, { text: "Delete item", type: "verbose" }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_minus.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer_transition)
            imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, true);
          imageContainer_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_minus.$$.fragment, local);
      if (local) {
        if (!imageContainer_transition)
          imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, false);
        imageContainer_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer);
      destroy_component(image_minus);
      if (detaching && imageContainer_transition)
        imageContainer_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$5(ctx) {
  let imageContainer;
  let image_trash;
  let imageContainer_transition;
  let current;
  let mounted;
  let dispose;
  image_trash = new Trash({ props: { color: "white" } });
  return {
    c() {
      imageContainer = element("imageContainer");
      create_component(image_trash.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer_nodes = children(imageContainer);
      claim_component(image_trash.$$.fragment, imageContainer_nodes);
      imageContainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
      mount_component(image_trash, imageContainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer, "click", ctx[15]),
          listen(imageContainer, "keyup", ctx[10]),
          action_destroyer(tooltip.call(null, imageContainer, { text: "Delete item", type: "verbose" }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_trash.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer_transition)
            imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, true);
          imageContainer_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_trash.$$.fragment, local);
      if (local) {
        if (!imageContainer_transition)
          imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, false);
        imageContainer_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer);
      destroy_component(image_trash);
      if (detaching && imageContainer_transition)
        imageContainer_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_key_block$1(ctx) {
  let div1;
  let t;
  let div0;
  let current_block_type_index;
  let if_block1;
  let div1_data_selected_value;
  let div1_data_isedit_value;
  let current;
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return create_if_block_2$5;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block$5, create_if_block_1$5, create_else_block$2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    if (ctx2[1] && ctx2[0].name != ctx2[0].nameEdit)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      if_block0.c();
      t = space();
      div0 = element("div");
      if_block1.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-selected": true,
        "data-can-hover": true,
        "data-isedit": true
      });
      var div1_nodes = children(div1);
      if_block0.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      var _a;
      attr(div1, "class", "Editable_row");
      attr(div1, "data-selected", div1_data_selected_value = !ctx[1] && ctx[0].key == ((_a = ctx[2]) == null ? void 0 : _a.key));
      attr(div1, "data-can-hover", true);
      attr(div1, "data-isedit", div1_data_isedit_value = ctx[1] && ctx[0].name != ctx[0].nameEdit);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if_block0.m(div1, null);
      append_hydration(div1, t);
      append_hydration(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div1, t);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (!current || dirty & 7 && div1_data_selected_value !== (div1_data_selected_value = !ctx2[1] && ctx2[0].key == ((_a = ctx2[2]) == null ? void 0 : _a.key))) {
        attr(div1, "data-selected", div1_data_selected_value);
      }
      if (!current || dirty & 3 && div1_data_isedit_value !== (div1_data_isedit_value = ctx2[1] && ctx2[0].name != ctx2[0].nameEdit)) {
        attr(div1, "data-isedit", div1_data_isedit_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$6(ctx) {
  let previous_key = ctx[9];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    l(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { editIsActive } = $$props;
  let { element: element2 } = $$props;
  let { selected } = $$props;
  let { deleteIsAllowed } = $$props;
  let { disabled } = $$props;
  let { onDelete } = $$props;
  let { onSelect } = $$props;
  let { onEditCancelSingle: onEditCancelSingle2 } = $$props;
  let { onEditFocus: onEditFocus2 } = $$props;
  let k = 0;
  let key = "editAbleRow" + StringFunctions.uuidv4();
  onMount(() => {
    element2.addEventListener(key, "update", update2);
  });
  onDestroy(() => {
    element2.removeEventListener(key);
  });
  function update2() {
    $$invalidate(9, k++, k);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => {
    if (disabled) {
      return;
    }
    onSelect(element2);
  };
  function div_input_handler() {
    element2.nameEdit = this.textContent;
    $$invalidate(0, element2);
  }
  const click_handler_1 = () => onDelete(element2);
  const click_handler_2 = () => onEditCancelSingle2(element2);
  $$self.$$set = ($$props2) => {
    if ("editIsActive" in $$props2)
      $$invalidate(1, editIsActive = $$props2.editIsActive);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("selected" in $$props2)
      $$invalidate(2, selected = $$props2.selected);
    if ("deleteIsAllowed" in $$props2)
      $$invalidate(3, deleteIsAllowed = $$props2.deleteIsAllowed);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
    if ("onDelete" in $$props2)
      $$invalidate(5, onDelete = $$props2.onDelete);
    if ("onSelect" in $$props2)
      $$invalidate(6, onSelect = $$props2.onSelect);
    if ("onEditCancelSingle" in $$props2)
      $$invalidate(7, onEditCancelSingle2 = $$props2.onEditCancelSingle);
    if ("onEditFocus" in $$props2)
      $$invalidate(8, onEditFocus2 = $$props2.onEditFocus);
  };
  return [
    element2,
    editIsActive,
    selected,
    deleteIsAllowed,
    disabled,
    onDelete,
    onSelect,
    onEditCancelSingle2,
    onEditFocus2,
    k,
    keyup_handler_1,
    keyup_handler_2,
    keyup_handler,
    click_handler,
    div_input_handler,
    click_handler_1,
    click_handler_2
  ];
}
class EditAbleListRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
      editIsActive: 1,
      element: 0,
      selected: 2,
      deleteIsAllowed: 3,
      disabled: 4,
      onDelete: 5,
      onSelect: 6,
      onEditCancelSingle: 7,
      onEditFocus: 8
    });
  }
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[25] = list;
  child_ctx[26] = i;
  const constants_0 = !child_ctx[6] && child_ctx[5] != null && !child_ctx[8];
  child_ctx[24] = constants_0;
  return child_ctx;
}
function create_if_block$4(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = ctx[4] != null && create_if_block_3$2(ctx);
  let if_block1 = ctx[2] != null && create_if_block_2$4(ctx);
  let if_block2 = ctx[3] != null && create_if_block_1$4(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-can-hover": true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "Editable_rowHeader");
      attr(div, "data-can-hover", true);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[4] != null) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[3] != null) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_3$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$1, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[8])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1(ctx) {
  let imageContainer0;
  let image_edit;
  let imageContainer0_transition;
  let t0;
  let imageContainer1;
  let image_save;
  let imageContainer1_transition;
  let t1;
  let imageContainer2;
  let image_minus;
  let imageContainer2_transition;
  let current;
  let mounted;
  let dispose;
  image_edit = new Edit({ props: { color: "white" } });
  image_save = new Download({ props: { color: "white" } });
  image_minus = new Minus({ props: { color: "white" } });
  return {
    c() {
      imageContainer0 = element("imageContainer");
      create_component(image_edit.$$.fragment);
      t0 = space();
      imageContainer1 = element("imageContainer");
      create_component(image_save.$$.fragment);
      t1 = space();
      imageContainer2 = element("imageContainer");
      create_component(image_minus.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer0 = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer0_nodes = children(imageContainer0);
      claim_component(image_edit.$$.fragment, imageContainer0_nodes);
      imageContainer0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      imageContainer1 = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer1_nodes = children(imageContainer1);
      claim_component(image_save.$$.fragment, imageContainer1_nodes);
      imageContainer1_nodes.forEach(detach);
      t1 = claim_space(nodes);
      imageContainer2 = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer2_nodes = children(imageContainer2);
      claim_component(image_minus.$$.fragment, imageContainer2_nodes);
      imageContainer2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer0, "role", "none");
      attr(imageContainer1, "role", "none");
      attr(imageContainer2, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer0, anchor);
      mount_component(image_edit, imageContainer0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, imageContainer1, anchor);
      mount_component(image_save, imageContainer1, null);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, imageContainer2, anchor);
      mount_component(image_minus, imageContainer2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer0, "click", ctx[11]),
          listen(imageContainer0, "keyup", ctx[11]),
          action_destroyer(tooltip.call(null, imageContainer0, {
            text: "Turn off Edit mode",
            type: "verbose"
          })),
          listen(imageContainer1, "click", ctx[12]),
          listen(imageContainer1, "keyup", ctx[12]),
          action_destroyer(tooltip.call(null, imageContainer1, {
            text: "Save changes made",
            type: "verbose"
          })),
          listen(imageContainer2, "click", ctx[11]),
          listen(imageContainer2, "keyup", ctx[11]),
          action_destroyer(tooltip.call(null, imageContainer2, { text: "Discard Changes", type: "verbose" }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_edit.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer0_transition)
            imageContainer0_transition = create_bidirectional_transition(imageContainer0, slide, {}, true);
          imageContainer0_transition.run(1);
        });
      }
      transition_in(image_save.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer1_transition)
            imageContainer1_transition = create_bidirectional_transition(imageContainer1, slide, {}, true);
          imageContainer1_transition.run(1);
        });
      }
      transition_in(image_minus.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer2_transition)
            imageContainer2_transition = create_bidirectional_transition(imageContainer2, slide, {}, true);
          imageContainer2_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_edit.$$.fragment, local);
      if (local) {
        if (!imageContainer0_transition)
          imageContainer0_transition = create_bidirectional_transition(imageContainer0, slide, {}, false);
        imageContainer0_transition.run(0);
      }
      transition_out(image_save.$$.fragment, local);
      if (local) {
        if (!imageContainer1_transition)
          imageContainer1_transition = create_bidirectional_transition(imageContainer1, slide, {}, false);
        imageContainer1_transition.run(0);
      }
      transition_out(image_minus.$$.fragment, local);
      if (local) {
        if (!imageContainer2_transition)
          imageContainer2_transition = create_bidirectional_transition(imageContainer2, slide, {}, false);
        imageContainer2_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer0);
      destroy_component(image_edit);
      if (detaching && imageContainer0_transition)
        imageContainer0_transition.end();
      if (detaching)
        detach(t0);
      if (detaching)
        detach(imageContainer1);
      destroy_component(image_save);
      if (detaching && imageContainer1_transition)
        imageContainer1_transition.end();
      if (detaching)
        detach(t1);
      if (detaching)
        detach(imageContainer2);
      destroy_component(image_minus);
      if (detaching && imageContainer2_transition)
        imageContainer2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$1(ctx) {
  let imageContainer;
  let image_edit;
  let imageContainer_transition;
  let current;
  let mounted;
  let dispose;
  image_edit = new Edit({ props: { color: "white" } });
  return {
    c() {
      imageContainer = element("imageContainer");
      create_component(image_edit.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer_nodes = children(imageContainer);
      claim_component(image_edit.$$.fragment, imageContainer_nodes);
      imageContainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
      mount_component(image_edit, imageContainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer, "click", ctx[11]),
          listen(imageContainer, "keyup", ctx[11]),
          action_destroyer(tooltip.call(null, imageContainer, {
            text: "Turn on Edit mode",
            type: "verbose"
          }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_edit.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer_transition)
            imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, true);
          imageContainer_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_edit.$$.fragment, local);
      if (local) {
        if (!imageContainer_transition)
          imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, false);
        imageContainer_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer);
      destroy_component(image_edit);
      if (detaching && imageContainer_transition)
        imageContainer_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$4(ctx) {
  let imageContainer;
  let image_plus;
  let imageContainer_transition;
  let current;
  let mounted;
  let dispose;
  image_plus = new Plus({ props: { color: "white" } });
  return {
    c() {
      imageContainer = element("imageContainer");
      create_component(image_plus.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer_nodes = children(imageContainer);
      claim_component(image_plus.$$.fragment, imageContainer_nodes);
      imageContainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
      mount_component(image_plus, imageContainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer, "click", ctx[19]),
          listen(imageContainer, "keyup", ctx[18]),
          action_destroyer(tooltip.call(null, imageContainer, { text: "Add To List", type: "verbose" }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_plus.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer_transition)
            imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, true);
          imageContainer_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_plus.$$.fragment, local);
      if (local) {
        if (!imageContainer_transition)
          imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, false);
        imageContainer_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer);
      destroy_component(image_plus);
      if (detaching && imageContainer_transition)
        imageContainer_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$4(ctx) {
  let imageContainer;
  let image_plus;
  let imageContainer_transition;
  let current;
  let mounted;
  let dispose;
  image_plus = new Plus({ props: { color: "yellow" } });
  return {
    c() {
      imageContainer = element("imageContainer");
      create_component(image_plus.$$.fragment);
      this.h();
    },
    l(nodes) {
      imageContainer = claim_element(nodes, "IMAGECONTAINER", { role: true });
      var imageContainer_nodes = children(imageContainer);
      claim_component(image_plus.$$.fragment, imageContainer_nodes);
      imageContainer_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(imageContainer, "role", "none");
    },
    m(target, anchor) {
      insert_hydration(target, imageContainer, anchor);
      mount_component(image_plus, imageContainer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(imageContainer, "click", ctx[20]),
          listen(imageContainer, "keyup", ctx[17]),
          action_destroyer(tooltip.call(null, imageContainer, {
            text: "Add Entire collection",
            type: "verbose"
          }))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(image_plus.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!imageContainer_transition)
            imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, true);
          imageContainer_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(image_plus.$$.fragment, local);
      if (local) {
        if (!imageContainer_transition)
          imageContainer_transition = create_bidirectional_transition(imageContainer, slide, {}, false);
        imageContainer_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(imageContainer);
      destroy_component(image_plus);
      if (detaching && imageContainer_transition)
        imageContainer_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(key_1, ctx) {
  let div;
  let editablelistrow;
  let updating_element;
  let t;
  let div_transition;
  let rect;
  let stop_animation = noop;
  let current;
  function editablelistrow_element_binding(value2) {
    ctx[21](value2, ctx[23], ctx[25], ctx[26]);
  }
  let editablelistrow_props = {
    editIsActive: ctx[8],
    selected: ctx[7],
    disabled: ctx[6],
    deleteIsAllowed: ctx[24],
    onDelete: ctx[13],
    onSelect: ctx[9],
    onEditCancelSingle,
    onEditFocus
  };
  if (ctx[23] !== void 0) {
    editablelistrow_props.element = ctx[23];
  }
  editablelistrow = new EditAbleListRow({ props: editablelistrow_props });
  binding_callbacks.push(() => bind(editablelistrow, "element", editablelistrow_element_binding));
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(editablelistrow.$$.fragment);
      t = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(editablelistrow.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(editablelistrow, div, null);
      append_hydration(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const editablelistrow_changes = {};
      if (dirty & 256)
        editablelistrow_changes.editIsActive = ctx[8];
      if (dirty & 128)
        editablelistrow_changes.selected = ctx[7];
      if (dirty & 64)
        editablelistrow_changes.disabled = ctx[6];
      if (dirty & 352)
        editablelistrow_changes.deleteIsAllowed = ctx[24];
      if (!updating_element && dirty & 1) {
        updating_element = true;
        editablelistrow_changes.element = ctx[23];
        add_flush_callback(() => updating_element = false);
      }
      editablelistrow.$set(editablelistrow_changes);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
      add_transform(div, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, {});
    },
    i(local) {
      if (current)
        return;
      transition_in(editablelistrow.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(editablelistrow.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(editablelistrow);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$5(ctx) {
  let div;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let current;
  let if_block = !ctx[6] && create_if_block$4(ctx);
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[23].key;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", div_class_value = ctx[1] ? "GrobsInteractiveContainer editableTable" : "editableTable");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 9185) {
        each_value = ctx2[0];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = ctx2[1] ? "GrobsInteractiveContainer editableTable" : "editableTable")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function onEditCancelSingle(item) {
  item.nameEdit = item.name;
}
function onEditFocus(row) {
  const element2 = row.target;
  const range = document.createRange();
  const selection = window.getSelection();
  if (!range || !selection) {
    return;
  }
  range.selectNodeContents(element2);
  range.collapse(false);
  selection.removeAllRanges();
  selection.addRange(range);
}
function instance$5($$self, $$props, $$invalidate) {
  let { isEditableContainer = true } = $$props;
  let { collection = [] } = $$props;
  let { onSelect } = $$props;
  let { onAdd = null } = $$props;
  let { onSpecialAdd = null } = $$props;
  let { onUpdateItem } = $$props;
  let { onDeleteItem } = $$props;
  let { disabled = false } = $$props;
  const dispatch2 = createEventDispatcher();
  let selected = null;
  let editIsActive = false;
  onMount(() => {
  });
  onDestroy(() => {
  });
  function deselect() {
    if (!selected)
      return;
    $$invalidate(7, selected = null);
    dispatch2("onDeSelect");
  }
  function select(key) {
    let item = collection.find((p) => p.key == key);
    if ((item === null || item === void 0 ? void 0 : item.key) == (selected === null || selected === void 0 ? void 0 : selected.key)) {
      deselect();
      return;
    } else if (item) {
      _onSelect(item);
    }
  }
  function _onSelect(item) {
    if (item.key == (selected === null || selected === void 0 ? void 0 : selected.key)) {
      deselect();
      return;
    }
    const isSelected = onSelect(item);
    if (isSelected) {
      $$invalidate(7, selected = item);
    } else {
      $$invalidate(7, selected = null);
    }
  }
  function _onAdd() {
    if (!onAdd)
      return;
    onAdd();
  }
  function onEditClicked() {
    collection.forEach((item) => {
      item.nameEdit = item.name;
    });
    $$invalidate(8, editIsActive = !editIsActive);
  }
  function onEditSaved() {
    if (!onUpdateItem) {
      return;
    }
    onUpdateItem(collection);
    $$invalidate(8, editIsActive = !editIsActive);
  }
  function onDelete(item) {
    if (!onDeleteItem) {
      return;
    }
    onDeleteItem(item);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => {
    if (_onAdd) {
      _onAdd();
    }
  };
  const click_handler_1 = () => {
    if (onSpecialAdd) {
      onSpecialAdd();
    }
  };
  function editablelistrow_element_binding(value2, element2, each_value, i) {
    each_value[i] = value2;
    $$invalidate(0, collection);
  }
  $$self.$$set = ($$props2) => {
    if ("isEditableContainer" in $$props2)
      $$invalidate(1, isEditableContainer = $$props2.isEditableContainer);
    if ("collection" in $$props2)
      $$invalidate(0, collection = $$props2.collection);
    if ("onSelect" in $$props2)
      $$invalidate(14, onSelect = $$props2.onSelect);
    if ("onAdd" in $$props2)
      $$invalidate(2, onAdd = $$props2.onAdd);
    if ("onSpecialAdd" in $$props2)
      $$invalidate(3, onSpecialAdd = $$props2.onSpecialAdd);
    if ("onUpdateItem" in $$props2)
      $$invalidate(4, onUpdateItem = $$props2.onUpdateItem);
    if ("onDeleteItem" in $$props2)
      $$invalidate(5, onDeleteItem = $$props2.onDeleteItem);
    if ("disabled" in $$props2)
      $$invalidate(6, disabled = $$props2.disabled);
  };
  return [
    collection,
    isEditableContainer,
    onAdd,
    onSpecialAdd,
    onUpdateItem,
    onDeleteItem,
    disabled,
    selected,
    editIsActive,
    _onSelect,
    _onAdd,
    onEditClicked,
    onEditSaved,
    onDelete,
    onSelect,
    deselect,
    select,
    keyup_handler_1,
    keyup_handler,
    click_handler,
    click_handler_1,
    editablelistrow_element_binding
  ];
}
class EditAbleList2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
      isEditableContainer: 1,
      collection: 0,
      onSelect: 14,
      onAdd: 2,
      onSpecialAdd: 3,
      onUpdateItem: 4,
      onDeleteItem: 5,
      disabled: 6,
      deselect: 15,
      select: 16
    });
  }
  get deselect() {
    return this.$$.ctx[15];
  }
  get select() {
    return this.$$.ctx[16];
  }
}
function create_else_block(ctx) {
  let div;
  let tooglesection0;
  let t;
  let tooglesection1;
  let div_transition;
  let current;
  tooglesection0 = new ToogleSection({
    props: {
      title: "fixed",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  tooglesection1 = new ToogleSection({
    props: {
      title: "derived",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tooglesection0.$$.fragment);
      t = space();
      create_component(tooglesection1.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(tooglesection0.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(tooglesection1.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(tooglesection0, div, null);
      append_hydration(div, t);
      mount_component(tooglesection1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tooglesection0_changes = {};
      if (dirty[0] & 342 | dirty[1] & 16384) {
        tooglesection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooglesection0.$set(tooglesection0_changes);
      const tooglesection1_changes = {};
      if (dirty[0] & 171 | dirty[1] & 16384) {
        tooglesection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooglesection1.$set(tooglesection1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tooglesection0.$$.fragment, local);
      transition_in(tooglesection1.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(tooglesection0.$$.fragment, local);
      transition_out(tooglesection1.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tooglesection0);
      destroy_component(tooglesection1);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block$3(ctx) {
  let div;
  let derivedcollectiondesigner;
  let current;
  derivedcollectiondesigner = new DerivedCollectionDesigner({
    props: {
      context: ctx[0],
      system: ctx[9],
      secondSlideInReady: true,
      messageHandler: ctx[8]
    }
  });
  derivedcollectiondesigner.$on("close", ctx[18]);
  return {
    c() {
      div = element("div");
      create_component(derivedcollectiondesigner.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(derivedcollectiondesigner.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(derivedcollectiondesigner, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const derivedcollectiondesigner_changes = {};
      if (dirty[0] & 1)
        derivedcollectiondesigner_changes.context = ctx2[0];
      if (dirty[0] & 256)
        derivedcollectiondesigner_changes.messageHandler = ctx2[8];
      derivedcollectiondesigner.$set(derivedcollectiondesigner_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(derivedcollectiondesigner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(derivedcollectiondesigner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(derivedcollectiondesigner);
    }
  };
}
function create_if_block_2$3(ctx) {
  var _a;
  let previous_key = (_a = ctx[4]) == null ? void 0 : _a.key;
  let key_block_anchor;
  let current;
  let key_block = create_key_block_1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    l(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty[0] & 16 && safe_not_equal(previous_key, previous_key = (_a2 = ctx2[4]) == null ? void 0 : _a2.key)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_key_block_1(ctx) {
  let div;
  let fixeditemdesigner;
  let div_transition;
  let current;
  let fixeditemdesigner_props = {
    node: ctx[4],
    system: ctx[9],
    messageHandler: ctx[8]
  };
  fixeditemdesigner = new FixedItemDesigner({ props: fixeditemdesigner_props });
  ctx[29](fixeditemdesigner);
  fixeditemdesigner.$on("save", save_handler);
  return {
    c() {
      div = element("div");
      create_component(fixeditemdesigner.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(fixeditemdesigner.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(fixeditemdesigner, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const fixeditemdesigner_changes = {};
      if (dirty[0] & 16)
        fixeditemdesigner_changes.node = ctx2[4];
      if (dirty[0] & 256)
        fixeditemdesigner_changes.messageHandler = ctx2[8];
      fixeditemdesigner.$set(fixeditemdesigner_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fixeditemdesigner.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(fixeditemdesigner.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[29](null);
      destroy_component(fixeditemdesigner);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let h1;
  let t0;
  let t1;
  let p;
  let t2;
  let t3;
  let div1;
  let editablelist20;
  let t4;
  let editablelist21;
  let t5;
  let if_block_anchor;
  let current;
  editablelist20 = new EditAbleList2({
    props: {
      collection: (_b = (_a = ctx[11]) == null ? void 0 : _a.collections) != null ? _b : [],
      onSelect: ctx[19],
      onAdd: ctx[20],
      onUpdateItem: ctx[21],
      onDeleteItem: ctx[22]
    }
  });
  editablelist20.$on("onDeSelect", ctx[23]);
  editablelist21 = new EditAbleList2({
    props: {
      disabled: ctx[2] == null,
      collection: (_d = (_c = ctx[2]) == null ? void 0 : _c.nodes) != null ? _d : [],
      onSelect: ctx[24],
      onAdd: ctx[25],
      onUpdateItem: ctx[26],
      onDeleteItem: ctx[27]
    }
  });
  editablelist21.$on("onDeSelect", ctx[28]);
  let if_block = ctx[4] && create_if_block_2$3(ctx);
  return {
    c() {
      div0 = element("div");
      h1 = element("h1");
      t0 = text("Fixed Item Design");
      t1 = space();
      p = element("p");
      t2 = text("Fixed properties are the properties that are defiend on each article's meta data.");
      t3 = space();
      div1 = element("div");
      create_component(editablelist20.$$.fragment);
      t4 = space();
      create_component(editablelist21.$$.fragment);
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      h1 = claim_element(div0_nodes, "H1", {});
      var h1_nodes = children(h1);
      t0 = claim_text(h1_nodes, "Fixed Item Design");
      h1_nodes.forEach(detach);
      t1 = claim_space(div0_nodes);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, "Fixed properties are the properties that are defiend on each article's meta data.");
      p_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t3 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      claim_component(editablelist20.$$.fragment, div1_nodes);
      t4 = claim_space(div1_nodes);
      claim_component(editablelist21.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      t5 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      set_style(div1, "display", "grid");
      set_style(div1, "grid-template-columns", "1fr 1fr");
      set_style(div1, "gap", "10px");
      set_style(div1, "align-items", "start");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      append_hydration(div0, h1);
      append_hydration(h1, t0);
      append_hydration(div0, t1);
      append_hydration(div0, p);
      append_hydration(p, t2);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(editablelist20, div1, null);
      append_hydration(div1, t4);
      mount_component(editablelist21, div1, null);
      insert_hydration(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const editablelist20_changes = {};
      if (dirty[0] & 2)
        editablelist20_changes.onDeleteItem = ctx2[22];
      editablelist20.$set(editablelist20_changes);
      const editablelist21_changes = {};
      if (dirty[0] & 4)
        editablelist21_changes.disabled = ctx2[2] == null;
      if (dirty[0] & 4)
        editablelist21_changes.collection = (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.nodes) != null ? _b2 : [];
      if (dirty[0] & 4)
        editablelist21_changes.onAdd = ctx2[25];
      if (dirty[0] & 20)
        editablelist21_changes.onDeleteItem = ctx2[27];
      editablelist21.$set(editablelist21_changes);
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablelist20.$$.fragment, local);
      transition_in(editablelist21.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(editablelist20.$$.fragment, local);
      transition_out(editablelist21.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(editablelist20);
      destroy_component(editablelist21);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$3(ctx) {
  var _a;
  let previous_key = (_a = ctx[3]) == null ? void 0 : _a.key;
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    l(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty[0] & 8 && safe_not_equal(previous_key, previous_key = (_a2 = ctx2[3]) == null ? void 0 : _a2.key)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_key_block(ctx) {
  let div;
  let deriveditemdesigner;
  let div_transition;
  let current;
  let deriveditemdesigner_props = {
    node: ctx[3],
    system: ctx[9],
    context: ctx[0]
  };
  deriveditemdesigner = new DerivedItemDesigner({ props: deriveditemdesigner_props });
  ctx[40](deriveditemdesigner);
  return {
    c() {
      div = element("div");
      create_component(deriveditemdesigner.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(deriveditemdesigner.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(deriveditemdesigner, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const deriveditemdesigner_changes = {};
      if (dirty[0] & 8)
        deriveditemdesigner_changes.node = ctx2[3];
      if (dirty[0] & 1)
        deriveditemdesigner_changes.context = ctx2[0];
      deriveditemdesigner.$set(deriveditemdesigner_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(deriveditemdesigner.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(deriveditemdesigner.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[40](null);
      destroy_component(deriveditemdesigner);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let h1;
  let t0;
  let t1;
  let p;
  let t2;
  let t3;
  let div1;
  let editablelist20;
  let t4;
  let editablelist21;
  let t5;
  let if_block_anchor;
  let current;
  editablelist20 = new EditAbleList2({
    props: {
      collection: (_b = (_a = ctx[10]) == null ? void 0 : _a.collections) != null ? _b : [],
      onSelect: ctx[30],
      onAdd: ctx[31],
      onUpdateItem: ctx[32],
      onDeleteItem: ctx[33],
      onSpecialAdd: ctx[34]
    }
  });
  editablelist20.$on("onDeSelect", ctx[35]);
  editablelist21 = new EditAbleList2({
    props: {
      disabled: ctx[1] == null,
      collection: (_d = (_c = ctx[1]) == null ? void 0 : _c.nodes) != null ? _d : [],
      onSelect: ctx[36],
      onAdd: ctx[37],
      onUpdateItem: ctx[38],
      onDeleteItem: ctx[39]
    }
  });
  editablelist21.$on("onDeSelect", onDeSelect_handler_3);
  let if_block = ctx[3] && create_if_block_1$3(ctx);
  return {
    c() {
      div0 = element("div");
      h1 = element("h1");
      t0 = text("Derived Item Design");
      t1 = space();
      p = element("p");
      t2 = text("Derived properties are the data, that are derived from fixedData");
      t3 = space();
      div1 = element("div");
      create_component(editablelist20.$$.fragment);
      t4 = space();
      create_component(editablelist21.$$.fragment);
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      h1 = claim_element(div0_nodes, "H1", {});
      var h1_nodes = children(h1);
      t0 = claim_text(h1_nodes, "Derived Item Design");
      h1_nodes.forEach(detach);
      t1 = claim_space(div0_nodes);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, "Derived properties are the data, that are derived from fixedData");
      p_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t3 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      claim_component(editablelist20.$$.fragment, div1_nodes);
      t4 = claim_space(div1_nodes);
      claim_component(editablelist21.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      t5 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      set_style(div1, "display", "grid");
      set_style(div1, "grid-template-columns", "1fr 1fr");
      set_style(div1, "gap", "10px");
      set_style(div1, "align-items", "start");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      append_hydration(div0, h1);
      append_hydration(h1, t0);
      append_hydration(div0, t1);
      append_hydration(div0, p);
      append_hydration(p, t2);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(editablelist20, div1, null);
      append_hydration(div1, t4);
      mount_component(editablelist21, div1, null);
      insert_hydration(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const editablelist20_changes = {};
      if (dirty[0] & 2)
        editablelist20_changes.onDeleteItem = ctx2[33];
      if (dirty[0] & 32)
        editablelist20_changes.onSpecialAdd = ctx2[34];
      editablelist20.$set(editablelist20_changes);
      const editablelist21_changes = {};
      if (dirty[0] & 2)
        editablelist21_changes.disabled = ctx2[1] == null;
      if (dirty[0] & 2)
        editablelist21_changes.collection = (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.nodes) != null ? _b2 : [];
      if (dirty[0] & 2)
        editablelist21_changes.onAdd = ctx2[37];
      if (dirty[0] & 10)
        editablelist21_changes.onDeleteItem = ctx2[39];
      editablelist21.$set(editablelist21_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablelist20.$$.fragment, local);
      transition_in(editablelist21.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(editablelist20.$$.fragment, local);
      transition_out(editablelist21.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(editablelist20);
      destroy_component(editablelist21);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$4(ctx) {
  let div;
  let staticmessagehandler;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  let staticmessagehandler_props = {};
  staticmessagehandler = new StaticMessageHandler({ props: staticmessagehandler_props });
  ctx[17](staticmessagehandler);
  const if_block_creators = [create_if_block$3, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(staticmessagehandler.$$.fragment);
      t = space();
      if_block.c();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(staticmessagehandler.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if_block.l(div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(staticmessagehandler, div, null);
      append_hydration(div, t);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const staticmessagehandler_changes = {};
      staticmessagehandler.$set(staticmessagehandler_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(staticmessagehandler.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(staticmessagehandler.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[17](null);
      destroy_component(staticmessagehandler);
      if_blocks[current_block_type_index].d();
    }
  };
}
const designerKey = "sysDesigner";
const save_handler = (e) => {
  e.detail;
};
const onDeSelect_handler_3 = () => {
};
function instance$4($$self, $$props, $$invalidate) {
  var _a, _b;
  let { context } = $$props;
  let { system } = $$props;
  let uiSystem = (_a = context.uiSystem) !== null && _a !== void 0 ? _a : new UISystem(system);
  let guidKey = (_b = context.uiGuid) !== null && _b !== void 0 ? _b : "designer" + StringFunctions.uuidv4();
  context.uiSystem = uiSystem;
  context.uiGuid = guidKey;
  let derivedGrp = uiSystem.groups.find((p) => p.name == "derived");
  let fixedGrp = uiSystem.groups.find((p) => p.name == "fixed");
  let derivedCol = null;
  let fixedCol = null;
  let derivedNod = null;
  let fixedNod = null;
  let specialOn = false;
  let designerFixed;
  let designerDerived;
  function designerUIUpdate() {
    designerDerived === null || designerDerived === void 0 ? void 0 : designerDerived.forceUpdate();
    designerFixed === null || designerFixed === void 0 ? void 0 : designerFixed.forceUpdate();
  }
  function _colSelect(grp, col) {
    _nodSelect(grp, null);
    if (grp == "derived") {
      if (derivedCol) {
        derivedCol === null || derivedCol === void 0 ? void 0 : derivedCol.removeEventListener(guidKey);
      }
      $$invalidate(1, derivedCol = col);
      derivedCol === null || derivedCol === void 0 ? void 0 : derivedCol.addEventListener(guidKey, "update", () => {
        $$invalidate(1, derivedCol);
      });
    } else {
      if (fixedCol) {
        fixedCol === null || fixedCol === void 0 ? void 0 : fixedCol.removeEventListener(guidKey);
      }
      $$invalidate(2, fixedCol = col);
      fixedCol === null || fixedCol === void 0 ? void 0 : fixedCol.addEventListener(guidKey, "update", () => {
        $$invalidate(2, fixedCol);
      });
    }
  }
  function _nodSelect(grp, nod) {
    if (grp == "derived") {
      derivedNod === null || derivedNod === void 0 ? void 0 : derivedNod.removeEventListener(guidKey);
      $$invalidate(3, derivedNod = nod);
      derivedNod === null || derivedNod === void 0 ? void 0 : derivedNod.addEventListener(guidKey, "update", () => {
        designerUIUpdate();
      });
    } else {
      fixedNod === null || fixedNod === void 0 ? void 0 : fixedNod.removeEventListener(guidKey);
      $$invalidate(4, fixedNod = nod);
      fixedNod === null || fixedNod === void 0 ? void 0 : fixedNod.addEventListener(guidKey, "update", () => {
        designerUIUpdate();
      });
    }
  }
  function _colUpdate(grp, colArr) {
    colArr.forEach((n) => {
      if (n.name != n.nameEdit) {
        uiSystem.renameCollection(grp, n.name, n.nameEdit);
      }
    });
  }
  function _nodUpdate(grp, nodArr) {
    let col = grp == "derived" ? derivedCol : fixedCol;
    if (!col)
      return;
    nodArr.forEach((n) => {
      if (n.name != n.nameEdit) {
        uiSystem.renameNode(grp, col.name, n.name, n.nameEdit);
      }
    });
  }
  onMount(() => {
    derivedGrp === null || derivedGrp === void 0 ? void 0 : derivedGrp.addEventListener(designerKey, "update", () => {
      _colSelect("derived", null);
    });
  });
  onDestroy(() => {
    derivedGrp === null || derivedGrp === void 0 ? void 0 : derivedGrp.removeEventListener(designerKey);
  });
  let messageHandler;
  function staticmessagehandler_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      messageHandler = $$value;
      $$invalidate(8, messageHandler);
    });
  }
  const close_handler = () => {
    $$invalidate(5, specialOn = false);
  };
  const func2 = (e) => {
    _colSelect("fixed", e);
    return true;
  };
  const func_1 = () => {
    uiSystem.addCollection("fixed");
  };
  const func_2 = (arr) => {
    _colUpdate("fixed", arr);
    return true;
  };
  const func_3 = (e) => {
    uiSystem.remCollection("fixed", e.name);
    if (e.key == (derivedCol == null ? void 0 : derivedCol.key)) {
      _colSelect("fixed", null);
    }
  };
  const onDeSelect_handler2 = () => {
    _colSelect("fixed", null);
  };
  const func_4 = (e) => {
    _nodSelect("fixed", e);
    return true;
  };
  const func_5 = () => {
    uiSystem.addNode("fixed", fixedCol == null ? void 0 : fixedCol.name);
  };
  const func_6 = (arr) => {
    _nodUpdate("fixed", arr);
    return true;
  };
  const func_7 = (e) => {
    var _a2;
    uiSystem.remNode("fixed", (_a2 = fixedCol == null ? void 0 : fixedCol.name) != null ? _a2 : "", e.name);
    if (e.key == (fixedNod == null ? void 0 : fixedNod.key)) {
      _nodSelect("fixed", null);
    }
  };
  const onDeSelect_handler_1 = () => {
    _nodSelect("fixed", null);
  };
  function fixeditemdesigner_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      designerFixed = $$value;
      $$invalidate(6, designerFixed);
    });
  }
  const func_8 = (e) => {
    _colSelect("derived", e);
    return true;
  };
  const func_9 = () => {
    uiSystem.addCollection("derived");
  };
  const func_10 = (arr) => {
    _colUpdate("derived", arr);
    return true;
  };
  const func_11 = (e) => {
    uiSystem.remCollection("derived", e.name);
    if (e.key == (derivedCol == null ? void 0 : derivedCol.key)) {
      _colSelect("derived", null);
    }
  };
  const func_12 = () => {
    $$invalidate(5, specialOn = !specialOn);
  };
  const onDeSelect_handler_2 = () => {
    _colSelect("derived", null);
  };
  const func_13 = (e) => {
    _nodSelect("derived", e);
    return true;
  };
  const func_14 = () => {
    uiSystem.addNode("derived", derivedCol == null ? void 0 : derivedCol.name);
  };
  const func_15 = (arr) => {
    _nodUpdate("derived", arr);
    return true;
  };
  const func_16 = (e) => {
    var _a2;
    uiSystem.remNode("derived", (_a2 = derivedCol == null ? void 0 : derivedCol.name) != null ? _a2 : "", e.name);
    if (e.key == (derivedNod == null ? void 0 : derivedNod.key)) {
      _nodSelect("derived", null);
    }
  };
  function deriveditemdesigner_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      designerDerived = $$value;
      $$invalidate(7, designerDerived);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("system" in $$props2)
      $$invalidate(16, system = $$props2.system);
  };
  return [
    context,
    derivedCol,
    fixedCol,
    derivedNod,
    fixedNod,
    specialOn,
    designerFixed,
    designerDerived,
    messageHandler,
    uiSystem,
    derivedGrp,
    fixedGrp,
    _colSelect,
    _nodSelect,
    _colUpdate,
    _nodUpdate,
    system,
    staticmessagehandler_binding,
    close_handler,
    func2,
    func_1,
    func_2,
    func_3,
    onDeSelect_handler2,
    func_4,
    func_5,
    func_6,
    func_7,
    onDeSelect_handler_1,
    fixeditemdesigner_binding,
    func_8,
    func_9,
    func_10,
    func_11,
    func_12,
    onDeSelect_handler_2,
    func_13,
    func_14,
    func_15,
    func_16,
    deriveditemdesigner_binding
  ];
}
class SystemDesigner3Parts extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { context: 0, system: 16 }, null, [-1, -1]);
  }
}
function create_if_block_2$2(ctx) {
  let div3;
  let section;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      section = element("section");
      div0 = element("div");
      t0 = text("X");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = text("use this as a base for a ui theme that can be used for character sheets.");
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", {});
      var div3_nodes = children(div3);
      section = claim_element(div3_nodes, "SECTION", {});
      var section_nodes = children(section);
      div0 = claim_element(section_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "X");
      div0_nodes.forEach(detach);
      t1 = claim_space(section_nodes);
      div2 = claim_element(section_nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "use this as a base for a ui theme that can be used for character sheets.");
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      section_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "SystemExporterOptionsCloseBtn");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, section);
      append_hydration(section, div0);
      append_hydration(div0, t0);
      append_hydration(section, t1);
      append_hydration(section, div2);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[10]),
          listen(div0, "keypress", ctx[6])
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div3_transition)
            div3_transition = create_bidirectional_transition(div3, slide, {}, true);
          div3_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, slide, {}, false);
        div3_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$2(ctx) {
  let div3;
  let section;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      section = element("section");
      div0 = element("div");
      t0 = text("X");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = text("use this as a base for a ui theme that can be used for character sheets.");
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", {});
      var div3_nodes = children(div3);
      section = claim_element(div3_nodes, "SECTION", {});
      var section_nodes = children(section);
      div0 = claim_element(section_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "X");
      div0_nodes.forEach(detach);
      t1 = claim_space(section_nodes);
      div2 = claim_element(section_nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "use this as a base for a ui theme that can be used for character sheets.");
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      section_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "SystemExporterOptionsCloseBtn");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, section);
      append_hydration(section, div0);
      append_hydration(div0, t0);
      append_hydration(section, t1);
      append_hydration(section, div2);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[9]),
          listen(div0, "keypress", ctx[5])
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div3_transition)
            div3_transition = create_bidirectional_transition(div3, slide, {}, true);
          div3_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, slide, {}, false);
        div3_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2(ctx) {
  let div8;
  let section0;
  let br0;
  let t0;
  let div1;
  let b;
  let t1;
  let t2;
  let div0;
  let p0;
  let t3;
  let t4;
  let p1;
  let t5;
  let t6;
  let div2;
  let editablelist;
  let t7;
  let br1;
  let t8;
  let section1;
  let div4;
  let button0;
  let t9;
  let t10;
  let div3;
  let t11;
  let t12;
  let div6;
  let button1;
  let t13;
  let t14;
  let div5;
  let t15;
  let t16;
  let section2;
  let br2;
  let t17;
  let div7;
  let t18;
  let br3;
  let br4;
  let t19;
  let div8_transition;
  let current;
  let mounted;
  let dispose;
  editablelist = new EditAbleList({
    props: {
      isEditableContainer: false,
      collection: ["theme - A", "theme - B", "theme - C"],
      onSelect: func$1
    }
  });
  editablelist.$on("onDeSelect", onDeSelect_handler);
  return {
    c() {
      div8 = element("div");
      section0 = element("section");
      br0 = element("br");
      t0 = space();
      div1 = element("div");
      b = element("b");
      t1 = text("UI-theme's");
      t2 = space();
      div0 = element("div");
      p0 = element("p");
      t3 = text("author :");
      t4 = space();
      p1 = element("p");
      t5 = text("version :");
      t6 = space();
      div2 = element("div");
      create_component(editablelist.$$.fragment);
      t7 = space();
      br1 = element("br");
      t8 = space();
      section1 = element("section");
      div4 = element("div");
      button0 = element("button");
      t9 = text("Export New UI Project");
      t10 = space();
      div3 = element("div");
      t11 = text("use this as a base for a ui theme that can be used for character sheets.");
      t12 = space();
      div6 = element("div");
      button1 = element("button");
      t13 = text("Import a UI project");
      t14 = space();
      div5 = element("div");
      t15 = text("click her, to Open Importer.");
      t16 = space();
      section2 = element("section");
      br2 = element("br");
      t17 = space();
      div7 = element("div");
      t18 = text("click her, to Open Importer. details .... details .... details .... ");
      br3 = element("br");
      br4 = element("br");
      t19 = text("\n					details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details ....");
      this.h();
    },
    l(nodes) {
      div8 = claim_element(nodes, "DIV", {});
      var div8_nodes = children(div8);
      section0 = claim_element(div8_nodes, "SECTION", {});
      var section0_nodes = children(section0);
      br0 = claim_element(section0_nodes, "BR", {});
      t0 = claim_space(section0_nodes);
      div1 = claim_element(section0_nodes, "DIV", {});
      var div1_nodes = children(div1);
      b = claim_element(div1_nodes, "B", {});
      var b_nodes = children(b);
      t1 = claim_text(b_nodes, "UI-theme's");
      b_nodes.forEach(detach);
      t2 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      p0 = claim_element(div0_nodes, "P", {});
      var p0_nodes = children(p0);
      t3 = claim_text(p0_nodes, "author :");
      p0_nodes.forEach(detach);
      t4 = claim_space(div0_nodes);
      p1 = claim_element(div0_nodes, "P", {});
      var p1_nodes = children(p1);
      t5 = claim_text(p1_nodes, "version :");
      p1_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t6 = claim_space(section0_nodes);
      div2 = claim_element(section0_nodes, "DIV", {});
      var div2_nodes = children(div2);
      claim_component(editablelist.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach);
      section0_nodes.forEach(detach);
      t7 = claim_space(div8_nodes);
      br1 = claim_element(div8_nodes, "BR", {});
      t8 = claim_space(div8_nodes);
      section1 = claim_element(div8_nodes, "SECTION", { class: true });
      var section1_nodes = children(section1);
      div4 = claim_element(section1_nodes, "DIV", {});
      var div4_nodes = children(div4);
      button0 = claim_element(div4_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t9 = claim_text(button0_nodes, "Export New UI Project");
      button0_nodes.forEach(detach);
      t10 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", {});
      var div3_nodes = children(div3);
      t11 = claim_text(div3_nodes, "use this as a base for a ui theme that can be used for character sheets.");
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      t12 = claim_space(section1_nodes);
      div6 = claim_element(section1_nodes, "DIV", {});
      var div6_nodes = children(div6);
      button1 = claim_element(div6_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t13 = claim_text(button1_nodes, "Import a UI project");
      button1_nodes.forEach(detach);
      t14 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", {});
      var div5_nodes = children(div5);
      t15 = claim_text(div5_nodes, "click her, to Open Importer.");
      div5_nodes.forEach(detach);
      div6_nodes.forEach(detach);
      section1_nodes.forEach(detach);
      t16 = claim_space(div8_nodes);
      section2 = claim_element(div8_nodes, "SECTION", {});
      var section2_nodes = children(section2);
      br2 = claim_element(section2_nodes, "BR", {});
      t17 = claim_space(section2_nodes);
      div7 = claim_element(section2_nodes, "DIV", {});
      var div7_nodes = children(div7);
      t18 = claim_text(div7_nodes, "click her, to Open Importer. details .... details .... details .... ");
      br3 = claim_element(div7_nodes, "BR", {});
      br4 = claim_element(div7_nodes, "BR", {});
      t19 = claim_text(div7_nodes, "\n					details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details .... details ....");
      div7_nodes.forEach(detach);
      section2_nodes.forEach(detach);
      div8_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button0, "class", "SystemExporterButton");
      attr(button1, "class", "SystemExporterButton");
      attr(section1, "class", "SystemExporterOptions");
    },
    m(target, anchor) {
      insert_hydration(target, div8, anchor);
      append_hydration(div8, section0);
      append_hydration(section0, br0);
      append_hydration(section0, t0);
      append_hydration(section0, div1);
      append_hydration(div1, b);
      append_hydration(b, t1);
      append_hydration(div1, t2);
      append_hydration(div1, div0);
      append_hydration(div0, p0);
      append_hydration(p0, t3);
      append_hydration(div0, t4);
      append_hydration(div0, p1);
      append_hydration(p1, t5);
      append_hydration(section0, t6);
      append_hydration(section0, div2);
      mount_component(editablelist, div2, null);
      append_hydration(div8, t7);
      append_hydration(div8, br1);
      append_hydration(div8, t8);
      append_hydration(div8, section1);
      append_hydration(section1, div4);
      append_hydration(div4, button0);
      append_hydration(button0, t9);
      append_hydration(div4, t10);
      append_hydration(div4, div3);
      append_hydration(div3, t11);
      append_hydration(section1, t12);
      append_hydration(section1, div6);
      append_hydration(div6, button1);
      append_hydration(button1, t13);
      append_hydration(div6, t14);
      append_hydration(div6, div5);
      append_hydration(div5, t15);
      append_hydration(div8, t16);
      append_hydration(div8, section2);
      append_hydration(section2, br2);
      append_hydration(section2, t17);
      append_hydration(section2, div7);
      append_hydration(div7, t18);
      append_hydration(div7, br3);
      append_hydration(div7, br4);
      append_hydration(div7, t19);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[7]),
          listen(button0, "keypress", ctx[4]),
          listen(button1, "click", ctx[8]),
          listen(button1, "keypress", ctx[3])
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(editablelist.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div8_transition)
            div8_transition = create_bidirectional_transition(div8, slide, {}, true);
          div8_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(editablelist.$$.fragment, local);
      if (local) {
        if (!div8_transition)
          div8_transition = create_bidirectional_transition(div8, slide, {}, false);
        div8_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      destroy_component(editablelist);
      if (detaching && div8_transition)
        div8_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2, create_if_block_1$2, create_if_block_2$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] == "")
      return 0;
    if (ctx2[1] == ctx2[0].exporter)
      return 1;
    if (ctx2[1] == ctx2[0].importer)
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
const func$1 = (e) => {
  return true;
};
const onDeSelect_handler = () => {
};
function instance$3($$self, $$props, $$invalidate) {
  class subpages {
  }
  subpages.importer = "importer";
  subpages.exporter = "exporter";
  let subpage = "";
  function enableSubPage(_subpage) {
    $$invalidate(1, subpage = _subpage);
  }
  function keypress_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => {
    enableSubPage(subpages.exporter);
  };
  const click_handler_1 = () => enableSubPage(subpages.importer);
  const click_handler_2 = () => enableSubPage("");
  const click_handler_3 = () => enableSubPage("");
  return [
    subpages,
    subpage,
    enableSubPage,
    keypress_handler_1,
    keypress_handler,
    keypress_handler_2,
    keypress_handler_3,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class SystemExporter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
  }
}
function create_if_block$1(ctx) {
  let section;
  let menu;
  let t;
  let current_block_type_index;
  let if_block;
  let section_transition;
  let current;
  menu = new Menu({
    props: {
      regularOptions: ctx[9],
      startChosen: ctx[6]
    }
  });
  menu.$on("changePage", ctx[10]);
  const if_block_creators = [create_if_block_1$1, create_if_block_2$1, create_if_block_3$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] == "designer")
      return 0;
    if (ctx2[6] == "UI-designer")
      return 1;
    if (ctx2[6] == "test")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      section = element("section");
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
    },
    l(nodes) {
      section = claim_element(nodes, "SECTION", {});
      var section_nodes = children(section);
      claim_component(menu.$$.fragment, section_nodes);
      t = claim_space(section_nodes);
      if (if_block)
        if_block.l(section_nodes);
      section_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, section, anchor);
      mount_component(menu, section, null);
      append_hydration(section, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(section, null);
      }
      ctx[12](section);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (dirty & 64)
        menu_changes.startChosen = ctx2[6];
      menu.$set(menu_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(section, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      add_render_callback(() => {
        if (!current)
          return;
        if (!section_transition)
          section_transition = create_bidirectional_transition(section, slide, {}, true);
        section_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      if (!section_transition)
        section_transition = create_bidirectional_transition(section, slide, {}, false);
      section_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(menu);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[12](null);
      if (detaching && section_transition)
        section_transition.end();
    }
  };
}
function create_if_block_3$1(ctx) {
  let div;
  let h1;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      h1 = element("h1");
      t = text("asdadsadsasdadsasdauuuuh");
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", {});
      var h1_nodes = children(h1);
      t = claim_text(h1_nodes, "asdadsadsasdadsasdauuuuh");
      h1_nodes.forEach(detach);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, h1);
      append_hydration(h1, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_2$1(ctx) {
  let div;
  let systemexporter;
  let div_transition;
  let current;
  systemexporter = new SystemExporter({});
  return {
    c() {
      div = element("div");
      create_component(systemexporter.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(systemexporter.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(systemexporter, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(systemexporter.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(systemexporter.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(systemexporter);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_1$1(ctx) {
  let div;
  let systemdesigner3parts;
  let div_transition;
  let current;
  systemdesigner3parts = new SystemDesigner3Parts({
    props: {
      system: ctx[4],
      context: ctx[0]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(systemdesigner3parts.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(systemdesigner3parts.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(systemdesigner3parts, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const systemdesigner3parts_changes = {};
      if (dirty & 16)
        systemdesigner3parts_changes.system = ctx[4];
      if (dirty & 1)
        systemdesigner3parts_changes.context = ctx[0];
      systemdesigner3parts.$set(systemdesigner3parts_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(systemdesigner3parts.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(systemdesigner3parts.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[5] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(systemdesigner3parts);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$2(ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  let div20;
  let section;
  let div18;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = (_a = ctx[3]) == null ? void 0 : _a.author) != null ? _b : unknownString) + "";
  let t2;
  let t3;
  let div5;
  let div3;
  let t4;
  let t5;
  let div4;
  let t6_value = ((_d = (_c = ctx[3]) == null ? void 0 : _c.version) != null ? _d : unknownString) + "";
  let t6;
  let t7;
  let div8;
  let div6;
  let t8;
  let t9;
  let div7;
  let t10_value = ((_f = (_e = ctx[3]) == null ? void 0 : _e.code) != null ? _f : unknownString) + "";
  let t10;
  let t11;
  let div11;
  let div9;
  let t12;
  let t13;
  let div10;
  let t14_value = ((_h = (_g = ctx[3]) == null ? void 0 : _g.isEditable) != null ? _h : unknownString) + "";
  let t14;
  let t15;
  let div14;
  let div12;
  let t16;
  let t17;
  let div13;
  let t18_value = ((_j = (_i = ctx[3]) == null ? void 0 : _i.name) != null ? _j : unknownString) + "";
  let t18;
  let t19;
  let div17;
  let div15;
  let t20;
  let t21;
  let div16;
  let t22_value = ((_l = (_k = ctx[3]) == null ? void 0 : _k.folderName) != null ? _l : unknownString) + "";
  let t22;
  let div18_transition;
  let t23;
  let br;
  let t24;
  let div19;
  let editablelist;
  let t25;
  let current;
  editablelist = new EditAbleList({
    props: {
      isEditableContainer: false,
      collection: (_n = (_m = ctx[1]) == null ? void 0 : _m.map(func)) != null ? _n : [],
      onSelect: ctx[11]
    }
  });
  editablelist.$on("onDeSelect", ctx[7]);
  let if_block = ctx[4] && ctx[3] != ctx[2] && create_if_block$1(ctx);
  return {
    c() {
      div20 = element("div");
      section = element("section");
      div18 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text("Author");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      t4 = text("Version");
      t5 = space();
      div4 = element("div");
      t6 = text(t6_value);
      t7 = space();
      div8 = element("div");
      div6 = element("div");
      t8 = text("SystemCodeName");
      t9 = space();
      div7 = element("div");
      t10 = text(t10_value);
      t11 = space();
      div11 = element("div");
      div9 = element("div");
      t12 = text("editable");
      t13 = space();
      div10 = element("div");
      t14 = text(t14_value);
      t15 = space();
      div14 = element("div");
      div12 = element("div");
      t16 = text("SystemName");
      t17 = space();
      div13 = element("div");
      t18 = text(t18_value);
      t19 = space();
      div17 = element("div");
      div15 = element("div");
      t20 = text("folder name");
      t21 = space();
      div16 = element("div");
      t22 = text(t22_value);
      t23 = space();
      br = element("br");
      t24 = space();
      div19 = element("div");
      create_component(editablelist.$$.fragment);
      t25 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div20 = claim_element(nodes, "DIV", { class: true });
      var div20_nodes = children(div20);
      section = claim_element(div20_nodes, "SECTION", {});
      var section_nodes = children(section);
      div18 = claim_element(section_nodes, "DIV", { class: true, "data-is-edit": true });
      var div18_nodes = children(div18);
      div2 = claim_element(div18_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "Author");
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      t3 = claim_space(div18_nodes);
      div5 = claim_element(div18_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div3 = claim_element(div5_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      t4 = claim_text(div3_nodes, "Version");
      div3_nodes.forEach(detach);
      t5 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      t6 = claim_text(div4_nodes, t6_value);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      t7 = claim_space(div18_nodes);
      div8 = claim_element(div18_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      div6 = claim_element(div8_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      t8 = claim_text(div6_nodes, "SystemCodeName");
      div6_nodes.forEach(detach);
      t9 = claim_space(div8_nodes);
      div7 = claim_element(div8_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      t10 = claim_text(div7_nodes, t10_value);
      div7_nodes.forEach(detach);
      div8_nodes.forEach(detach);
      t11 = claim_space(div18_nodes);
      div11 = claim_element(div18_nodes, "DIV", { class: true });
      var div11_nodes = children(div11);
      div9 = claim_element(div11_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      t12 = claim_text(div9_nodes, "editable");
      div9_nodes.forEach(detach);
      t13 = claim_space(div11_nodes);
      div10 = claim_element(div11_nodes, "DIV", { class: true });
      var div10_nodes = children(div10);
      t14 = claim_text(div10_nodes, t14_value);
      div10_nodes.forEach(detach);
      div11_nodes.forEach(detach);
      t15 = claim_space(div18_nodes);
      div14 = claim_element(div18_nodes, "DIV", { class: true });
      var div14_nodes = children(div14);
      div12 = claim_element(div14_nodes, "DIV", { class: true });
      var div12_nodes = children(div12);
      t16 = claim_text(div12_nodes, "SystemName");
      div12_nodes.forEach(detach);
      t17 = claim_space(div14_nodes);
      div13 = claim_element(div14_nodes, "DIV", { class: true });
      var div13_nodes = children(div13);
      t18 = claim_text(div13_nodes, t18_value);
      div13_nodes.forEach(detach);
      div14_nodes.forEach(detach);
      t19 = claim_space(div18_nodes);
      div17 = claim_element(div18_nodes, "DIV", { class: true });
      var div17_nodes = children(div17);
      div15 = claim_element(div17_nodes, "DIV", { class: true });
      var div15_nodes = children(div15);
      t20 = claim_text(div15_nodes, "folder name");
      div15_nodes.forEach(detach);
      t21 = claim_space(div17_nodes);
      div16 = claim_element(div17_nodes, "DIV", { class: true });
      var div16_nodes = children(div16);
      t22 = claim_text(div16_nodes, t22_value);
      div16_nodes.forEach(detach);
      div17_nodes.forEach(detach);
      div18_nodes.forEach(detach);
      t23 = claim_space(section_nodes);
      br = claim_element(section_nodes, "BR", {});
      t24 = claim_space(section_nodes);
      div19 = claim_element(section_nodes, "DIV", { class: true });
      var div19_nodes = children(div19);
      claim_component(editablelist.$$.fragment, div19_nodes);
      div19_nodes.forEach(detach);
      section_nodes.forEach(detach);
      t25 = claim_space(div20_nodes);
      if (if_block)
        if_block.l(div20_nodes);
      div20_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "tableRowColumn");
      attr(div1, "class", "tableRowColumn");
      attr(div2, "class", "tableRow");
      attr(div3, "class", "tableRowColumn");
      attr(div4, "class", "tableRowColumn");
      attr(div5, "class", "tableRow");
      attr(div6, "class", "tableRowColumn");
      attr(div7, "class", "tableRowColumn");
      attr(div8, "class", "tableRow");
      attr(div9, "class", "tableRowColumn");
      attr(div10, "class", "tableRowColumn");
      attr(div11, "class", "tableRow");
      attr(div12, "class", "tableRowColumn");
      attr(div13, "class", "tableRowColumn");
      attr(div14, "class", "tableRow");
      attr(div15, "class", "tableRowColumn");
      attr(div16, "class", "tableRowColumn");
      attr(div17, "class", "tableRow");
      attr(div18, "class", "table SystemPreviewer");
      attr(div18, "data-is-edit", false);
      attr(div19, "class", "PageSystemList");
      attr(div20, "class", "MainAppContainerPage MainAppContainerPageSystem");
    },
    m(target, anchor) {
      insert_hydration(target, div20, anchor);
      append_hydration(div20, section);
      append_hydration(section, div18);
      append_hydration(div18, div2);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
      append_hydration(div18, t3);
      append_hydration(div18, div5);
      append_hydration(div5, div3);
      append_hydration(div3, t4);
      append_hydration(div5, t5);
      append_hydration(div5, div4);
      append_hydration(div4, t6);
      append_hydration(div18, t7);
      append_hydration(div18, div8);
      append_hydration(div8, div6);
      append_hydration(div6, t8);
      append_hydration(div8, t9);
      append_hydration(div8, div7);
      append_hydration(div7, t10);
      append_hydration(div18, t11);
      append_hydration(div18, div11);
      append_hydration(div11, div9);
      append_hydration(div9, t12);
      append_hydration(div11, t13);
      append_hydration(div11, div10);
      append_hydration(div10, t14);
      append_hydration(div18, t15);
      append_hydration(div18, div14);
      append_hydration(div14, div12);
      append_hydration(div12, t16);
      append_hydration(div14, t17);
      append_hydration(div14, div13);
      append_hydration(div13, t18);
      append_hydration(div18, t19);
      append_hydration(div18, div17);
      append_hydration(div17, div15);
      append_hydration(div15, t20);
      append_hydration(div17, t21);
      append_hydration(div17, div16);
      append_hydration(div16, t22);
      append_hydration(section, t23);
      append_hydration(section, br);
      append_hydration(section, t24);
      append_hydration(section, div19);
      mount_component(editablelist, div19, null);
      append_hydration(div20, t25);
      if (if_block)
        if_block.m(div20, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2;
      if ((!current || dirty & 8) && t2_value !== (t2_value = ((_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.author) != null ? _b2 : unknownString) + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 8) && t6_value !== (t6_value = ((_d2 = (_c2 = ctx2[3]) == null ? void 0 : _c2.version) != null ? _d2 : unknownString) + ""))
        set_data(t6, t6_value);
      if ((!current || dirty & 8) && t10_value !== (t10_value = ((_f2 = (_e2 = ctx2[3]) == null ? void 0 : _e2.code) != null ? _f2 : unknownString) + ""))
        set_data(t10, t10_value);
      if ((!current || dirty & 8) && t14_value !== (t14_value = ((_h2 = (_g2 = ctx2[3]) == null ? void 0 : _g2.isEditable) != null ? _h2 : unknownString) + ""))
        set_data(t14, t14_value);
      if ((!current || dirty & 8) && t18_value !== (t18_value = ((_j2 = (_i2 = ctx2[3]) == null ? void 0 : _i2.name) != null ? _j2 : unknownString) + ""))
        set_data(t18, t18_value);
      if ((!current || dirty & 8) && t22_value !== (t22_value = ((_l2 = (_k2 = ctx2[3]) == null ? void 0 : _k2.folderName) != null ? _l2 : unknownString) + ""))
        set_data(t22, t22_value);
      const editablelist_changes = {};
      if (dirty & 2)
        editablelist_changes.collection = (_n2 = (_m2 = ctx2[1]) == null ? void 0 : _m2.map(func)) != null ? _n2 : [];
      editablelist.$set(editablelist_changes);
      if (ctx2[4] && ctx2[3] != ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 28) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div20, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!div18_transition)
          div18_transition = create_bidirectional_transition(div18, fade, {}, true);
        div18_transition.run(1);
      });
      transition_in(editablelist.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      if (!div18_transition)
        div18_transition = create_bidirectional_transition(div18, fade, {}, false);
      div18_transition.run(0);
      transition_out(editablelist.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div20);
      if (detaching && div18_transition)
        div18_transition.end();
      destroy_component(editablelist);
      if (if_block)
        if_block.d();
    }
  };
}
let unknownString = "unknown";
const func = (p) => {
  return { key: p.code, value: p.name };
};
function instance$2($$self, $$props, $$invalidate) {
  let { context } = $$props;
  context.activeSystem;
  let availSystems = [];
  const nullpreview = new SystemPreview();
  let activePreview = nullpreview;
  let factory = null;
  onMount(() => {
    var _a;
    $$invalidate(1, availSystems = (_a = context.availablePreviews) !== null && _a !== void 0 ? _a : []);
    loadAllSystems();
  });
  function loadAllSystems() {
    return __awaiter(this, void 0, void 0, function* () {
      let response = yield context.API.getAllSystems();
      $$invalidate(0, context.availablePreviews = response.response, context);
      $$invalidate(1, availSystems = response.response);
    });
  }
  function unloadPreview() {
    $$invalidate(3, activePreview = nullpreview);
    $$invalidate(4, factory = null);
  }
  function onSelectSystem(d) {
    return __awaiter(this, void 0, void 0, function* () {
      const pre = availSystems.find((p) => p.code == d);
      if (activePreview == pre || !pre) {
        $$invalidate(3, activePreview = nullpreview);
        return false;
      }
      $$invalidate(3, activePreview = pre);
      let response = yield context.API.getFactory(activePreview);
      $$invalidate(4, factory = response.response);
      return true;
    });
  }
  let pagesContainer;
  let editPages = ["designer", "UI-designer"];
  let activeSubPage = "designer";
  function changePage(event) {
    $$invalidate(6, activeSubPage = event.detail);
  }
  nullpreview.isEditable = null;
  const func_1 = (e) => {
    onSelectSystem(e);
    return true;
  };
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pagesContainer = $$value;
      $$invalidate(5, pagesContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
  };
  return [
    context,
    availSystems,
    nullpreview,
    activePreview,
    factory,
    pagesContainer,
    activeSubPage,
    unloadPreview,
    onSelectSystem,
    editPages,
    changePage,
    func_1,
    section_binding
  ];
}
class SystemPage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { context: 0 });
  }
}
const Designer_svelte_svelte_type_style_lang = "";
function add_css(target) {
  append_styles(target, "svelte-q6h4ep", "#MainAppContainer.svelte-q6h4ep{container-type:inline-size;min-height:inherit}");
}
function create_if_block_4(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text("1");
    },
    l(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "1");
      p_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_3(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text("1");
    },
    l(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "1");
      p_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_2(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text("1");
    },
    l(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "1");
      p_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let systempage;
  let div_transition;
  let current;
  systempage = new SystemPage({ props: { context: ctx[0] } });
  return {
    c() {
      div = element("div");
      create_component(systempage.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(systempage.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(systempage, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const systempage_changes = {};
      if (dirty & 1)
        systempage_changes.context = ctx[0];
      systempage.$set(systempage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(systempage.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[2] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(systempage.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[2] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(systempage);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block(ctx) {
  let div;
  let homepage;
  let div_transition;
  let current;
  homepage = new HomePage({});
  return {
    c() {
      div = element("div");
      create_component(homepage.$$.fragment);
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(homepage.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(homepage, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(homepage.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[2] }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(homepage.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, pageSlide, { parent: ctx[2] }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(homepage);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment$1(ctx) {
  let div;
  let menu;
  let t;
  let section;
  let current_block_type_index;
  let if_block;
  let current;
  menu = new Menu({
    props: {
      title: "TTP-RPG System Designer",
      regularOptions: ["home", "system", "data tables", "export", "import"],
      startChosen: ctx[3]
    }
  });
  menu.$on("changePage", ctx[5]);
  const if_block_creators = [
    create_if_block,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] == "home")
      return 0;
    if (ctx2[3] == "system")
      return 1;
    if (ctx2[3] == "home1")
      return 2;
    if (ctx2[3] == "home2")
      return 3;
    if (ctx2[3] == "home3")
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      create_component(menu.$$.fragment);
      t = space();
      section = element("section");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      claim_component(menu.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      section = claim_element(div_nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (if_block)
        if_block.l(section_nodes);
      section_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(section, "class", "MainAppContainerPages");
      attr(div, "id", "MainAppContainer");
      attr(div, "class", "svelte-q6h4ep");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(menu, div, null);
      append_hydration(div, t);
      append_hydration(div, section);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(section, null);
      }
      ctx[6](section);
      ctx[7](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.startChosen = ctx2[3];
      menu.$set(menu_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(section, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[6](null);
      ctx[7](null);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $page;
  let page = writable("system");
  component_subscribe($$self, page, (value2) => $$invalidate(3, $page = value2));
  let { context } = $$props;
  let mainAppContainer;
  function changePage(event) {
    page.set(event.detail);
  }
  onMount(() => {
    $$invalidate(0, context.mainAppContainer = mainAppContainer, context);
  });
  let pagesContainer;
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pagesContainer = $$value;
      $$invalidate(2, pagesContainer);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      mainAppContainer = $$value;
      $$invalidate(1, mainAppContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
  };
  return [
    context,
    mainAppContainer,
    pagesContainer,
    $page,
    page,
    changePage,
    section_binding,
    div_binding
  ];
}
class Designer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { context: 0 }, add_css);
  }
}
var E_CANCELED = new Error("request for lock canceled");
var Semaphore = function() {
  function Semaphore2(_value, _cancelError) {
    if (_cancelError === void 0) {
      _cancelError = E_CANCELED;
    }
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  Semaphore2.prototype.acquire = function(weight, priority) {
    var _this = this;
    if (weight === void 0) {
      weight = 1;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (weight <= 0)
      throw new Error("invalid weight ".concat(weight, ": must be positive"));
    return new Promise(function(resolve, reject) {
      var task = { resolve, reject, weight, priority };
      var i = findIndexFromEnd(_this._queue, function(other) {
        return priority <= other.priority;
      });
      if (i === -1 && weight <= _this._value) {
        _this._dispatchItem(task);
      } else {
        _this._queue.splice(i + 1, 0, task);
      }
    });
  };
  Semaphore2.prototype.runExclusive = function(callback_1) {
    return __awaiter(this, arguments, void 0, function(callback, weight, priority) {
      var _a, value2, release;
      if (weight === void 0) {
        weight = 1;
      }
      if (priority === void 0) {
        priority = 0;
      }
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this.acquire(weight, priority)];
          case 1:
            _a = _b.sent(), value2 = _a[0], release = _a[1];
            _b.label = 2;
          case 2:
            _b.trys.push([2, , 4, 5]);
            return [4, callback(value2)];
          case 3:
            return [2, _b.sent()];
          case 4:
            release();
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Semaphore2.prototype.waitForUnlock = function(weight, priority) {
    var _this = this;
    if (weight === void 0) {
      weight = 1;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (weight <= 0)
      throw new Error("invalid weight ".concat(weight, ": must be positive"));
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise(function(resolve) {
        if (!_this._weightedWaiters[weight - 1])
          _this._weightedWaiters[weight - 1] = [];
        insertSorted(_this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  };
  Semaphore2.prototype.isLocked = function() {
    return this._value <= 0;
  };
  Semaphore2.prototype.getValue = function() {
    return this._value;
  };
  Semaphore2.prototype.setValue = function(value2) {
    this._value = value2;
    this._dispatchQueue();
  };
  Semaphore2.prototype.release = function(weight) {
    if (weight === void 0) {
      weight = 1;
    }
    if (weight <= 0)
      throw new Error("invalid weight ".concat(weight, ": must be positive"));
    this._value += weight;
    this._dispatchQueue();
  };
  Semaphore2.prototype.cancel = function() {
    var _this = this;
    this._queue.forEach(function(entry) {
      return entry.reject(_this._cancelError);
    });
    this._queue = [];
  };
  Semaphore2.prototype._dispatchQueue = function() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  };
  Semaphore2.prototype._dispatchItem = function(item) {
    var previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  };
  Semaphore2.prototype._newReleaser = function(weight) {
    var _this = this;
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      _this.release(weight);
    };
  };
  Semaphore2.prototype._drainUnlockWaiters = function() {
    if (this._queue.length === 0) {
      for (var weight = this._value; weight > 0; weight--) {
        var waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach(function(waiter) {
          return waiter.resolve();
        });
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      var queuedPriority_1 = this._queue[0].priority;
      for (var weight = this._value; weight > 0; weight--) {
        var waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        var i = waiters.findIndex(function(waiter) {
          return waiter.priority <= queuedPriority_1;
        });
        (i === -1 ? waiters : waiters.splice(0, i)).forEach(function(waiter) {
          return waiter.resolve();
        });
      }
    }
  };
  Semaphore2.prototype._couldLockImmediately = function(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  };
  return Semaphore2;
}();
function insertSorted(a, v) {
  var i = findIndexFromEnd(a, function(other) {
    return v.priority <= other.priority;
  });
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (var i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var Mutex = function() {
  function Mutex2(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  Mutex2.prototype.acquire = function() {
    return __awaiter(this, arguments, void 0, function(priority) {
      var _a, releaser;
      if (priority === void 0) {
        priority = 0;
      }
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this._semaphore.acquire(1, priority)];
          case 1:
            _a = _b.sent(), releaser = _a[1];
            return [2, releaser];
        }
      });
    });
  };
  Mutex2.prototype.runExclusive = function(callback, priority) {
    if (priority === void 0) {
      priority = 0;
    }
    return this._semaphore.runExclusive(function() {
      return callback();
    }, 1, priority);
  };
  Mutex2.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  };
  Mutex2.prototype.waitForUnlock = function(priority) {
    if (priority === void 0) {
      priority = 0;
    }
    return this._semaphore.waitForUnlock(1, priority);
  };
  Mutex2.prototype.release = function() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  };
  Mutex2.prototype.cancel = function() {
    return this._semaphore.cancel();
  };
  return Mutex2;
}();
const _FileHandler = class {
  constructor() {
    if (_FileHandler._instance == null) {
      _FileHandler._instance = new _FileHandler();
    }
    return _FileHandler._instance;
  }
  static async mkdir(path) {
    return await PluginHandler.App.vault.adapter.mkdir(path);
  }
  static async rmdir(path) {
    return await PluginHandler.App.vault.adapter.rmdir(path, true);
  }
  static async lsdir(path) {
    return await PluginHandler.App.vault.adapter.list(path);
  }
  static async exists(path) {
    return await PluginHandler.App.vault.adapter.exists(path, false);
  }
  static async saveFile(path, fileContent) {
    return await PluginHandler.App.vault.adapter.write(path, fileContent);
  }
  static async readFile(path) {
    return await PluginHandler.App.vault.adapter.read(path);
  }
  static async rm(path) {
    return await PluginHandler.App.vault.adapter.remove(path);
  }
  static async copy(path, newPath) {
    return await PluginHandler.App.vault.adapter.copy(path, newPath);
  }
};
let FileHandler = _FileHandler;
__publicField(FileHandler, "_instance");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class UILayoutModelSchemes {
}
__publicField(UILayoutModelSchemes, "BASE", BASE_SCHEME);
__publicField(UILayoutModelSchemes, "PAGE", "PAGE");
class UILayoutModel {
  constructor() {
    __publicField(this, "id", distExports.keyManagerInstance.getNewKey());
    __publicField(this, "guid", PluginHandler.uuidv4());
    __publicField(this, "author");
    __publicField(this, "version");
    __publicField(this, "name");
    __publicField(this, "mainStyle");
    __publicField(this, "componentJs");
    __publicField(this, "folderSrc");
    __publicField(this, "valid", true);
    __publicField(this, "errors", []);
  }
  async isValid() {
    let errors = [];
    if (!this.folderSrc) {
      errors.push(`UILayoutModel for ${this.name} by ${this.author}, did not have a folderSrc`);
      return;
    }
    let valid = true;
    let src = this.folderSrc + "/" + this.componentJs;
    let _ = await FileHandler.exists(src);
    if (!_) {
      errors.push(`UILayoutModel for ${this.name} by ${this.author}, Pointed to a missing file ${src}`);
      valid = false;
    }
    src = this.folderSrc + "/" + this.mainStyle;
    _ = await FileHandler.exists(src);
    if (!_) {
      errors.push(`UILayoutModel for ${this.name} by ${this.author}, Pointed to a missing file ${src}`);
      valid = false;
    }
    this.valid = valid;
    return valid;
  }
  async loadfile(file, errors = []) {
    const src = this.folderSrc + "/" + file;
    let _ = await FileHandler.exists(src);
    if (!_) {
      errors.push(`file at ${src} did not exists`);
      return null;
    }
    let f = await FileHandler.readFile(src);
    return f;
  }
}
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE, UILayoutModelSchemes.PAGE] })
], UILayoutModel.prototype, "guid", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE] })
], UILayoutModel.prototype, "author", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE] })
], UILayoutModel.prototype, "version", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE, UILayoutModelSchemes.PAGE] })
], UILayoutModel.prototype, "name", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE] })
], UILayoutModel.prototype, "mainStyle", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE] })
], UILayoutModel.prototype, "componentJs", 2);
__decorateClass([
  JsonString({ scheme: [UILayoutModelSchemes.BASE] })
], UILayoutModel.prototype, "folderSrc", 2);
const _FileContext = class {
  constructor(pluginHandler) {
    __publicField(this, "path");
    __publicField(this, "pluginHandler");
    __publicField(this, "loadedSystem");
    __publicField(this, "foldersWithNoIndex");
    __publicField(this, "availableSystems");
    if (!this.pluginHandler && !pluginHandler) {
      console.error("First get instance of FileContext, must include a plugin handler");
    }
    this.pluginHandler = pluginHandler;
    this.path = PluginHandler.PLUGIN_ROOT + "/" + PluginHandler.SYSTEMS_FOLDER_NAME;
  }
  static getInstance(pluginHandler) {
    if (!_FileContext.instance) {
      _FileContext.instance = new _FileContext(pluginHandler);
    }
    return _FileContext.instance;
  }
  async initSystemsStructure() {
    if (await FileHandler.exists(this.path))
      return;
    FileHandler.mkdir(this.path);
  }
  async loadPreviewAndfolder(folderPath) {
    const indexPath = folderPath + "/index.json";
    const folderName = folderPath.split("/").last();
    let exists = await FileHandler.exists(indexPath);
    if (exists) {
      const content = await FileHandler.readFile(indexPath);
      const systemPreview = JSONHandler.deserialize(SystemPreview, content);
      systemPreview.folderName = folderName;
      systemPreview.folderPath = folderPath;
      systemPreview.filePath = indexPath;
      return [systemPreview, folderName];
    }
    return [null, folderName];
  }
  async loadPreview(folderPath) {
    return (await this.loadPreviewAndfolder(folderPath))[0];
  }
  static async loadAllAvailableFiles() {
    let instance2 = _FileContext.getInstance();
    return instance2.loadAllAvailableFiles();
  }
  async loadAllAvailableFiles(messages = {}) {
    let release = await _FileContext.mutex.acquire();
    let lsDir = await FileHandler.lsdir(this.path);
    let systems = await Promise.all(lsDir.folders.map(async (folderPath) => {
      return await this.loadPreviewAndfolder(folderPath);
    }));
    this.foldersWithNoIndex = [];
    this.availableSystems = [];
    systems.forEach((p) => {
      if (p[0]) {
        this.availableSystems.push(p[0]);
      } else {
        this.foldersWithNoIndex.push(p[1]);
      }
    });
    release();
  }
  static async createSystemDefinition(system, messages = {}) {
    let instance2 = _FileContext.getInstance();
    return instance2.createSystemDefinition(system, messages);
  }
  async createSystemDefinition(system, messages = {}) {
    let release = await _FileContext.mutex.acquire();
    this.initSystemsStructure();
    let folderPath = this.path + "/" + system.folderName;
    if (!await FileHandler.exists(folderPath)) {
      await FileHandler.mkdir(folderPath);
    } else {
      if (await FileHandler.exists(folderPath + "/index.json")) {
        messages["createSystem"] = { msg: `folder '${system.folderName}' already existed, and contained a system. 
Either delete the old system, or choose another foldername`, type: "error" };
        release();
        return null;
      }
    }
    let filepath = folderPath + "/index.json";
    await FileHandler.saveFile(filepath, JSONHandler.serialize(system));
    if (!await FileHandler.exists(filepath)) {
      messages["createSystem"] = { msg: `tried to save index.json at '${filepath} 
 but something went wrong.`, type: "error" };
      release();
      return null;
    }
    let systemReloaded = await this.loadPreview(folderPath);
    release();
    return systemReloaded;
  }
  static async copySystemDefinition(system, systemNew, messages = {}) {
    let instance2 = _FileContext.getInstance();
    return instance2.copySystemDefinition(system, systemNew, messages);
  }
  async copySystemDefinition(system, systemNew, messages = {}) {
    let copiedSystem = await this.createSystemDefinition(systemNew, messages);
    if (!copiedSystem) {
      return null;
    }
    async function DFSCopyAllFolders(path, newPath) {
      let ls = await FileHandler.lsdir(path);
      await Promise.all(ls.folders.map(async (folderPath) => {
        let foldername = folderPath.split("/").last();
        let newFolderPath = newPath + "/" + foldername;
        FileHandler.mkdir(newFolderPath);
        await DFSCopyAllFolders(folderPath, newFolderPath);
      }));
    }
    async function BFSCopyAllFiles(path, newPath) {
      let ls = await FileHandler.lsdir(path);
      await Promise.all(ls.files.map(async (filePath) => {
        let file = await FileHandler.readFile(filePath);
        let fileName = filePath.split("/").last();
        await FileHandler.saveFile(newPath + "/" + fileName, file);
      }));
      await Promise.all(ls.folders.map(async (folderPath) => {
        let segmentsPath = folderPath.split("/");
        let foldername = segmentsPath.pop();
        let newFolderPath = newPath + "/" + foldername;
        await BFSCopyAllFiles(folderPath, newFolderPath);
      }));
    }
    await DFSCopyAllFolders(system.folderPath, copiedSystem.folderPath);
    await BFSCopyAllFiles(system.folderPath, copiedSystem.folderPath);
    await FileHandler.saveFile(copiedSystem.filePath, JSONHandler.serialize(copiedSystem));
    return copiedSystem;
  }
  static async systemDefinitionExistsInFolder(folder2) {
    let instance2 = _FileContext.getInstance();
    return instance2.systemDefinitionExistsInFolder(folder2);
  }
  async systemDefinitionExistsInFolder(folder2) {
    let folderPath = this.path + "/" + folder2;
    if (!await FileHandler.exists(folderPath)) {
      return false;
    } else {
      if (await FileHandler.exists(folderPath + "/index.json")) {
        return true;
      }
    }
    return false;
  }
  static async getOrCreateSystemsDesigns(folder2) {
    return _FileContext.getInstance().systemDefinitionExistsInFolder(folder2);
  }
  async getOrCreateSystemsDesigns(folder2) {
    if (!await FileHandler.exists(folder2)) {
      return null;
    }
    if (!await FileHandler.exists(folder2)) {
      return null;
    }
    let filepath = folder2 + "/designer.json";
    if (!await FileHandler.exists(filepath)) {
      let designer = new TTRPGSystemJSONFormatting();
      designer.initAsNew();
      await FileHandler.saveFile(filepath, JSONHandler.serialize(designer));
      return designer;
    }
    let file = await FileHandler.readFile(filepath);
    let loaded = JSONHandler.deserialize(TTRPGSystemJSONFormatting, file);
    return loaded;
  }
  async saveSystemsDesigns(folder2, designer) {
    if (!await FileHandler.exists(folder2)) {
      return null;
    }
    if (!await FileHandler.exists(folder2)) {
      return null;
    }
    let filepath = folder2 + "/designer.json";
    await FileHandler.saveFile(filepath, JSONHandler.serialize(designer));
    return true;
  }
  async loadFolderAndFilesRecursice(folderPath) {
    let c = [];
    const content = await FileHandler.lsdir(folderPath);
    let map = await Promise.all(content.files.map(async (f) => {
      return await this.loadFileAndCreateCommand(f);
    }));
    map.forEach((p) => {
      c.push(p);
    });
    let map2 = await Promise.all(content.folders.map(async (f) => {
      return await this.loadFolderAndFilesRecursice(f);
    }));
    map2.forEach((p) => {
      p.forEach((q) => {
        c.push(q);
      });
    });
    return c;
  }
  async loadFileAndCreateCommand(filepath) {
    let data = await FileHandler.readFile(filepath);
    return {
      command: "file",
      path: filepath,
      content: data
    };
  }
  async loadBlockUITemplate() {
    const path = PluginHandler.PLUGIN_ROOT + "/" + PluginHandler.BUILTIN_UIS_FOLDER_NAME + "/";
    let commands = [];
    let exists = await FileHandler.exists(path);
    if (!exists) {
      throw new Error("File for BlockUI have been deleted. this feature longer works as a result");
    }
    const content = await FileHandler.lsdir(path);
    let map = await Promise.all(content.files.map(async (f) => {
      return await this.loadFileAndCreateCommand(f);
    }));
    map.forEach((p) => {
      var _a;
      if (!p.path.endsWith("/declaration.ts")) {
        let n = (_a = p.path.split("BlockUIDev/").last()) != null ? _a : "";
        p.path = "src/" + n;
        commands.push(p);
      }
    });
    let pathsrc = path + "/src/";
    let map2 = await this.loadFolderAndFilesRecursice(pathsrc);
    map2.forEach((p) => {
      var _a;
      let n = (_a = p.path.split("BlockUIDev/").last()) != null ? _a : "";
      p.path = n;
      if (n != "/src/") {
        commands.push(p);
      }
    });
    return commands;
  }
  async loadUILayout(foldersrc, errors = []) {
    const src = foldersrc + "/" + PluginHandler.SYSTEM_UI_LAYOUTFILENAME;
    const exists = await FileHandler.exists(src);
    if (!exists)
      return null;
    const file = await FileHandler.readFile(src);
    let model;
    try {
      model = JSONHandler.deserialize(UILayoutModel, file);
    } catch (e) {
      errors.push(e.message);
      return null;
    }
    model.folderSrc = foldersrc;
    await model.isValid();
    return model;
  }
  async getAllBlockUIAvailablePreview(sys) {
    const UIFolderpath = sys.folderPath + "/" + PluginHandler.SYSTEM_UI_CONTAINER_FOLDER_NAME;
    const exists = await FileHandler.exists(UIFolderpath);
    let layouts = [];
    if (exists) {
      let folders = (await FileHandler.lsdir(UIFolderpath)).folders;
      for (let i = 0; i < folders.length; i++) {
        const folder2 = folders[i];
        let layout = await this.loadUILayout(folder2);
        if (layout)
          layouts.push(layout);
      }
    }
    return layouts;
  }
};
let FileContext = _FileContext;
__publicField(FileContext, "mutex", new Mutex());
__publicField(FileContext, "instance");
class ObsidianAPI {
  constructor(pluginHandler) {
    __publicField(this, "pluginHandler");
    this.pluginHandler = pluginHandler;
  }
  getSystemUIs(preview) {
    throw new Error("Method not implemented.");
  }
  getFactory(preview) {
    throw new Error("Method not implemented.");
  }
  async getAllSystems() {
    var _a;
    let messages = [];
    try {
      let fileContext = FileContext.getInstance(this.pluginHandler);
      await fileContext.loadAllAvailableFiles(messages);
      let previews = (_a = fileContext.availableSystems) != null ? _a : [];
      let response = {
        responseCode: 200,
        messages: [],
        response: previews
      };
      return response;
    } catch (e) {
      messages["exception"] = { msg: e.message, type: "error" };
      let response = {
        responseCode: 300,
        messages: ["could not load system previews"],
        response: []
      };
      return response;
    }
  }
}
function create_fragment(ctx) {
  let div;
  let designer;
  let current;
  designer = new Designer({ props: { context: ctx[0] } });
  return {
    c() {
      div = element("div");
      create_component(designer.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      claim_component(designer.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "id", "SvelteContainerForTTPRPGSystem");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(designer, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const designer_changes = {};
      if (dirty & 1)
        designer_changes.context = ctx2[0];
      designer.$set(designer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(designer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(designer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(designer);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { pluginHandler } = $$props;
  let context = new Layout01Context();
  let API = new ObsidianAPI(pluginHandler);
  context.API = API;
  $$self.$$set = ($$props2) => {
    if ("pluginHandler" in $$props2)
      $$invalidate(1, pluginHandler = $$props2.pluginHandler);
  };
  return [context, pluginHandler];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { pluginHandler: 1 });
  }
}
const VIEW_TYPE = "svelte-view";
const DEFAULT_SETTINGS = {
  mySetting: "default"
};
const _PluginHandler = class extends obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  async onload() {
    await this.loadSettings();
    _PluginHandler.self = this;
    _PluginHandler.App = this.app;
    _PluginHandler.ROOT = _PluginHandler.App.vault.configDir;
    _PluginHandler.PLUGIN_ROOT = this.manifest.dir;
    _PluginHandler.SYSTEMS_FOLDER_NAME = "Systems";
    _PluginHandler.BUILTIN_UIS_FOLDER_NAME = "subProjects/BlockUIDev";
    _PluginHandler.SYSTEM_UI_CONTAINER_FOLDER_NAME = "UILayouts";
    _PluginHandler.SYSTEM_UI_LAYOUTFILENAME = "UIPreview.json";
    _PluginHandler.GLOBAL_SYSTEM_PASSER = "GrobaxTTRPGGlobalVariable";
    _PluginHandler.SYSTEM_LAYOUT_BLOCKNAME = "TTRPG";
    this.addRibbonIcon("dice", "Hanss' Plugin", (evt) => {
      new ModalMount(this.app, this).open();
    });
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor(_PluginHandler.SYSTEM_LAYOUT_BLOCKNAME, (source, el, ctx) => {
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf) {
          window[_PluginHandler.GLOBAL_SYSTEM_PASSER] = {};
        }
      })
    );
  }
  onLayoutReady() {
    var _a;
    if (this.app.workspace.getLeavesOfType(VIEW_TYPE).length) {
      return;
    }
    (_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
      type: VIEW_TYPE
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
};
let PluginHandler = _PluginHandler;
__publicField(PluginHandler, "App");
__publicField(PluginHandler, "ROOT");
__publicField(PluginHandler, "PLUGIN_ROOT");
__publicField(PluginHandler, "SYSTEMS_FOLDER_NAME");
__publicField(PluginHandler, "BUILTIN_UIS_FOLDER_NAME");
__publicField(PluginHandler, "SYSTEM_UI_CONTAINER_FOLDER_NAME");
__publicField(PluginHandler, "SYSTEM_UI_LAYOUTFILENAME");
__publicField(PluginHandler, "SYSTEM_LAYOUT_BLOCKNAME");
__publicField(PluginHandler, "GLOBAL_SYSTEM_PASSER");
__publicField(PluginHandler, "self");
class SampleSettingTab extends obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new App({
      target: this.containerEl,
      props: {
        plugin: this.plugin
      }
    });
  }
}
class ModalMount extends obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  onOpen() {
    new App({
      target: this.contentEl,
      props: {
        plugin: this.plugin
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}
module.exports = PluginHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9lYXNpbmcvaW5kZXgubWpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvc3ZlbHRlL3RyYW5zaXRpb24vaW5kZXgubWpzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9WaWV3cy9MYXlvdXQwMS9WaWV3cy9QYWdlL0hvbWVQYWdlLnN2ZWx0ZSIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9idXR0b25zL3BsdXMuc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL2VkaXRBYmxlTGlzdC9FZGl0QWJsZUxpc3Quc3ZlbHRlIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvc3ZlbHRlL3N0b3JlL2luZGV4Lm1qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9hbmltYXRlL2luZGV4Lm1qcyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9NZXNzYWdlcy9TdGF0aWNNZXNzYWdlSGFuZGxlci5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL2NvbnRleHQudHMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy90dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9BYnN0cmFjdGlvbnMvS2V5TWFuYWdlci5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L0Fic3RyYWN0aW9ucy9JT3V0cHV0SGFuZGxlci5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L0Fic3RyYWN0aW9ucy9BR3JhcGhJdGVtLmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvdHRycGctc3lzdGVtLWdyYXBoL2Rpc3QvR3JvYkNvbGxlY3Rpb24uanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy90dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9Hcm9iR3JvdXAuanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy90dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9HcmFwaC9UVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbC5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L0dyYXBoL1RUUlBHU3lzdGVtR3JhcGhNb2RlbC5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L05vZGVzL2FsZ29yaXRobS9UYXJqYW5Ob2RlLmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvdHRycGctc3lzdGVtLWdyYXBoL2Rpc3QvTm9kZXMvQUdyb2JOb2R0ZS5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L0dyYXBoL1RUUlBHU3lzdGVtc0dyYXBoRGVwZW5kZW5jaWVzLmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvdHRycGctc3lzdGVtLWdyYXBoL2Rpc3QvTm9kZXMvR3JvYk9yaWdpbi5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L05vZGVzL0dyb2JEZXJpdmVkTm9kZS5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L05vZGVzL0dyb2JCb251c05vZGUuanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy90dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9IZWxwZXJzL1RUUlBHU3lzdGVtQm9udXNEZXNpZ25lci5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL3R0cnBnLXN5c3RlbS1ncmFwaC9kaXN0L05vZGVzL0dyb2JGaXhlZE5vZGUuanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy90dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9UYWJsZXMvRGF0YVRhYmxlLmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvdHRycGctc3lzdGVtLWdyYXBoL2Rpc3QvaW5kZXguanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy9ncm9iYXgtanNvbi1oYW5kbGVyL2Rpc3QvSnNvbk1vZHVsZUNvbnN0YW50cy5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL2dyb2JheC1qc29uLWhhbmRsZXIvZGlzdC9SZWZsZWN0LmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvZ3JvYmF4LWpzb24taGFuZGxlci9kaXN0L0pzb25Nb2R1bGVCYXNlRnVuY3Rpb24uanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy9ncm9iYXgtanNvbi1oYW5kbGVyL2Rpc3QvRGVjb3JhdG9ycy5qcyIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL2dyb2JheC1qc29uLWhhbmRsZXIvZGlzdC9Kc29uSGFuZGxlci5qcyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9pbmRleC50cyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvY29yZS9tb2RlbC9zeXN0ZW1QcmV2aWV3LnRzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9WaWV3cy9MYXlvdXQwMS9WaWV3cy9NZW51L01lbnVCdG4uc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9WaWV3cy9MYXlvdXQwMS9WaWV3cy9NZW51L01lbnUuc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL1RyYW5zaXRpb25zL3BhZ2VTbGlkZS5qcyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvVmlld3MvTGF5b3V0MDEvVmlld3MvUGFnZS9TeXN0ZW1QYWdlL1N5c3RlbURlc2lnbmVyL0l0ZW1Db250cm9sbGVycy50cyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvY29yZS9CYXNlRnVuY3Rpb25zL3N0cmluZ2Z1bmN0aW9ucy50cyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9VSUNvbXBvc2l0aW9uL1ZhcmlvdXMudHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSU5vZGUudHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSUNvbGxlY3Rpb24udHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSUdyb3VwLnRzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyL1VJQ29tcG9zaXRpb24vVUlTeXN0ZW0udHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL1ZpZXdzL1BhZ2UvU3lzdGVtUGFnZS9TeXN0ZW1EZXNpZ25lci9GaXhlZEl0ZW1EZXNpZ25lci5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvQ3VzdG9tU2VsZWN0L3NlbGVjdFNsaWRlLmpzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL0N1c3RvbVNlbGVjdC9DdXN0b21TZWxlY3Quc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL2J1dHRvbnMvdHJhc2guc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9WaWV3cy9MYXlvdXQwMS9WaWV3cy9PcmlnaW5Sb3cvT3JpZ2luUm93LnN2ZWx0ZSIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvVmlld3MvTGF5b3V0MDEvVmlld3MvUGFnZS9TeXN0ZW1QYWdlL1N5c3RlbURlc2lnbmVyL0Rlcml2ZWRJdGVtRGVzaWduZXIuc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9WaWV3cy9MYXlvdXQwMS9WaWV3cy9QYWdlL1N5c3RlbVBhZ2UvU3lzdGVtRGVzaWduZXIvRGVyaXZlZENvbGxlY3Rpb25EZXNpZ25lckNvbnRyb2xsZXIudHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvdG9vZ2xlU2VjdGlvbi90b29nbGVTZWN0aW9uLnN2ZWx0ZSIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvVmlld3MvTGF5b3V0MDEvVmlld3MvUGFnZS9TeXN0ZW1QYWdlL1N5c3RlbURlc2lnbmVyL0Rlcml2ZWRDb2xsZWN0aW9uRGVzaWduZXIuc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL2J1dHRvbnMvbWludXMuc3ZlbHRlIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL2J1dHRvbnMvZWRpdC5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvYnV0dG9ucy9kb3dubG9hZC5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvTWVzc2FnZXMvdG9vbFRpcC5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvTWVzc2FnZXMvdG9vbFRpcC5qcyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9lZGl0QWJsZUxpc3QvRWRpdEFibGVMaXN0Um93LnN2ZWx0ZSIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9lZGl0QWJsZUxpc3QvRWRpdEFibGVMaXN0Mi5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL1ZpZXdzL1BhZ2UvU3lzdGVtUGFnZS9TeXN0ZW1EZXNpZ25lci9TeXN0ZW1EZXNpZ25lcjNQYXJ0cy5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL1ZpZXdzL1BhZ2UvU3lzdGVtUGFnZS9TeXN0ZW1FeHBvcnRlci9TeXN0ZW1FeHBvcnRlci5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL1ZpZXdzL1BhZ2UvU3lzdGVtUGFnZS5zdmVsdGUiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL3VpL1ZpZXdzL0xheW91dDAxL0Rlc2lnbmVyLnN2ZWx0ZSIsIlRTRnJvbnRFbmQvbm9kZV9tb2R1bGVzL2FzeW5jLW11dGV4L2VzNi9lcnJvcnMuanMiLCJUU0Zyb250RW5kL25vZGVfbW9kdWxlcy9hc3luYy1tdXRleC9lczYvU2VtYXBob3JlLmpzIiwiVFNGcm9udEVuZC9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvZXM2L011dGV4LmpzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy9jb3JlL2ZpbGVIYW5kbGVyLnRzIiwiVFNGcm9udEVuZC9zcmMvTW9kdWxlcy9jb3JlL21vZGVsL1VJTGF5b3V0TW9kZWwudHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL2NvcmUvZmlsZUNvbnRleHQudHMiLCJUU0Zyb250RW5kL3NyYy9Nb2R1bGVzL2FwaS9PYnNpZGlhbkFQSS50cyIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWktb2JzaWRpYW4vYXBwLnN2ZWx0ZSIsIlRTRnJvbnRFbmQvc3JjL01vZHVsZXMvdWktb2JzaWRpYW4vYXBwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcbiAgICBjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuICAgIHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbdmFsdWUsICdweCddO1xufVxuY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuY2xhc3MgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9nZXRPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0T2JzZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX29ic2VydmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX2xpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0ICYmIGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuICAgIE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEodGFnKSB7XG4gICAgcmV0dXJuICgvLS8udGVzdCh0YWcpKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcbiAgICBsZXQgX2lucHV0cztcbiAgICByZXR1cm4ge1xuICAgICAgICAvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG4gICAgICAgICAgICBfaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IGdyb3VwLnB1c2goaW5wdXQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogcmVtb3ZlICovIHIoKSB7XG4gICAgICAgICAgICBfaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gZ3JvdXAuc3BsaWNlKGdyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMoZ3JvdXAsIGluZGV4ZXMpIHtcbiAgICBsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuICAgIGxldCBfaW5wdXRzO1xuICAgIGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IF9ncm91cC5wdXNoKGlucHV0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8qIHVwZGF0ZSAqLyB1KG5ld19pbmRleGVzKSB7XG4gICAgICAgICAgICBpbmRleGVzID0gbmV3X2luZGV4ZXM7XG4gICAgICAgICAgICBjb25zdCBuZXdfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG4gICAgICAgICAgICBpZiAobmV3X2dyb3VwICE9PSBfZ3JvdXApIHtcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBfZ3JvdXAgPSBuZXdfZ3JvdXA7XG4gICAgICAgICAgICAgICAgcHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG4gICAgICAgICAgICBfaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgcHVzaCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbW1lbnQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDgsIChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjb21tZW50KGRhdGEpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC5kYXRhID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcbiAgICBpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcbiAgICAgICAgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0X2RhdGEodGV4dCwgZGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBpbml0aWFsIHJlc2l6ZSBldmVudCBpcyBmaXJlZCBfYWZ0ZXJfIHRoZSBpZnJhbWUgaXMgbG9hZGVkICh3aGljaCBpcyBhc3luY2hyb25vdXMpXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNDIzM1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5jb25zdCByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHsgYm94OiAnY29udGVudC1ib3gnIH0pO1xuY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHsgYm94OiAnYm9yZGVyLWJveCcgfSk7XG5jb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfSk7XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHN0YXJ0ZWQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gbm9kZS50ZXh0Q29udGVudC50cmltKCk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X0VORGApIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkIC09IDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBpc19zdmc7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19zdmcpXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gc3ZnX2VsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCgodGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWUpKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnID8gdGFyZ2V0IDogdGFyZ2V0LmNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUubm9kZU5hbWUgPT09ICdURU1QTEFURScgPyB0aGlzLmUuY29udGVudC5jaGlsZE5vZGVzIDogdGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNfc3ZnKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBmb3IgbXVsdGlwbGUgZG9jdW1lbnRzIGJlY2F1c2UgYSBTdmVsdGUgYXBwbGljYXRpb24gY291bGQgYWxzbyBjb250YWluIGlmcmFtZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzM2MjRcbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuICAgIGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcbiAgICBtYW5hZ2VkX3N0eWxlcy5zZXQoZG9jLCBpbmZvKTtcbiAgICByZXR1cm4gaW5mbztcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuICAgIGlmICghcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiAnJ30ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG93bmVyTm9kZSB9ID0gaW5mby5zdHlsZXNoZWV0O1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gb3duZXJOb2RlIGlmIGl0IHJ1bnMgb24ganNkb20uXG4gICAgICAgICAgICBpZiAob3duZXJOb2RlKVxuICAgICAgICAgICAgICAgIGRldGFjaChvd25lck5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtYmVmb3JldXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIGEgW3NlcnZlci1zaWRlIGNvbXBvbmVudF0oL2RvY3MjcnVuLXRpbWUtc2VydmVyLXNpZGUtY29tcG9uZW50LWFwaSkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLW9ubW91bnRcbiAqL1xuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKi9cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLW9uZGVzdHJveVxuICovXG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oL2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtY3JlYXRlZXZlbnRkaXNwYXRjaGVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLXNldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0Y29udGV4dFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1nZXRhbGxjb250ZXh0c1xuICovXG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtaGFzY29udGV4dFxuICovXG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5jb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5jb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuICAgIC8vIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLiBJbnN0ZWFkLCBsZXQgdGhlIGlubmVyIGZsdXNoIGhhbmRsZSBpdC5cbiAgICAvLyBSZWVudHJhbmN5IGlzIG9rIGFmdGVyd2FyZHMgZm9yIGJpbmRpbmdzIGV0Yy5cbiAgICBpZiAoZmx1c2hpZHggIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRpcnR5IHN0YXRlIHRvIG5vdCBlbmQgdXAgaW4gYSBkZWFkbG9ja2VkIHN0YXRlIGFuZCB0aGVuIHJldGhyb3dcbiAgICAgICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VmdWwgZm9yIGV4YW1wbGUgdG8gZXhlY3V0ZSByZW1haW5pbmcgYGFmdGVyVXBkYXRlYCBjYWxsYmFja3MgYmVmb3JlIGV4ZWN1dGluZyBgZGVzdHJveWAuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoZm5zKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICBjb25zdCB0YXJnZXRzID0gW107XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKTtcbiAgICB0YXJnZXRzLmZvckVhY2goKGMpID0+IGMoKSk7XG4gICAgcmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnaW4nIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ291dCcgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IChwcm9ncmFtLmIgLSB0KTtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyDigJQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyDigJQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgLy8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcnVuX2FsbCh1cGRhdGVzKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbmNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSBbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2luZXJ0JyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXTtcbi8qKlxuICogTGlzdCBvZiBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcyAoZS5nLiBgPGlucHV0IGRpc2FibGVkPmApLlxuICogU291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbiAqL1xuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogcmVnZXggb2YgYWxsIGh0bWwgdm9pZCBlbGVtZW50IG5hbWVzICovXG5jb25zdCB2b2lkX2VsZW1lbnRfbmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvO1xuZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG4gICAgcmV0dXJuIHZvaWRfZWxlbWVudF9uYW1lcy50ZXN0KG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChhdHRyc190b19hZGQpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3NlcztcbiAgICAgICAgY29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG4gICAgICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZXNfdG9fYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKG1lcmdlX3Nzcl9zdHlsZXMoYXR0cmlidXRlcy5zdHlsZSwgc3R5bGVzX3RvX2FkZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICBjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGluZGl2aWR1YWxfc3R5bGUgb2Ygc3R5bGVfYXR0cmlidXRlLnNwbGl0KCc7JykpIHtcbiAgICAgICAgY29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKGNvbG9uX2luZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZV9vYmplY3Q7XG59XG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh2YWx1ZSwgaXNfYXR0ciA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICB3aGlsZSAocGF0dGVybi50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgY2ggPSBzdHJbaV07XG4gICAgICAgIGVzY2FwZWQgKz0gc3RyLnN1YnN0cmluZyhsYXN0LCBpKSArIChjaCA9PT0gJyYnID8gJyZhbXA7JyA6IChjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKSk7XG4gICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuICAgIC8vIGtlZXAgYm9vbGVhbnMsIG51bGwsIGFuZCB1bmRlZmluZWQgZm9yIHRoZSBzYWtlIG9mIGBzcHJlYWRgXG4gICAgY29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuICAgIHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlX29iamVjdChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXMuIE90aGVyd2lzZSB5b3UgbWF5IG5lZWQgdG8gZml4IGEgPCR7bmFtZX0+LmApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gKGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUpID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcbiAgICByZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5mdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuZnVuY3Rpb24gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuICAgICAgICAuZmlsdGVyKGtleSA9PiBzdHlsZV9vYmplY3Rba2V5XSlcbiAgICAgICAgLm1hcChrZXkgPT4gYCR7a2V5fTogJHtlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHN0eWxlX29iamVjdFtrZXldKX07YClcbiAgICAgICAgLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuICAgIHJldHVybiBzdHlsZXMgPyBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBpdCB3aWxsIHVwZGF0ZSB0aGUgYCQkLm9uX2Rlc3Ryb3lgIHJlZmVyZW5jZSB0byBgbnVsbGAuXG4gICAgICAgICAgICAvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcbiAgICAgICAgICAgICAgICBydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogW10sXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIHByb3BzLFxuICAgICAgICB1cGRhdGU6IG5vb3AsXG4gICAgICAgIG5vdF9lcXVhbCxcbiAgICAgICAgYm91bmQ6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICAvLyBsaWZlY3ljbGVcbiAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICBvbl9kZXN0cm95OiBbXSxcbiAgICAgICAgb25fZGlzY29ubmVjdDogW10sXG4gICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICBjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgc2tpcF9ib3VuZDogZmFsc2UsXG4gICAgICAgIHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuICAgIH07XG4gICAgYXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICQkLmN0eCA9IGluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgc3RhcnRfaHlkcmF0aW5nKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50cm8pXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvciwgb3B0aW9ucy5jdXN0b21FbGVtZW50KTtcbiAgICAgICAgZW5kX2h5ZHJhdGluZygpO1xuICAgICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5sZXQgU3ZlbHRlRWxlbWVudDtcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbl9tb3VudCB9ID0gdGhpcy4kJDtcbiAgICAgICAgICAgIHRoaXMuJCQub25fZGlzY29ubmVjdCA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJC5zbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuJCQuc2xvdHRlZFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgICRkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgZGVsZWdhdGUgdG8gYWRkRXZlbnRMaXN0ZW5lcj9cbiAgICAgICAgICAgIGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjU5LjInIH0sIGRldGFpbCksIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbiwgaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGlmIChoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24nKTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgY29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuICAgIGVsc2VcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC5kYXRhID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG4gICAgaWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG4gICAgICAgIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBlcnJvcl9tZXNzYWdlID0gJ3RoaXM9ey4uLn0gb2YgPHN2ZWx0ZTpjb21wb25lbnQ+IHNob3VsZCBzcGVjaWZ5IGEgU3ZlbHRlIGNvbXBvbmVudC4nO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGNvbXBvbmVudChwcm9wcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2UuJCQgfHwgIWluc3RhbmNlLiRzZXQgfHwgIWluc3RhbmNlLiRvbiB8fCAhaW5zdGFuY2UuJGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBlcnI7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKCdpcyBub3QgYSBjb25zdHJ1Y3RvcicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24sIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVDb21wb25lbnRUeXBlZCwgU3ZlbHRlRWxlbWVudCwgYWN0aW9uX2Rlc3Ryb3llciwgYWRkX2F0dHJpYnV0ZSwgYWRkX2NsYXNzZXMsIGFkZF9mbHVzaF9jYWxsYmFjaywgYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIsIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3N0eWxlcywgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tbWVudCwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tbWVudCwgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudCwgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2LCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcywgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGhlYWRfc2VsZWN0b3IsIGlkZW50aXR5LCBpbml0LCBpbml0X2JpbmRpbmdfZ3JvdXAsIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljLCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCwgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94LCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94LCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCwgc2V0X2RhdGEsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSwgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldiwgc2V0X2RhdGFfZGV2LCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwbGl0X2Nzc191bml0LCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24sIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHRydXN0ZWQsIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2gsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3RfYmFzZSwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCwgeGxpbmtfYXR0ciB9O1xuIiwiZXhwb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgubWpzJztcblxuLypcbkFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2xcbkRpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9lYXNlcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4qL1xuZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpO1xufVxuZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cbmZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xufVxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgICBjb25zdCBhID0gNC4wIC8gMTEuMDtcbiAgICBjb25zdCBiID0gOC4wIC8gMTEuMDtcbiAgICBjb25zdCBjID0gOS4wIC8gMTAuMDtcbiAgICBjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuICAgIGNvbnN0IGNiID0gMzU0NDIuMCAvIDE4MDUuMDtcbiAgICBjb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG4gICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICByZXR1cm4gdCA8IGFcbiAgICAgICAgPyA3LjU2MjUgKiB0MlxuICAgICAgICA6IHQgPCBiXG4gICAgICAgICAgICA/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG4gICAgICAgICAgICA6IHQgPCBjXG4gICAgICAgICAgICAgICAgPyBjYSAqIHQyIC0gY2IgKiB0ICsgY2NcbiAgICAgICAgICAgICAgICA6IDEwLjggKiB0ICogdCAtIDIwLjUyICogdCArIDEwLjcyO1xufVxuZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0ICogMi4wKSlcbiAgICAgICAgOiAwLjUgKiBib3VuY2VPdXQodCAqIDIuMCAtIDEuMCkgKyAwLjU7XG59XG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xufVxuZnVuY3Rpb24gY2lyY0luKHQpIHtcbiAgICByZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgICBjb25zdCBmID0gdCAtIDEuMDtcbiAgICByZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKCsxMy4wICogTWF0aC5QSSkgLyAyKSAqIDIuMCAqIHQpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcbiAgICAgICAgOiAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgtMTMuMCAqIE1hdGguUEkpIC8gMikgKiAoMi4wICogdCAtIDEuMCArIDEuMCkpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcbiAgICAgICAgICAgIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIChNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wKTtcbn1cbmZ1bmN0aW9uIGV4cG9Jbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcbiAgICAgICAgPyB0XG4gICAgICAgIDogdCA8IDAuNVxuICAgICAgICAgICAgPyArMC41ICogTWF0aC5wb3coMi4wLCAyMC4wICogdCAtIDEwLjApXG4gICAgICAgICAgICA6IC0wLjUgKiBNYXRoLnBvdygyLjAsIDEwLjAgLSB0ICogMjAuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBleHBvSW4odCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgPyB0IDogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGV4cG9PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcbiAgICB0IC89IDAuNTtcbiAgICBpZiAodCA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiB0ICogdDtcbiAgICB0LS07XG4gICAgcmV0dXJuIC0wLjUgKiAodCAqICh0IC0gMikgLSAxKTtcbn1cbmZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gICAgcmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyArOC4wICogTWF0aC5wb3codCwgNC4wKVxuICAgICAgICA6IC04LjAgKiBNYXRoLnBvdyh0IC0gMS4wLCA0LjApICsgMS4wO1xufVxuZnVuY3Rpb24gcXVhcnRJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIDQuMCk7XG59XG5mdW5jdGlvbiBxdWFydE91dCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5mdW5jdGlvbiBxdWludEluT3V0KHQpIHtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbn1cbmZ1bmN0aW9uIHF1aW50SW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKiB0ICogdCArIDE7XG59XG5mdW5jdGlvbiBzaW5lSW5PdXQodCkge1xuICAgIHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufVxuZnVuY3Rpb24gc2luZUluKHQpIHtcbiAgICBjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuICAgIGlmIChNYXRoLmFicyh2KSA8IDFlLTE0KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAxIC0gdjtcbn1cbmZ1bmN0aW9uIHNpbmVPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG5cbmV4cG9ydCB7IGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0LCBib3VuY2VJbiwgYm91bmNlSW5PdXQsIGJvdW5jZU91dCwgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQsIGN1YmljSW4sIGN1YmljSW5PdXQsIGN1YmljT3V0LCBlbGFzdGljSW4sIGVsYXN0aWNJbk91dCwgZWxhc3RpY091dCwgZXhwb0luLCBleHBvSW5PdXQsIGV4cG9PdXQsIHF1YWRJbiwgcXVhZEluT3V0LCBxdWFkT3V0LCBxdWFydEluLCBxdWFydEluT3V0LCBxdWFydE91dCwgcXVpbnRJbiwgcXVpbnRJbk91dCwgcXVpbnRPdXQsIHNpbmVJbiwgc2luZUluT3V0LCBzaW5lT3V0IH07XG4iLCJpbXBvcnQgeyBjdWJpY0luT3V0LCBsaW5lYXIsIGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBzcGxpdF9jc3NfdW5pdCwgaXNfZnVuY3Rpb24sIGFzc2lnbiB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBmID0gc3R5bGUuZmlsdGVyID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLmZpbHRlcjtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICBjb25zdCBbdmFsdWUsIHVuaXRdID0gc3BsaXRfY3NzX3VuaXQoYW1vdW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9OyBmaWx0ZXI6ICR7Zn0gYmx1cigke3UgKiB2YWx1ZX0ke3VuaXR9KTtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIgfSA9IHt9KSB7XG4gICAgY29uc3QgbyA9ICtnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogdCA9PiBgb3BhY2l0eTogJHt0ICogb31gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZseShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgY29uc3QgW3hWYWx1ZSwgeFVuaXRdID0gc3BsaXRfY3NzX3VuaXQoeCk7XG4gICAgY29uc3QgW3lWYWx1ZSwgeVVuaXRdID0gc3BsaXRfY3NzX3VuaXQoeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4VmFsdWV9JHt4VW5pdH0sICR7KDEgLSB0KSAqIHlWYWx1ZX0ke3lVbml0fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9YFxuICAgIH07XG59XG5mdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBheGlzID0gJ3knIH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgcHJpbWFyeV9wcm9wZXJ0eSA9IGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICBjb25zdCBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtwcmltYXJ5X3Byb3BlcnR5XSk7XG4gICAgY29uc3Qgc2Vjb25kYXJ5X3Byb3BlcnRpZXMgPSBheGlzID09PSAneScgPyBbJ3RvcCcsICdib3R0b20nXSA6IFsnbGVmdCcsICdyaWdodCddO1xuICAgIGNvbnN0IGNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzID0gc2Vjb25kYXJ5X3Byb3BlcnRpZXMubWFwKChlKSA9PiBgJHtlWzBdLnRvVXBwZXJDYXNlKCl9JHtlLnNsaWNlKDEpfWApO1xuICAgIGNvbnN0IHBhZGRpbmdfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG4gICAgY29uc3QgcGFkZGluZ19lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG4gICAgY29uc3QgbWFyZ2luX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG4gICAgY29uc3QgbWFyZ2luX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuICAgIGNvbnN0IGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19V2lkdGhgXSk7XG4gICAgY29uc3QgYm9yZGVyX3dpZHRoX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19V2lkdGhgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogdCA9PiAnb3ZlcmZsb3c6IGhpZGRlbjsnICtcbiAgICAgICAgICAgIGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcbiAgICAgICAgICAgIGAke3ByaW1hcnlfcHJvcGVydHl9OiAke3QgKiBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIHBhZGRpbmdfc3RhcnRfdmFsdWV9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogcGFkZGluZ19lbmRfdmFsdWV9cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBtYXJnaW5fc3RhcnRfdmFsdWV9cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBtYXJnaW5fZW5kX3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX2VuZF92YWx1ZX1weDtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNjYWxlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBzZCA9IDEgLSBzdGFydDtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIChzZCAqIHUpfSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9XG5cdFx0YFxuICAgIH07XG59XG5mdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljSW5PdXQgfSA9IHt9KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnN0cm9rZUxpbmVjYXAgIT09ICdidXR0Jykge1xuICAgICAgICBsZW4gKz0gcGFyc2VJbnQoc3R5bGUuc3Ryb2tlV2lkdGgpO1xuICAgIH1cbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSA4MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfLCB1KSA9PiBgXG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiAke2xlbn07XG5cdFx0XHRzdHJva2UtZGFzaG9mZnNldDogJHt1ICogbGVufTtcblx0XHRgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyb3NzZmFkZShfYSkge1xuICAgIHZhciB7IGZhbGxiYWNrIH0gPSBfYSwgZGVmYXVsdHMgPSBfX3Jlc3QoX2EsIFtcImZhbGxiYWNrXCJdKTtcbiAgICBjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHRvX3NlbmQgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3Jvc3NmYWRlKGZyb21fbm9kZSwgbm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMzAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGZyb20gPSBmcm9tX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuICAgICAgICBjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgY29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7dCArICgxIC0gdCkgKiBkaH0pO1xuXHRcdFx0YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG4gICAgICAgIHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5zZXQocGFyYW1zLmtleSwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyX25vZGUgPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NmYWRlKG90aGVyX25vZGUsIG5vZGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuICAgICAgICAgICAgICAgIGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSxcbiAgICAgICAgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKVxuICAgIF07XG59XG5cbmV4cG9ydCB7IGJsdXIsIGNyb3NzZmFkZSwgZHJhdywgZmFkZSwgZmx5LCBzY2FsZSwgc2xpZGUgfTtcbiIsIjxkaXYgY2xhc3M9XCJNYWluQXBwQ29udGFpbmVyUGFnZVwiPlxuXHQ8c2VjdGlvbiBjbGFzcz1cIk1haW5BcHBDb250YWluZXJQYWdlVGV4dEltYWdlU2VjdGlvblwiPlxuXHRcdDxkaXY+XG5cdFx0XHQ8cHJlPlxuXHRcdFx0XHRHcm9iYXgnIFRUUlBHLlxuXHRcdFx0XHRNYWtlIGEgYGBgVFRSUEcgYGBgIGJsb2NrIGluIGFuIGFydGljbGUuIHRoZW4geW91IGdldCB0byBzZXR1cCB5b3VyIGJsb2NrLlxuXHRcdFx0XHRjaG9vc2luZyBhIHN5c3RlbSwgYW5kIHRoZW4gYSBVSSBmb3IgdGhhdCBzeXN0ZW0uXG5cblx0XHRcdFx0VGhlcmUgYXJlIGEgc3RhbmRhcmQgTGF5b3V0cywgYnV0IHlvdSBhcmUgYWJsZSB0byB1c2UgZWRpdGluZyBzeXN0ZW1zIHRvIGNoYW5nZSB0aGUgbGF5b3V0LFxuXHRcdFx0XHRZb3UgY2FuIHVzZSB0aGUgRWRpdCBidXR0b24gdG8gY2hhbmdlIHNpbmdsZSB2aWV3IHNldHRpbmdzLlxuXHRcdFx0XHRUaGUgbGF5b3V0IGlzIG1hZGUgdXAgb2Ygcm93cywgdGhlbiBjb2x1bW5zLCB0aGVuIGl0ZW1zIGluIHJvd3MuXG5cdFx0XHRcdFlvdSBjYW4gdXNlIGVkaXQgcm93cyB0byBhZGQsIGRlbGV0ZSBhbmQgc3dpdGNoIHRoZSBwbGFjaW5nIG9mIHRoZXNlIHJvd3MgYWxvbmcgd2l0aCB0aGVpciBjb250ZW50cy5cblxuXHRcdFx0XHRZb3UgY2FuIHVzZSBlZGl0IGNvbHVtbnMgdG8gYWRkLCBkZWxldGUgYW5kIHN3aXRjaCBwbGFjZXMgb2YgY29sdW1ucyBhbmQgdGhlaXIgaXRlbXMuIFxuXG5cdFx0XHRcdFlvdSBjYW4gdXNlIGVkaXQgSXRlbXMgdG8gYWRkLCBkZWxldGUgaXRlbXMgaW4gdGhlIGNvbHVtbnMsIHlvdSBjYW4gYWxzbyBhc2lnbiBhbiBpdGVtIGEgdmlldywgYXMgd2VsbCBhcyBkcmFnIHRoZW0gaW50byBvdGhlciBjb2x1bW5zLiBcblx0XHRcdFx0aW4gdGhpcyBtb2RlIHlvdSBhcmUgYWxzbyBnaXZlbiBhY2Nlc3MgdG8gYnV0dG9ucyB0byBtYW5vdXZlciB0aGUgaXRlbSdzIHBvc2l0aW9uIGluIHRoYXQgY29sdW1uLlxuXHRcdFx0PC9wcmU+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiA+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiTWFpbkFwcENvbnRhaW5lclBhZ2VUZXh0SW1hZ2VTZWN0aW9uSW1hZ2VcIiA+XG5cdFx0XHRcdElNQUdFXG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9zZWN0aW9uPlxuXHQ8c2VjdGlvbj5cblx0XHQ8ZGl2IGNsYXNzPVwidGFibGUgXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgc3R5bGU9XCJmbG9hdDpsZWZ0O1wiXHQ+IFNldHRpbmcgMSA8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgc3R5bGU9XCJmbG9hdDpyaWdodDtcIj5cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPVwiMTJcIiAvPlxuXHRcdFx0XHRcdDxzZWxlY3Q+XG5cdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwicHhcIiBzZWxlY3RlZD5weDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cImVtXCI+ZW08L29wdGlvbj5cblx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCIlXCI+JTwvb3B0aW9uPlx0XHRcblx0XHRcdFx0XHQ8L3NlbGVjdD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd1wiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dDb2x1bW5cIiBzdHlsZT1cImZsb2F0OmxlZnQ7XCJcdD4gU2V0dGluZyAyPC9kaXY+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiIHN0eWxlPVwiZmxvYXQ6cmlnaHQ7XCI+XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgc3R5bGU9XCJmbG9hdDpsZWZ0O1wiXHQ+IFNldHRpbmcgMzwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dDb2x1bW5cIiBzdHlsZT1cImZsb2F0OnJpZ2h0O1wiPlxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiAvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L3NlY3Rpb24+XG48L2Rpdj4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XHJcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cclxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XHJcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcclxuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xyXG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcclxuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XHJcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XHJcbiAgICBkb25lID0gdHJ1ZTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XHJcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcclxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSk7XHJcbiAgICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xyXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcclxuICAgICAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XHJcbiAgICAgICAgaWYgKGFzeW5jKSB7XHJcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcclxuICAgICAgICAgICAgaWYgKGFzeW5jKSBpbm5lciA9IGRpc3Bvc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcclxuICAgICAgICBpZiAoaW5uZXIpIGRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgdHJ5IHsgaW5uZXIuY2FsbCh0aGlzKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IH0gfTtcclxuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXN5bmMpIHtcclxuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG5cclxufVxyXG5cclxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XHJcbiAgICBmdW5jdGlvbiBmYWlsKGUpIHtcclxuICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XHJcbiAgICAgICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHZhciByLCBzID0gMDtcclxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHIuZGlzcG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByLmRpc3Bvc2UuY2FsbChyLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoci5hc3luYykgcmV0dXJuIHMgfD0gMiwgUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBzIHw9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGZhaWwoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMgPT09IDEpIHJldHVybiBlbnYuaGFzRXJyb3IgPyBQcm9taXNlLnJlamVjdChlbnYuZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgX19leHRlbmRzOiBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbjogX19hc3NpZ24sXHJcbiAgICBfX3Jlc3Q6IF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGU6IF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtOiBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YTogX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcjogX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3I6IF9fZ2VuZXJhdG9yLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nOiBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX2V4cG9ydFN0YXI6IF9fZXhwb3J0U3RhcixcclxuICAgIF9fdmFsdWVzOiBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZDogX19yZWFkLFxyXG4gICAgX19zcHJlYWQ6IF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXM6IF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheTogX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQ6IF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yOiBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcjogX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXM6IF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdDogX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXI6IF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdDogX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ6IF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW46IF9fY2xhc3NQcml2YXRlRmllbGRJbixcclxuICAgIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlOiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcclxuICAgIF9fZGlzcG9zZVJlc291cmNlczogX19kaXNwb3NlUmVzb3VyY2VzLFxyXG59O1xyXG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgZXhwb3J0IGxldCBjb2xvcjogc3RyaW5nID0gXCJibGFja1wiIDsgXG48L3NjcmlwdD5cbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT17Y29sb3J9IHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBjbGFzcz1cInN2Zy1pY29uIGx1Y2lkZS1wbHVzLWNpcmNsZVwiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCI+XG4gICAgICAgIDwvY2lyY2xlPlxuICAgICAgICA8bGluZSB4MT1cIjEyXCIgeTE9XCI4XCIgeDI9XCIxMlwiIHkyPVwiMTZcIj5cbiAgICAgICAgPC9saW5lPlxuICAgICAgICA8bGluZSB4MT1cIjhcIiB5MT1cIjEyXCIgeDI9XCIxNlwiIHkyPVwiMTJcIj5cbiAgICAgICAgPC9saW5lPlxuICAgIDwvc3ZnPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cblxuXHRpbXBvcnQgSW1hZ2VfcGx1cyBmcm9tIFwiLi4vYnV0dG9ucy9wbHVzLnN2ZWx0ZVwiOyBcbiAgICBpbXBvcnQgeyAgIHNsaWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiOyAgXG4gXG5cblx0ZXhwb3J0IGxldCBpc0VkaXRhYmxlQ29udGFpbmVyOmJvb2xlYW4gPSB0cnVlO1xuICAgIGV4cG9ydCBsZXQgY29sbGVjdGlvbjogc3RyaW5nW10gfCB7a2V5OnN0cmluZywgdmFsdWU6c3RyaW5nLCBpc1NlbGVjdGVkPzpib29sZWFuIH1bXTsgXG5cdCQ6IF9jb2xsZWN0aW9uID0gY29sbGVjdGlvbi5tYXAoIHAgPT4geyBcblx0XHRpZiAoIHAua2V5ICYmIHAudmFsdWUgKXtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGtleVx0XHRcdDpwLmtleSxcblx0XHRcdFx0bmFtZVx0XHQ6cC52YWx1ZSxcblx0XHRcdFx0aXNTZWxlY3RlZFx0OnAuaXNTZWxlY3RlZCA/PyBmYWxzZSxcblx0XHRcdFx0bmFtZUVkaXRcdDpwLnZhbHVlLFxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNle1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0a2V5XHRcdFx0OnAgYXMgc3RyaW5nLFxuXHRcdFx0XHRuYW1lXHRcdDpwIGFzIHN0cmluZyxcblx0XHRcdFx0aXNTZWxlY3RlZFx0OmZhbHNlLFxuXHRcdFx0XHRuYW1lRWRpdFx0OnAgYXMgc3RyaW5nLFxuXHRcdFx0fVxuXHRcdH1cblx0fSlcblxuXHRleHBvcnQgbGV0IG9uU2VsZWN0XHRcdDogKCBkOiBhbnkgKSA9PiBib29sZWFuO1xuXHRleHBvcnQgbGV0IG9uQWRkXHRcdDogKCgpID0+IGFueSkgfCBudWxsID0gbnVsbDsgXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0aW50ZXJmYWNlIElWaWV3RWxlbWVudHtcblx0XHRrZXk6c3RyaW5nO1xuXHRcdG5hbWU6c3RyaW5nO1xuXHRcdGlzU2VsZWN0ZWQ6Ym9vbGVhbjtcblx0XHRuYW1lRWRpdDpzdHJpbmc7IFxuXHR9XG5cblx0bGV0IHNlbGVjdGVkIDogSVZpZXdFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cdFxuXHRleHBvcnQgZnVuY3Rpb24gZGVzZWxlY3QoKXtcblx0XHRpZighc2VsZWN0ZWQpXG5cdFx0XHRyZXR1cm47XG4gXG5cdFx0bGV0IGkgPSBfY29sbGVjdGlvbi5maW5kSW5kZXgoIHAgPT4gcC5pc1NlbGVjdGVkICk7IFxuXHRcdGlmKCBpICE9IC0xIClcblx0XHRcdF9jb2xsZWN0aW9uW2ldLmlzU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRcdHNlbGVjdGVkID0gbnVsbDtcblx0XHRkaXNwYXRjaCgnb25EZVNlbGVjdCcpXG5cdH1cblxuXHRleHBvcnQgZnVuY3Rpb24gc2VsZWN0KCBrZXkgOiBzdHJpbmcgKXtcblx0XHRsZXQgaXRlbSA9IF9jb2xsZWN0aW9uLmZpbmQoIHAgPT4gcC5rZXkgPT0ga2V5ICk7XG5cdFx0aWYgKCBpdGVtICl7XG5cdFx0XHRfb25TZWxlY3QoIGl0ZW0gKTtcblx0XHR9XG5cdH1cblx0IFxuXHRmdW5jdGlvbiBfb25TZWxlY3QoaXRlbSA6IElWaWV3RWxlbWVudCl7IFxuXG5cdFx0Ly8gZ2V0IGxhc3Qgc2VsZWN0ZWQgXG5cdFx0bGV0IGkgPSBfY29sbGVjdGlvbi5maW5kSW5kZXgoIHAgPT4gcC5pc1NlbGVjdGVkICk7IFxuXHRcblx0XHQvLyBlbnN1cmUgdGhhdCBhIENsaWNrIG9uIHRoZSBzYW1lIGl0ZW0gaXMgYSBkZXNlbGVjdFxuXHRcdGlmICggaSAhPSAtMSAmJiBfY29sbGVjdGlvbltpXS5rZXkgPT0gaXRlbS5rZXkgKXtcblx0XHRcdF9jb2xsZWN0aW9uW2ldLmlzU2VsZWN0ZWQgPSBmYWxzZTsgXG5cdFx0XHRzZWxlY3RlZCA9IG51bGw7XG5cdFx0XHRkaXNwYXRjaCgnb25EZVNlbGVjdCcpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZGVzZWxlY3Rcblx0XHRpZiAoIGkgIT0gLTEgKVxuXHRcdFx0X2NvbGxlY3Rpb25baV0uaXNTZWxlY3RlZCA9IGZhbHNlO1xuXG5cdFx0aSA9IF9jb2xsZWN0aW9uLmZpbmRJbmRleCggcCA9PiBwLmtleSA9PSBpdGVtLmtleSApOyAgXG5cdFx0Y29uc3QgaXNTZWxlY3RlZCA9IG9uU2VsZWN0KF9jb2xsZWN0aW9uW2ldLmtleSk7IFxuXHRcdGlmIChpc1NlbGVjdGVkKXtcblx0XHRcdHNlbGVjdGVkID0gX2NvbGxlY3Rpb25baV07XG5cdFx0fSBlbHNle1xuXHRcdFx0c2VsZWN0ZWQgPSBudWxsO1xuXHRcdH1cbiBcblx0XHRfY29sbGVjdGlvbltpXS5pc1NlbGVjdGVkID0gaXNTZWxlY3RlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIF9vbkFkZCgpe1xuXHRcdGlmKCFvbkFkZClcblx0XHRcdHJldHVybjtcdFxuIFxuXHRcdGRlc2VsZWN0KCk7XG5cdFx0b25BZGQoKTtcblx0fVxuXG48L3NjcmlwdD5cblxuXG4gICAgPGRpdiBjbGFzcz17IGlzRWRpdGFibGVDb250YWluZXIgPyBcIkdyb2JzSW50ZXJhY3RpdmVDb250YWluZXIgZWRpdGFibGVUYWJsZVwiIDogXCJlZGl0YWJsZVRhYmxlXCJ9ID5cblx0XHRcdHsjZWFjaCBfY29sbGVjdGlvbiBhcyBlICggZS5rZXkgKSB9XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRjbGFzcz1cIkVkaXRhYmxlX3Jvd1wiIFxuXHRcdFx0XHRcdGRhdGEtc2VsZWN0ZWQ9eyBlLmlzU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdHRyYW5zaXRpb246c2xpZGUgXG5cdFx0XHRcdFx0ZGF0YS1jYW4taG92ZXI9e3RydWV9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHR0YWJpbmRleD1cIi0xXCJcblx0XHRcdFx0XHRcdGNsYXNzPVwiRWRpdGFibGVfY29sdW1uXCJcblx0XHRcdFx0XHRcdGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJcblx0XHRcdFx0XHRcdGJpbmQ6dGV4dENvbnRlbnQ9e2UubmFtZX0gXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+IF9vblNlbGVjdChlKSB9XG5cdFx0XHRcdFx0XHRvbjprZXl1cFxuXHRcdFx0XHRcdD4gXG5cdFx0XHRcdFx0XHR7ZS5uYW1lfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdHsvZWFjaH1cblx0XHRcdHsjaWYgb25BZGQgIT0gbnVsbCB9XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzcz1cIkVkaXRhYmxlX3JvdyBFZGl0YWJsZV9yb3dQbHVzQnV0dG9uXCJcblx0XHRcdFx0XHRkYXRhLXNlbGVjdGVkPXsgZmFsc2UgfVxuXHRcdFx0XHRcdHRyYW5zaXRpb246c2xpZGVcblx0XHRcdFx0XHRkYXRhLWNhbi1ob3Zlcj17dHJ1ZX1cblx0XHRcdFx0XHRzdHlsZT1cImRpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcIlxuXHRcdFx0XHRcdG9uOmNsaWNrPXsgKCkgPT4gX29uQWRkKCkgfVxuXHRcdFx0XHRcdG9uOmtleXVwPXsgKCkgPT4gX29uQWRkKCkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PGRpdiBcblx0XHRcdFx0XHRcdHRhYmluZGV4PVwiLTFcIlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJFZGl0YWJsZV9JY29uXCJcblx0XHRcdFx0XHRcdGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIgXG5cdFx0XHRcdFx0PiAgXG5cdFx0XHRcdFx0XHQ8SW1hZ2VfcGx1cyBjb2xvcj17JyNmZmYnfS8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2Plx0XG5cdFx0XHR7L2lmfVxuXHQ8L2Rpdj5cblxuICIsImltcG9ydCB7IG5vb3AsIHNhZmVfbm90X2VxdWFsLCBzdWJzY3JpYmUsIHJ1bl9hbGwsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgubWpzJztcbmV4cG9ydCB7IGdldF9zdG9yZV92YWx1ZSBhcyBnZXQgfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5tanMnO1xuXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXJ9IFtzdGFydF1cbiAqL1xuZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKiBAcGFyYW0geyo9fXZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI9fSBzdGFydFxuICovXG5mdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG4gICAgbGV0IHN0b3A7XG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuICAgICAgICBpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3X3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0b3ApIHsgLy8gc3RvcmUgaXMgcmVhZHlcbiAgICAgICAgICAgICAgICBjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJbMV0oKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bl9xdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgICAgIHNldChmbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG4gICAgICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGFydChzZXQpIHx8IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwICYmIHN0b3ApIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3RvcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHNldCwgdXBkYXRlLCBzdWJzY3JpYmUgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuICAgIGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG4gICAgY29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlXG4gICAgICAgID8gW3N0b3Jlc11cbiAgICAgICAgOiBzdG9yZXM7XG4gICAgY29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG4gICAgcmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICAgICAgbGV0IGNsZWFudXAgPSBub29wO1xuICAgICAgICBjb25zdCBzeW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCk7XG4gICAgICAgICAgICBpZiAoYXV0bykge1xuICAgICAgICAgICAgICAgIHNldChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCA9IGlzX2Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQgOiBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+IHN1YnNjcmliZShzdG9yZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmcgfD0gKDEgPDwgaSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHN5bmMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICBydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcbiAgICAgICAgICAgIC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFRha2VzIGEgc3RvcmUgYW5kIHJldHVybnMgYSBuZXcgb25lIGRlcml2ZWQgZnJvbSB0aGUgb2xkIG9uZSB0aGF0IGlzIHJlYWRhYmxlLlxuICpcbiAqIEBwYXJhbSBzdG9yZSAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqL1xuZnVuY3Rpb24gcmVhZG9ubHkoc3RvcmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZS5iaW5kKHN0b3JlKVxuICAgIH07XG59XG5cbmV4cG9ydCB7IGRlcml2ZWQsIHJlYWRhYmxlLCByZWFkb25seSwgd3JpdGFibGUgfTtcbiIsImltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc19mdW5jdGlvbiB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGZsaXAobm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IFtveCwgb3ldID0gc3R5bGUudHJhbnNmb3JtT3JpZ2luLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xuICAgIGNvbnN0IGR4ID0gKGZyb20ubGVmdCArIGZyb20ud2lkdGggKiBveCAvIHRvLndpZHRoKSAtICh0by5sZWZ0ICsgb3gpO1xuICAgIGNvbnN0IGR5ID0gKGZyb20udG9wICsgZnJvbS5oZWlnaHQgKiBveSAvIHRvLmhlaWdodCkgLSAodG8udG9wICsgb3kpO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IChkKSA9PiBNYXRoLnNxcnQoZCkgKiAxMjAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKSA6IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB1ICogZHg7XG4gICAgICAgICAgICBjb25zdCB5ID0gdSAqIGR5O1xuICAgICAgICAgICAgY29uc3Qgc3ggPSB0ICsgdSAqIGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHN5ID0gdCArIHUgKiBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KSBzY2FsZSgke3N4fSwgJHtzeX0pO2A7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBmbGlwIH07XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IFx0Y29uc3QgTWVzc2FnZVR5cGVzID0ge1xuXHRcdGVycm9yXHQ6XCJlcnJvclwiLFxuXHRcdHZlcmJvc2VcdDpcInZlcmJvc2VcIiwgXG5cdFx0Z29vZFx0OlwiZ29vZFwiXG5cdH1cblx0ZXhwb3J0IHR5cGUgTWVzc2FnZVR5cGVUeXBlcyA9IGtleW9mIHR5cGVvZiBNZXNzYWdlVHlwZXM7XG48L3NjcmlwdD4gXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBcblx0aW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjsgXG4gICAgaW1wb3J0IHsgd3JpdGFibGUgLCB0eXBlICBXcml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG4gICAgaW1wb3J0IHsgZmxpcCB9IGZyb20gJ3N2ZWx0ZS9hbmltYXRlJztcblxuXHRsZXQgbWVzc2FnZXMgOiBXcml0YWJsZTxSZWNvcmQ8YW55LHttc2c6c3RyaW5nLCB0eXBlIDogTWVzc2FnZVR5cGVUeXBlc30+PiA9IHdyaXRhYmxlKHt9KTtcblx0bGV0IG1lc3NhZ2VzTGVuZ3RoID0gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5sZW5ndGg7XG5cdGxldCBlbnRyaWVzIDogW2FueSx7bXNnOnN0cmluZywgdHlwZSA6IE1lc3NhZ2VUeXBlVHlwZXN9XSBbXSA9IFtdO1xuXHRleHBvcnQgbGV0IG92ZXJyaWRlQ2xpY2sgOiAoKCB0eXBlOnN0cmluZyAsa2V5IDogYW55ICkgPT4gYW55ICkgfCBudWxsID0gbnVsbCA7XG5cdGV4cG9ydCBsZXQgb3ZlcnJpZGVDbGlja1RleHRFcnJvciA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXHRcblxuXHRtZXNzYWdlcy5zdWJzY3JpYmUoIHAgPT4geyBcblx0XHRlbnRyaWVzID0gIE9iamVjdC5lbnRyaWVzKHApO1xuXHRcdG1lc3NhZ2VzTGVuZ3RoID0gZW50cmllcy5sZW5ndGg7IFxuXHR9KVxuXG5cdGV4cG9ydCBmdW5jdGlvbiBhZGRNZXNzYWdlKCBrZXk6IGFueSAsIG1zZyA6IHttc2c6c3RyaW5nLCB0eXBlIDogTWVzc2FnZVR5cGVUeXBlcyB9ICl7ICBcblx0XHRcblx0XHRpZighbXNnKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYoIW1zZy50eXBlKVxuXHRcdFx0bXNnLnR5cGUgPSAnZXJyb3InO1xuXHRcdFxuXHRcdG1lc3NhZ2VzLnVwZGF0ZSggciA9PiB7XG5cdFx0XHRyW2tleV0gPSBtc2cgXG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9KVxuXHR9XG5cdGV4cG9ydCBmdW5jdGlvbiBhZGRNZXNzYWdlTWFudWFsKCBrZXk6IGFueSAsIG1zZyA6IHN0cmluZyAsIHR5cGUgOiBNZXNzYWdlVHlwZVR5cGVzID0gJ2Vycm9yJyApeyAgXG5cdFx0bWVzc2FnZXMudXBkYXRlKCByID0+IHtcblx0XHRcdHJba2V5XSA9IHttc2c6bXNnLHR5cGU6dHlwZX07IFxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSlcblx0fVxuXHRleHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXJyb3IoIGtleSA6IGFueSApeyAgXG5cdFx0bWVzc2FnZXMudXBkYXRlKCByID0+IHtcblxuXHRcdFx0aWYoIXJba2V5XSlcblx0XHRcdFx0cmV0dXJuIHI7XG5cblx0XHRcdGRlbGV0ZSByW2tleV07IFxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSkgXG5cdH1cblx0ZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbE1lc3NhZ2VzKCAgKXsgXG5cdFx0bWVzc2FnZXMudXBkYXRlKCAoKSA9PiB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIG9uY2xpY2sodHlwZTphbnksa2V5OmFueSl7IFxuXHRcdFxuXHRcdGxldCBhID0gdHJ1ZTtcblx0XHRpZiAob3ZlcnJpZGVDbGljaylcblx0XHRcdGEgPSBvdmVycmlkZUNsaWNrKHR5cGUsIGtleSApXG5cdFx0XG5cdFx0aWYgKGEpe1xuXHRcdFx0cmVtb3ZlRXJyb3IoIGtleSApO1xuXHRcdH1cblx0fVxuXHRcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiRXJyb3JIYW5kbGVyU2lnbmFnZUNvbnRhaW5lclwiID5cblx0eyNpZiBtZXNzYWdlc0xlbmd0aCAhPSAwfSBcblx0XHQ8ZGl2IGNsYXNzPVwiRXJyb3JIYW5kbGVyU2lnbmFnZVwiIHRyYW5zaXRpb246c2xpZGV8bG9jYWwgPlxuXHRcdFx0eyNlYWNoIGVudHJpZXMgYXMgW2tleSwgb2JqXSAoa2V5KSB9IFxuXHRcdFx0XHR7QGNvbnN0IG1zZ1RyYW5zZm9ybWVkID0gb2JqLm1zZy5yZXBsYWNlKCdcXG4nLCc8YnIgLz4nKX1cblx0XHRcdFx0PGRpdiBcblx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRhbmltYXRlOmZsaXBcblx0XHRcdFx0cm9sZT1cIm5vbmVcIlxuXHRcdFx0XHRjbGFzcz17IFxuXHRcdFx0XHRcdChvYmoudHlwZSA9PSBNZXNzYWdlVHlwZXMuZXJyb3IpID8gXCJFcnJvckhhbmRsZXJTaWduXCIgOiBcblx0XHRcdFx0XHQob2JqLnR5cGUgPT0gTWVzc2FnZVR5cGVzLnZlcmJvc2UpID8gIFwiVmVyYm9zZUhhbmRsZXJTaWduXCIgOiBcblx0XHRcdFx0XHQob2JqLnR5cGUgPT0gTWVzc2FnZVR5cGVzLmdvb2QpID8gIFwiT0tIYW5kbGVyU2lnblwiIDogXG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0fSBcblx0XHRcdFx0b246a2V5ZG93bj17ICgpID0+XHR7IG9uY2xpY2sob2JqLnR5cGUsa2V5KX0gfVxuXHRcdFx0XHRvbjpjbGljaz17ICgpID0+XHR7IG9uY2xpY2sob2JqLnR5cGUsa2V5KX0gfVxuXHRcdFx0XHQ+IFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdDxwPntAaHRtbCBtc2dUcmFuc2Zvcm1lZCB9PC9wPlxuXHRcdFx0XHRcdHsjaWYgb3ZlcnJpZGVDbGlja1RleHRFcnJvciAmJiBvYmoudHlwZSA9PSBNZXNzYWdlVHlwZXMuZXJyb3IgfVxuXHRcdFx0XHRcdFx0PGk+e292ZXJyaWRlQ2xpY2tUZXh0RXJyb3J9PC9pPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9lYWNofVxuXHRcdDwvZGl2PiBcblx0ey9pZn1cbjwvZGl2PiIsImltcG9ydCB7IElBUEkgfSBmcm9tIFwic3JjL01vZHVsZXMvYXBpL0lBUElcIjtcbmltcG9ydCB7IFN5c3RlbVByZXZpZXcgfSBmcm9tIFx0XHRcdFx0XCIuLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9jb3JlL21vZGVsL3N5c3RlbVByZXZpZXdcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFx0XCIuLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyL2luZGV4XCI7XG5pbXBvcnQgeyBVSVN5c3RlbSB9IGZyb20gXCIuLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyL1VJQ29tcG9zaXRpb24vVUlTeXN0ZW1cIjtcblxuZXhwb3J0IGNsYXNzIExheW91dDAxQ29udGV4dHtcblx0cHVibGljIGFjdGl2ZVN5c3RlbSBcdDogVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZztcblx0cHVibGljIGF2YWlsYWJsZVByZXZpZXdzOlN5c3RlbVByZXZpZXdbXTtcblx0cHVibGljIEFQSSA6IElBUEk7XG5cdHB1YmxpYyBtYWluQXBwQ29udGFpbmVyIDogSFRNTEVsZW1lbnQ7XG5cblx0cHVibGljIHVpU3lzdGVtIDogVUlTeXN0ZW07XG5cdHB1YmxpYyB1aUd1aWQgOiBzdHJpbmc7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtleU1hbmFnZXJJbnN0YW5jZSA9IGV4cG9ydHMuS2V5TWFuYWdlciA9IHZvaWQgMDtcbnZhciBLZXlNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMua2V5Q291bnRlciA9IDA7XG4gICAgfVxuICAgIEtleU1hbmFnZXIucHJvdG90eXBlLmdldE5ld0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMua2V5Q291bnRlcisrO1xuICAgICAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuICAgIHJldHVybiBLZXlNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuS2V5TWFuYWdlciA9IEtleU1hbmFnZXI7XG5leHBvcnRzLmtleU1hbmFnZXJJbnN0YW5jZSA9IG5ldyBLZXlNYW5hZ2VyKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3T3V0cHV0SGFuZGxlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG5ld091dHB1dEhhbmRsZXIoKSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICAgIG91dEVycm9yOiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgIH0sXG4gICAgICAgIG91dExvZzogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLm5ld091dHB1dEhhbmRsZXIgPSBuZXdPdXRwdXRIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFHcmFwaEl0ZW0gPSB2b2lkIDA7XG52YXIgS2V5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vS2V5TWFuYWdlclwiKTtcbnZhciBrZXlNYW5hZ2VyID0gbmV3IEtleU1hbmFnZXJfMS5LZXlNYW5hZ2VyKCk7XG52YXIgQUdyYXBoSXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBR3JhcGhJdGVtKG5hbWUsIGtleSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxuICAgICAgICBpZiAoa2V5ID09PSB2b2lkIDApIHsga2V5ID0gJyc7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5ICsga2V5TWFuYWdlci5nZXROZXdLZXkoKTtcbiAgICB9XG4gICAgQUdyYXBoSXRlbS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9O1xuICAgIEFHcmFwaEl0ZW0ucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH07XG4gICAgQUdyYXBoSXRlbS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xuICAgIH07XG4gICAgcmV0dXJuIEFHcmFwaEl0ZW07XG59KCkpO1xuZXhwb3J0cy5BR3JhcGhJdGVtID0gQUdyYXBoSXRlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hcm9iQ29sbGVjdGlvbiA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEFHcmFwaEl0ZW1fMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0aW9ucy9BR3JhcGhJdGVtXCIpO1xudmFyIEdyb2JDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEdyb2JDb2xsZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb2JDb2xsZWN0aW9uKG5hbWUsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCAnQycpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5vZGVzX25hbWVzID0ge307XG4gICAgICAgIF90aGlzLnVwZGF0ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdyb2JDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROb2RlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzX25hbWVzKTtcbiAgICB9O1xuICAgIEdyb2JDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5ub2Rlc19uYW1lcyk7XG4gICAgfTtcbiAgICBHcm9iQ29sbGVjdGlvbi5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzX25hbWVzW25hbWVdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm5vZGVzX25hbWVzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vZGVzX25hbWVzW25vZGUuZ2V0TmFtZSgpXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2F0dGVtcHRlZCB0byBkZWxldGUgbm9kZSBcIk51bGxcIiAnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IG5vZGUuZ2V0TmFtZSgpO1xuICAgICAgICB2YXIgbiA9IHRoaXMubm9kZXNfbmFtZXNbbmFtZV07XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbi5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzX25hbWVzW25hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc19uYW1lc1tuYW1lXSA9PSBudWxsO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZV9ub2RlX25hbWUgPSBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICBpZiAob2xkTmFtZSA9PSBuZXdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5vZGVzX25hbWVzW29sZE5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2Rlc19uYW1lc1tvbGROYW1lXS5zZXROYW1lKG5ld05hbWUsIHRydWUpO1xuICAgICAgICB0aGlzLm5vZGVzX25hbWVzW25ld05hbWVdID0gdGhpcy5ub2Rlc19uYW1lc1tvbGROYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNfbmFtZXNbb2xkTmFtZV07XG4gICAgfTtcbiAgICBHcm9iQ29sbGVjdGlvbi5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBvbGRuYW1lID0gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIGlmIChvbGRuYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldE5hbWUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlX2NvbGxlY3Rpb25fbmFtZShvbGRuYW1lLCBuYW1lKTtcbiAgICAgICAgdGhpcy51cGRhdGVMb2NhdGlvbih0aGlzLnBhcmVudCk7XG4gICAgfTtcbiAgICBHcm9iQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubm9kZXNfbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5ub2Rlc19uYW1lc1tuYW1lXTtcbiAgICAgICAgICAgIGN1cnIudXBkYXRlTG9jYXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXROb2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxVcGRhdGVMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEdyb2JDb2xsZWN0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubm9kZXNfbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5ub2Rlc19uYW1lc1tuYW1lXTtcbiAgICAgICAgICAgIGN1cnIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNfbmFtZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldENvbGxlY3Rpb25UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xUeXBlO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLnNldENvbGxlY3Rpb25UeXBlID0gZnVuY3Rpb24gKGNvbFR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sVHlwZSAhPSBudWxsICYmIGNvbFR5cGUgIT0gY29sVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmllZCB0byBjb252ZXJ0IGEgZ3JvdXAgdHlwZSBhZnRlciBTZXR0aW5nLiBEZW5pZWQgQWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xUeXBlID0gY29sVHlwZTtcbiAgICB9O1xuICAgIEdyb2JDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycygpO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLmNhbGxVcGRhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIChPYmplY3Qua2V5cyh0aGlzLnVwZGF0ZUxpc3RlbmVycykpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlTGlzdGVuZXJzW2tleV0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZFVwZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGtleSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlTGlzdGVuZXJzW2tleV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmllZCB0byBhZGQgdXBkYXRlbGlzdGVuZXIgdG8gbm9kZSB3aXRoIGtleTonICsga2V5ICsgJy4gYnV0IHRoZXJlIHdhcyBhbHJlYWR5IGEgbGlzdGVuZXIgdXNpbmcgdGhhdCBrZXknKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBHcm9iQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVXBkYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldO1xuICAgIH07XG4gICAgR3JvYkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUFsbFVwZGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBHcm9iQ29sbGVjdGlvbjtcbn0oQUdyYXBoSXRlbV8xLkFHcmFwaEl0ZW0pKTtcbmV4cG9ydHMuR3JvYkNvbGxlY3Rpb24gPSBHcm9iQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hcm9iR3JvdXAgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBBR3JhcGhJdGVtXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdGlvbnMvQUdyYXBoSXRlbVwiKTtcbnZhciBHcm9iR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoR3JvYkdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb2JHcm91cChuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgJ0cnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2xsZWN0aW9uc19uYW1lcyA9IHt9O1xuICAgICAgICBfdGhpcy51cGRhdGVMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHcm9iR3JvdXAucHJvdG90eXBlLmdldENvbGxlY3Rpb25zTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbGxlY3Rpb25zX25hbWVzKTtcbiAgICB9O1xuICAgIEdyb2JHcm91cC5wcm90b3R5cGUuaGFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zX25hbWVzW25hbWVdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS5nZXRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbbmFtZV07XG4gICAgfTtcbiAgICBHcm9iR3JvdXAucHJvdG90eXBlLmFkZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbY29sbGVjdGlvbi5nZXROYW1lKCldID0gY29sbGVjdGlvbjtcbiAgICAgICAgY29sbGVjdGlvbi5zZXRDb2xsZWN0aW9uVHlwZSh0aGlzLmdyb3VwVHlwZSk7XG4gICAgICAgIHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEdyb2JHcm91cC5wcm90b3R5cGUucmVtb3ZlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBuYW1lID0gY29sbGVjdGlvbi5nZXROYW1lKCk7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb2xsZWN0aW9uc19uYW1lc1tuYW1lXTtcbiAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb2xsZWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbbmFtZV07XG4gICAgICAgIHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uc19uYW1lc1tuYW1lXSA9PSBudWxsO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS51cGRhdGVfY29sbGVjdGlvbl9uYW1lID0gZnVuY3Rpb24gKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25zX25hbWVzW29sZE5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25zX25hbWVzW25ld05hbWVdID0gdGhpcy5jb2xsZWN0aW9uc19uYW1lc1tvbGROYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbb2xkTmFtZV07XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbbmV3TmFtZV0uc2V0TmFtZShuZXdOYW1lKTtcbiAgICB9O1xuICAgIEdyb2JHcm91cC5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0TmFtZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdGhpcy5jb2xsZWN0aW9uc19uYW1lcykge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSB0aGlzLmNvbGxlY3Rpb25zX25hbWVzW25hbWVfMV07XG4gICAgICAgICAgICBjdXJyLnVwZGF0ZUxvY2F0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycygpO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuY29sbGVjdGlvbnNfbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5jb2xsZWN0aW9uc19uYW1lc1tuYW1lXTtcbiAgICAgICAgICAgIGN1cnIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNfbmFtZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgfTtcbiAgICBHcm9iR3JvdXAucHJvdG90eXBlLmdldEdyb3VwVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBUeXBlO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS5zZXRHcm91cFR5cGUgPSBmdW5jdGlvbiAoZ3JvdXBUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwVHlwZSAhPSBudWxsICYmIGdyb3VwVHlwZSAhPSBncm91cFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJpZWQgdG8gY29udmVydCBhIGdyb3VwIHR5cGUgYWZ0ZXIgU2V0dGluZy4gRGVuaWVkIEFjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JvdXBUeXBlID0gZ3JvdXBUeXBlO1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuY29sbGVjdGlvbnNfbmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgY29sLnNldENvbGxlY3Rpb25UeXBlKGdyb3VwVHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycygpO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS5jYWxsVXBkYXRlTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAoT2JqZWN0LmtleXModGhpcy51cGRhdGVMaXN0ZW5lcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEdyb2JHcm91cC5wcm90b3R5cGUuYWRkVXBkYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoa2V5LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVMaXN0ZW5lcnNba2V5XSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyaWVkIHRvIGFkZCB1cGRhdGVsaXN0ZW5lciB0byBub2RlIHdpdGgga2V5OicgKyBrZXkgKyAnLiBidXQgdGhlcmUgd2FzIGFscmVhZHkgYSBsaXN0ZW5lciB1c2luZyB0aGF0IGtleScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzW2tleV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIEdyb2JHcm91cC5wcm90b3R5cGUucmVtb3ZlVXBkYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldO1xuICAgIH07XG4gICAgR3JvYkdyb3VwLnByb3RvdHlwZS5yZW1vdmVBbGxVcGRhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzID0ge307XG4gICAgfTtcbiAgICByZXR1cm4gR3JvYkdyb3VwO1xufShBR3JhcGhJdGVtXzEuQUdyYXBoSXRlbSkpO1xuZXhwb3J0cy5Hcm9iR3JvdXAgPSBHcm9iR3JvdXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwgPSB2b2lkIDA7XG52YXIgR3JvYkNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9Hcm9iQ29sbGVjdGlvblwiKTtcbnZhciBHcm9iR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi9Hcm9iR3JvdXBcIik7XG52YXIgSU91dHB1dEhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdGlvbnMvSU91dHB1dEhhbmRsZXJcIik7XG4vKipcbiogYSBnZW5lcmFsIGFuZCBmbGV4aWJsZSBpbXBsZW1lbnRhdGlvbiBvZiBUVFJQRyBzeXN0ZW0uIGl0IGZvY3Vzc2VzIG9uIG5vdCBkaXNrcmltaW5hdGlvbiBvciBzb3J0aW5nIGRhdGEuXG4qIHNpbXBseSBoYXZpbmcgbG9naWMgdGhhdCBpcyB0aGUgc2FtZSBmb3IgZXZlcnl0aGluZy5cbiovXG52YXIgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIH1cbiAgICBUVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbC5wcm90b3R5cGUuc2V0T3V0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dCA/IG91dCA6ICgwLCBJT3V0cHV0SGFuZGxlcl8xLm5ld091dHB1dEhhbmRsZXIpKCk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbC5wcm90b3R5cGUuX2RlbGV0ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBnXzEgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmICghZ18xKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGdyb3VwID0gZ18xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBncm91cC5nZXROYW1lKCk7XG4gICAgICAgIHZhciBnID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIGlmICghZykge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoJ3RyaWVkIHRvIGRlbGV0ZSBub24gZXhpc3RhbnQgZ3JvdXAnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBncm91cC5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsLnByb3RvdHlwZS5fY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5faGFzR3JvdXAobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKCdhdHRlbXB0ZWQgdG8gYWRkIG5ldyBncm91cCwgaG93ZXZlciBncm91cCBhbHJlYWR5IGV4aXN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncCA9IG5ldyBHcm9iR3JvdXBfMS5Hcm9iR3JvdXAobmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGF0YVtncC5nZXROYW1lKCldID0gZ3A7XG4gICAgICAgIHJldHVybiBncDtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsLnByb3RvdHlwZS5faGFzR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2tleV0uZ2V0TmFtZSgpID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbC5wcm90b3R5cGUuX2dldEdyb3VwX2tleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwucHJvdG90eXBlLmdldEdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtrZXldLmdldE5hbWUoKSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwucHJvdG90eXBlLl9kZWxldGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcInRyaWVkIHRvIGRlbGV0ZSBjb2xsZWN0aW9uLCBidXQgc3VwcGxpZWQgY29sbGVjdGlvbiB3YXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBjb2xsZWN0aW9uLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnJlbW92ZUNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZ3JvdXAsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJ0cmllZCB0byBjcmVhdGUgY29sbGVjdGlvbiwgYnV0IHN1cHBsaWVkIGdyb3VwIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cC5oYXNDb2xsZWN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIkNvbGxlY3Rpb24gYnkgdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RlZCBpbiAnXCIuY29uY2F0KGdyb3VwLmdldE5hbWUoKSwgXCInXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IEdyb2JDb2xsZWN0aW9uXzEuR3JvYkNvbGxlY3Rpb24obmFtZSwgZ3JvdXApO1xuICAgICAgICBncm91cC5hZGRDb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsLnByb3RvdHlwZS5fQWRkTm9kZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBub2RlKSB7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJ0cmllZCB0byBhZGQgbm9kZSwgYnV0IHN1cHBsaWVkIGNvbGxlY3Rpb24gd2FzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbGxlY3Rpb24uZ2V0Q29sbGVjdGlvblR5cGUoKSAhPSAnTm9kZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gQWRkIE5vZGUgdG8gTm9uIE5vZGUgQ29sbGVjdG9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uYWRkTm9kZShub2RlKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsLnByb3RvdHlwZS5fZGVsZXRlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBjb2wgPSBub2RlLnBhcmVudDtcbiAgICAgICAgdmFyIHIgPSBjb2wucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgbm9kZS5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwucHJvdG90eXBlLl9hZGROb2RlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlLCBkZXApIHtcbiAgICAgICAgdmFyIG8xID0gbm9kZS5hZGREZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIHZhciBvMiA9IGRlcC5hZGREZXBlbmRlbnQobm9kZSk7XG4gICAgICAgIGlmICghKG8xICYmIG8yKSkge1xuICAgICAgICAgICAgaWYgKCFvMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiQ291bGQgbm90IGFkZCBkZXBlbmRlbmN5IFwiLmNvbmNhdChkZXAuZ2V0TmFtZSgpLCBcIiwgb24gbm9kZSBcIikuY29uY2F0KG5vZGUuZ2V0TmFtZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW8yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJDb3VsZCBub3QgYWRkIGRlcGVuZGVudCBcIi5jb25jYXQobm9kZS5nZXROYW1lKCksIFwiLCBvbiBub2RlIFwiKS5jb25jYXQoZGVwLmdldE5hbWUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwucHJvdG90eXBlLl9yZW1vdmVOb2RlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlLCBkZXApIHtcbiAgICAgICAgdmFyIG8xID0gbm9kZS5yZW1vdmVEZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIHZhciBvMiA9IGRlcC5yZW1vdmVEZXBlbmRlbnQobm9kZSk7XG4gICAgICAgIGlmICghKG8xICYmIG8yKSkge1xuICAgICAgICAgICAgaWYgKCFvMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiQ291bGQgbm90IHJlbW92ZSBkZXBlbmRlbmN5IFwiLmNvbmNhdChkZXAuZ2V0TmFtZSgpLCBcIiwgb24gbm9kZSBcIikuY29uY2F0KG5vZGUuZ2V0TmFtZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW8yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJDb3VsZCBub3QgcmVtb3ZlIGRlcGVuZGVudCBcIi5jb25jYXQobm9kZS5nZXROYW1lKCksIFwiLCBvbiBub2RlIFwiKS5jb25jYXQoZGVwLmdldE5hbWUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwucHJvdG90eXBlLl9hZGRUYWJsZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCB0YWJsZSkge1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwidHJpZWQgdG8gYWRkIG5vZGUsIGJ1dCBzdXBwbGllZCBjb2xsZWN0aW9uIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmdldENvbGxlY3Rpb25UeXBlKCkgIT0gJ1RhYmxlJykge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoJ1RyaWVkIHRvIEFkZCB0YWJsZSB0byBOb24gVGFibGUgQ29sbGVjdG9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uYWRkTm9kZSh0YWJsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWw7XG59KCkpO1xuZXhwb3J0cy5UVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbCA9IFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRUUlBHU3lzdGVtR3JhcGhNb2RlbCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIElPdXRwdXRIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3Rpb25zL0lPdXRwdXRIYW5kbGVyXCIpO1xudmFyIFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsXzEgPSByZXF1aXJlKFwiLi9UVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbFwiKTtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIGluZGV4XzIgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgZGVyaXZlZCA9ICdkZXJpdmVkJztcbnZhciBmaXhlZCA9ICdmaXhlZCc7XG4vKipcbiAqICBoYW5kbGVzIE1vZGVsIG9wZXJhdGlvbnMgYW5kIERhdGEgQ29udGFpbm1lbnQsXG4gKiBFbnN1cmVzIHRoYXQgZGF0YSBpcyBtYWludGFpbmVkLCBhcyB3ZWxsIGFzIGdyYXBobGlua3NcbiovXG52YXIgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRUUlBHU3lzdGVtR3JhcGhNb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUVFJQR1N5c3RlbUdyYXBoTW9kZWwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNldE91dCgoMCwgSU91dHB1dEhhbmRsZXJfMS5uZXdPdXRwdXRIYW5kbGVyKSgpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvL1RPRE8gOiBmaW5kIGJldHRlciBzb2x1dGlvbiB0aGFuIHRoaXMuXG4gICAgLy8gciBcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmluaXRBc05ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlR3JvdXAoJ2ZpeGVkJyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUdyb3VwKCdkZXJpdmVkJyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUdyb3VwKCdleHRyYScpO1xuICAgICAgICB0aGlzLmRhdGFbJ2ZpeGVkJ10uc2V0R3JvdXBUeXBlKCdOb2RlJyk7XG4gICAgICAgIHRoaXMuZGF0YVsnZGVyaXZlZCddLnNldEdyb3VwVHlwZSgnTm9kZScpO1xuICAgICAgICB0aGlzLmRhdGFbJ2V4dHJhJ10uc2V0R3JvdXBUeXBlKCdUYWJsZScpO1xuICAgIH07XG4gICAgLy8vIENyZWF0ZSBTdGF0ZW1lbnRzIFxuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChncm91cCwgbmFtZSkge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCBncm91cCBleGlzdHMsIHNhbWUgd2F5IGFzIHRoZSBvdGhlcnNcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNHcm91cChncm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiTm8gZ3JvdXAgZXhpc3RlZCBieSBuYW1lIFwiLmNvbmNhdChncm91cCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgaWYgKCFncnApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUNvbGxlY3Rpb24oZ3JwLCBuYW1lKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlRGVyaXZlZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKGRlcml2ZWQsIG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5jcmVhdGVGaXhlZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKGZpeGVkLCBuYW1lKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChncm91cCwgY29sLCBuYW1lKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGdyb3VwIGV4aXN0cywgc2FtZSB3YXkgYXMgdGhlIG90aGVyc1xuICAgICAgICBpZiAoIXRoaXMuX2hhc0dyb3VwKGdyb3VwKSkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJObyBncm91cCBleGlzdGVkIGJ5IG5hbWUgXCIuY29uY2F0KGdyb3VwKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNOb2RlKGdyb3VwLCBjb2wsIG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vZGUgYnkgdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RlZCBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGaXhlZE5vZGUoY29sLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cCA9PSAnZGVyaXZlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURlcml2ZWROb2RlKGNvbCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmNyZWF0ZURlcml2ZWROb2RlID0gZnVuY3Rpb24gKGNvbCwgbmFtZSkge1xuICAgICAgICB2YXIgY29sTmFtZSA9IGNvbDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2wgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGRlcml2ZWQpO1xuICAgICAgICAgICAgaWYgKCFncnApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sTmFtZSA9IGNvbC5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2wpIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiTm8gRGVyaXZlZCBjb2xsZWN0aW9uIGZvdW5kIGJ5IG5hbWU6IFwiLmNvbmNhdChjb2xOYW1lLCBcIiBcIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgaW5kZXhfMi5Hcm9iRGVyaXZlZE5vZGUobmFtZSwgY29sKTtcbiAgICAgICAgY29sLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5jcmVhdGVGaXhlZE5vZGUgPSBmdW5jdGlvbiAoY29sLCBuYW1lKSB7XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGZpeGVkKTtcbiAgICAgICAgaWYgKCFncnApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGNvbE5hbWUgPSBjb2w7XG4gICAgICAgIGlmICh0eXBlb2YgY29sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29sTmFtZSA9IGNvbC5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihjb2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJObyBGaXhlZCBjb2xsZWN0aW9uIGZvdW5kIGJ5IG5hbWU6IFwiLmNvbmNhdChjb2xOYW1lLCBcIiBcIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgaW5kZXhfMS5Hcm9iRml4ZWROb2RlKG5hbWUsIGNvbCk7XG4gICAgICAgIGNvbC5hZGROb2RlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8vIGhhcyBTdGF0ZW1lbnRzIFxuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuaGFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChncm91cCwgbmFtZSkge1xuICAgICAgICB2YXIgZ3JwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JwLmhhc0NvbGxlY3Rpb24obmFtZSk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmhhc0Rlcml2ZWRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29sbGVjdGlvbihkZXJpdmVkLCBuYW1lKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuaGFzRml4ZWRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29sbGVjdGlvbihmaXhlZCwgbmFtZSk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmhhc05vZGUgPSBmdW5jdGlvbiAoZ3JvdXAsIGNvbCwgbmFtZSkge1xuICAgICAgICB2YXIgZ3JwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2NvbCA9IGNvbDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBfY29sID0gdGhpcy5nZXRDb2xsZWN0aW9uKGdycCwgY29sKTtcbiAgICAgICAgICAgIGlmICghX2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBcIi5jb25jYXQoZ3JvdXAsIFwiIGNvbGxlY3Rpb24gXCIpLmNvbmNhdChuYW1lLCBcIiwgYnV0IG5vIGNvbGxlY3Rpb24gZXhpc3RlZCBieSB0aGF0IG5hbWVcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2NvbC5oYXNOb2RlKG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5oYXNEZXJpdmVkTm9kZSA9IGZ1bmN0aW9uIChjb2wsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTm9kZShkZXJpdmVkLCBjb2wsIG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5oYXNGaXhlZE5vZGUgPSBmdW5jdGlvbiAoY29sLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc05vZGUoZml4ZWQsIGNvbCwgbmFtZSk7XG4gICAgfTtcbiAgICAvLyBnZXQgU3RhdGVtZW50cyBcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmdldENvbGxlY3Rpb25OYW1lcyA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgZ3JwO1xuICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdycCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JwLmdldENvbGxlY3Rpb25zTmFtZXMoKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIChncm91cCwgbmFtZSkge1xuICAgICAgICB2YXIgZ3JwO1xuICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdycCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihuYW1lKTtcbiAgICAgICAgaWYgKCFjb2wpIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBcIi5jb25jYXQoZ3JvdXAsIFwiIGNvbGxlY3Rpb24gXCIpLmNvbmNhdChuYW1lLCBcIiwgYnV0IG5vIGNvbGxlY3Rpb24gZXhpc3RlZCBieSB0aGF0IG5hbWVcIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbDtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0RGVyaXZlZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xsZWN0aW9uKGRlcml2ZWQsIG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRGaXhlZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xsZWN0aW9uKGZpeGVkLCBuYW1lKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uIChncm91cCwgY29sLCBuYW1lKSB7XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgaWYgKCFncnApIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiTm8gZ3JvdXAgZXhpc3RlZCBieSBuYW1lIFwiLmNvbmNhdChncm91cCkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIG91dHB1dFxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24sIGp1c3QgZ2V0IHRoZSBub2RlLlxuICAgICAgICBpZiAodHlwZW9mIGNvbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb2wuZ2V0Tm9kZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb2wgaXMgYSBzdHJpbmcsIHRoZW4gbGV0IGl0IGJlIHNlZW4gYXMgdGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24sIGFuZCBmZXRjaCBpdC5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXQgZGF0YVxuICAgICAgICAgICAgdmFyIGNvbE5hbWUgPSBjb2w7XG4gICAgICAgICAgICBjb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihjb2wpO1xuICAgICAgICAgICAgLy8gZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBcIi5jb25jYXQoZ3JvdXAsIFwiIGNvbGxlY3Rpb24gXCIpLmNvbmNhdChjb2xOYW1lLCBcIiwgYnV0IGRpZCBub3QgZXhpc3RcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmaW5lZCBvdXRwdXRcbiAgICAgICAgICAgIG5vZGUgPSBjb2wuZ2V0Tm9kZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlcnJvciBoYW5kbGluZ1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBcIi5jb25jYXQoZ3JvdXAsIFwiLlwiKS5jb25jYXQoY29sLmdldE5hbWUoKSwgXCIgTm9kZSBcIikuY29uY2F0KG5hbWUsIFwiLCBidXQgZGlkIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0RGVyaXZlZE5vZGUgPSBmdW5jdGlvbiAoY29sLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5vZGUoZGVyaXZlZCwgY29sLCBuYW1lKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Rml4ZWROb2RlID0gZnVuY3Rpb24gKGNvbCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROb2RlKGZpeGVkLCBjb2wsIG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5nZXROb2RlTmFtZXMgPSBmdW5jdGlvbiAoZ3JvdXAsIGNvbCkge1xuICAgICAgICB2YXIgZ3JwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JvdXApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfY29sO1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF9jb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2NvbCA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2NvbC5nZXROb2RlTmFtZXMoKTtcbiAgICB9O1xuICAgIC8vIGRlbGV0ZSBTdGF0ZW1lbnRzIFxuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuX2RlbGV0ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZ3JvdXA7XG4gICAgICAgICAgICBncm91cCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKCdObyBDb2xsZWN0aW9uIGJ5IG5hbWUgJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9kZWxldGVHcm91cC5jYWxsKHRoaXMsIGdyb3VwKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZGVsZXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChncm91cCwgY29sKSB7XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgaWYgKCFncnApIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiTm8gZ3JvdXAgZXhpc3RlZCBieSBuYW1lIFwiLmNvbmNhdChncm91cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29sID1cbiAgICAgICAgICAgICAgICBjb2wgPSBncnAuZ2V0Q29sbGVjdGlvbihjb2wpO1xuICAgICAgICAgICAgaWYgKCFjb2wpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxldGVDb2xsZWN0aW9uKGNvbCk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmRlbGV0ZURlcml2ZWRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVDb2xsZWN0aW9uKGRlcml2ZWQsIGNvbCk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmRlbGV0ZUZpeGVkQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlQ29sbGVjdGlvbihmaXhlZCwgY29sKTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuZGVsZXRlTm9kZSA9IGZ1bmN0aW9uIChncm91cCwgY29sLCBuYW1lKSB7XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgaWYgKCFncnApIHtcbiAgICAgICAgICAgIHRoaXMub3V0Lm91dEVycm9yKFwiTm8gZ3JvdXAgZXhpc3RlZCBieSBuYW1lIFwiLmNvbmNhdChncm91cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29sID0gZ3JwLmdldENvbGxlY3Rpb24oY29sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IFwiLmNvbmNhdChncm91cCwgXCIgY29sbGVjdGlvbiBcIikuY29uY2F0KG5hbWUsIFwiLCBidXQgbm8gY29sbGVjdGlvbiBleGlzdGVkIGJ5IHRoYXQgbmFtZVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBjb2wuZ2V0Tm9kZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIGNvbC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5kZWxldGVEZXJpdmVkTm9kZSA9IGZ1bmN0aW9uIChjb2wsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlTm9kZShkZXJpdmVkLCBjb2wsIG5hbWUpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5kZWxldGVGaXhlZE5vZGUgPSBmdW5jdGlvbiAoY29sLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZU5vZGUoZml4ZWQsIGNvbCwgbmFtZSk7XG4gICAgfTtcbiAgICAvLyBSZW5hbWluZyBmdW5jdGlvbnNcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLnJlbmFtZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZ3JvdXAsIGNvbCwgbmV3TmFtZSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IGdyb3VwIGV4aXN0cywgYW5kIGdldCB0aGUgdmFsdWVzLiBcbiAgICAgICAgdmFyIGdycDtcbiAgICAgICAgdmFyIGdycE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGdycE5hbWUgPSBncm91cDtcbiAgICAgICAgICAgIGdycCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JwTmFtZSA9IGdyb3VwLmdldE5hbWUoKTtcbiAgICAgICAgICAgIGdycCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JwTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBDb2xsZWN0aW9uIGV4aXN0cyBhbmQgZ2V0IHRoZSB2YWx1ZXMgXG4gICAgICAgIHZhciBjb2xOYW1lID0gY29sO1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29sTmFtZSA9IGNvbDtcbiAgICAgICAgICAgIGNvbCA9IGdycC5nZXRDb2xsZWN0aW9uKGNvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xOYW1lID0gY29sLmdldE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJObyBDb2xsZWN0aW9uIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoY29sTmFtZSwgXCIgaW4gXCIpLmNvbmNhdChncnBOYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBuZXcgTmFtZSBjb2xsZWN0aW9uIGRvZXNlbnQgYWxyZWFkeSBleGlzdC5cbiAgICAgICAgaWYgKGdycC5nZXRDb2xsZWN0aW9uKG5ld05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIkNvbGxlY3Rpb24gYWxyZWFkeSBleGlzdGVkIGJ5IG5hbWUgXCIuY29uY2F0KG5ld05hbWUsIFwiIGluIFwiKS5jb25jYXQoZ3JwTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIFxuICAgICAgICByZXR1cm4gY29sLnNldE5hbWUobmV3TmFtZSk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLnJlbmFtZUl0ZW0gPSBmdW5jdGlvbiAoZ3JvdXAsIGNvbCwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IGdyb3VwIGV4aXN0cywgYW5kIGdldCB0aGUgdmFsdWVzLiBcbiAgICAgICAgdmFyIGdycDtcbiAgICAgICAgdmFyIGdycE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGdycE5hbWUgPSBncm91cDtcbiAgICAgICAgICAgIGdycCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JwTmFtZSA9IGdyb3VwLmdldE5hbWUoKTtcbiAgICAgICAgICAgIGdycCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JwKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIGdyb3VwIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoZ3JwTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBDb2xsZWN0aW9uIGV4aXN0cyBhbmQgZ2V0IHRoZSB2YWx1ZXMgXG4gICAgICAgIHZhciBjb2xOYW1lID0gY29sO1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29sTmFtZSA9IGNvbDtcbiAgICAgICAgICAgIGNvbCA9IGdycC5nZXRDb2xsZWN0aW9uKGNvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xOYW1lID0gY29sLmdldE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgdGhpcy5vdXQub3V0RXJyb3IoXCJObyBDb2xsZWN0aW9uIGV4aXN0ZWQgYnkgbmFtZSBcIi5jb25jYXQoY29sTmFtZSwgXCIgaW4gXCIpLmNvbmNhdChncnBOYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBOb2RlIGV4aXN0c1xuICAgICAgICBpZiAoIWNvbC5oYXNOb2RlKG9sZE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dC5vdXRFcnJvcihcIk5vIEl0ZW0gZXhpc3RlZCBieSBuYW1lIFwiLmNvbmNhdChvbGROYW1lLCBcIiBpbiBcIikuY29uY2F0KGdycE5hbWUsIFwiLlwiKS5jb25jYXQoY29sTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIFxuICAgICAgICByZXR1cm4gY29sLnVwZGF0ZV9ub2RlX25hbWUob2xkTmFtZSwgbmV3TmFtZSk7XG4gICAgfTtcbiAgICAvLyBWYWxpZGF0aW9uIEZ1bmN0aW9uc1xuICAgIFRUUlBHU3lzdGVtR3JhcGhNb2RlbC5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIChlcnJvck1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2VzID09PSB2b2lkIDApIHsgZXJyb3JNZXNzYWdlcyA9IFtdOyB9XG4gICAgICAgIHZhciBrZXlfZ3JvdXAsIGtleV9jb2xsZWN0aW9uLCBrZXlfbm9kZTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lcywgbm9kZU5hbWVzO1xuICAgICAgICB2YXIgZ3JvdXAsIGNvbGxlY3Rpb24sIG5vZGU7XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICAvLyBmb3JlYWNoIGdyb3VwLCBnZXQgZG8gdGhpcyBmb3IgYWxsIGNvbGxlY3Rpb25zLlxuICAgICAgICBmb3IgKGtleV9ncm91cCBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5kYXRhW2tleV9ncm91cF07XG4gICAgICAgICAgICBjb2xsZWN0aW9uTmFtZXMgPSBncm91cC5nZXRDb2xsZWN0aW9uc05hbWVzKCk7XG4gICAgICAgICAgICAvLyBmb3JhY2ggY29sbGVjdGlvbiBkbyB0aGlzIGZvciBhbGwgbm9kZXMgXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbGxlY3Rpb25OYW1lcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xJbmRleCA9IGM7XG4gICAgICAgICAgICAgICAgLy9mb3IgKCBjb25zdCBjb2xJbmRleCBpbiBncm91cC5nZXRDb2xsZWN0aW9uc05hbWVzKCkgKXtcbiAgICAgICAgICAgICAgICBrZXlfY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25OYW1lc1tjb2xJbmRleF07XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGdyb3VwLmdldENvbGxlY3Rpb24oa2V5X2NvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lcyA9IGNvbGxlY3Rpb24uZ2V0Tm9kZU5hbWVzKCk7XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBmb3IgZWFjaCBub2RlLiBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVOYW1lcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbjtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgKCBjb25zdCBub2RlSW5kZXggaW4gbm9kZU5hbWVzICl7XG4gICAgICAgICAgICAgICAgICAgIGtleV9ub2RlID0gbm9kZU5hbWVzW25vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjb2xsZWN0aW9uLmdldE5vZGUoa2V5X25vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gbm9kZS5pc1ZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiXCIuY29uY2F0KGtleV9ncm91cCwgXCIuXCIpLmNvbmNhdChrZXlfY29sbGVjdGlvbiwgXCIuXCIpLmNvbmNhdChrZXlfbm9kZSwgXCIgd2FzIGludmFsaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtrZXlfZ3JvdXAsIGtleV9jb2xsZWN0aW9uLCBrZXlfbm9kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goeyBtc2c6IG1zZywga2V5OiBrZXlzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2VzLmxlbmd0aCA9PSAwO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBncnAgPSB0aGlzLmRhdGFbbmFtZV07XG4gICAgICAgIHJldHVybiBncnAgIT09IG51bGwgJiYgZ3JwICE9PSB2b2lkIDAgPyBncnAgOiBudWxsO1xuICAgIH07XG4gICAgLy8gYWRkIGRlcGVuZGVuY3lcbiAgICBUVFJQR1N5c3RlbUdyYXBoTW9kZWwucHJvdG90eXBlLmFkZE5vZGVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG5vZGUsIGRlcCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlRGVwZW5kZW5jeShub2RlLCBkZXApO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsLnByb3RvdHlwZS5yZW1vdmVOb2RlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlLCBkZXApIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTm9kZURlcGVuZGVuY3kobm9kZSwgZGVwKTtcbiAgICB9O1xuICAgIHJldHVybiBUVFJQR1N5c3RlbUdyYXBoTW9kZWw7XG59KFRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsXzEuVFRSUEdTeXN0ZW1HcmFwaEFic3RyYWN0TW9kZWwpKTtcbmV4cG9ydHMuVFRSUEdTeXN0ZW1HcmFwaE1vZGVsID0gVFRSUEdTeXN0ZW1HcmFwaE1vZGVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyb2JBbGdvcml0aG1zID0gdm9pZCAwO1xudmFyIEdyb2JBbGdvcml0aG1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb2JBbGdvcml0aG1zKCkge1xuICAgIH1cbiAgICBHcm9iQWxnb3JpdGhtcy5UYXJqQWxnbyA9IGZ1bmN0aW9uIChub2Rlcywgc3Ryb25nQ29tcG9uZW50cykge1xuICAgICAgICAvKlxuICAgICAgICAgICAgY29uc3QgZGVyaXZlZCA9ICdkZXJpdmVkJztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUdyYXBoKCAgKSA6IFJlY29yZDxzdHJpbmcsZGVwZW5kZW5jeU5vZGU+e1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRpbmcgdGhlIGRhdGEgd2UgbmVlZCB0byB3b3JrIHdpdGguXG4gICAgICAgICAgICAgICAgLy8gZmlyc3Qgd2UgR2V0IHRoZSBub2RlcyB3aXRoIHRoZWlyIG5hbWVzXG4gICAgICAgICAgICAgICAgdmFyIGdyYXBoIFx0XHQ6IFJlY29yZDxzdHJpbmcsQUdyb2JOb2RlPGFueT4+ID0ge307XG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKCBDb2xsZWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgQ29sbGVjdGlvbi5kYXRhLmZvckVhY2goIHN0YXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke2Rlcml2ZWR9LiR7Q29sbGVjdGlvbi5uYW1lfS4ke3N0YXQubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBkZXBlbmRlbmN5Tm9kZSggbmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhbIG5hbWUgXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXZSBhZGQgdGhlIGRlcGVuZGVuY2llcyB0byB0aGUgbm9kZXMgYXMgb3V0Z29pbmcgZWRnZXMuXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgRG9pbmcgc28gd2hlbiB3ZSBmaW5kIGFuIGVkZ2UsIHdlIGFsc28gYWRkIGl0IGFzIGluZ29pbmcgdG8gaXRzIHRhcmdldC5cbiAgICAgICAgICAgICAgICBmb3IgKCBjb25zdCBrZXkgaW4gZ3JhcGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkaWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gaXRlbS5kYXRhLm1hcChwID0+IHAub3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMuZm9yRWFjaCggZWRnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBncmFwaFtlZGdlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoICF0YXJnZXQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG91dGdvaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlcGVuZGVuY2llcy5wdXNoKCB0YXJnZXQgKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaW5nb2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRlcGVuZGVudHMucHVzaChub2RlKTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBncmFwaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbmVlZCBhIGRpY3Rpb25hcnkgd2hlcmUgdGhlIG5hbWVzIG1hdGNoIHRoZSBuYW1lcyBpbiB0aGUgcG9pbnRlcnNcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBwb2ludGVycyBhcmUgdGhlIHJlZmVyZW5jZXMgdG8gb3VyIG9iamN0LlxuICAgICAgICAgICAgY29uc3QgZGljdDogUmVjb3JkPHN0cmluZywgSURlcml2ZWRTdGF0PFQ+PiA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBkYXRhLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRhdGFbY107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjb2xsZWN0aW9uLmRhdGEubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGNvbGxlY3Rpb24uZGF0YVtzXTtcbiAgICAgICAgICAgICAgICAgICAgZGljdFtgZGVyaXZlZC4ke2NvbGxlY3Rpb24ubmFtZX0uJHtzdGF0Lm5hbWV9YF1cdD0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ3JhcGg6IFJlY29yZDxzdHJpbmcsZGVwZW5kZW5jeU5vZGU+ICA9IGNyZWF0ZUdyYXBoKGRhdGEsZGljdCk7XG4gICAgICAgICovXG4gICAgICAgIGlmIChzdHJvbmdDb21wb25lbnRzID09PSB2b2lkIDApIHsgc3Ryb25nQ29tcG9uZW50cyA9IHt9OyB9XG4gICAgICAgIC8vICAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tICAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuICAgICAgICAvLyBUYXJqYW5zIEFsZ29yaXRobVxuICAgICAgICAvLyAgLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAgLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS1cbiAgICAgICAgLy8gd2UgdXNlIHRhcmphbnMgYWxnb3JpdGhtIHRvIGNvdW50IGlzbGFuZHMuIGxvb2sgZm9yIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKCBpbiB3aWNoIGNhc2UsIHdlIEVSUk9SIClcbiAgICAgICAgLy8gYW5kIGZvciB0aGlzLCB3ZWUgbmVlZCB0byBwcmVwYXJlIGEgcXVlLiB3ZSBhcmUgZ29pbmcgdG8gdXNlIGEgY29weSBvZiB0aGUgbm9kZSBjb2xsZWN0aW9uIHdlIGhhdmUuXG4gICAgICAgIHZhciBxdWUgPSBbXTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcXVlLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYWxnTGV2ZWwgPSBHcm9iQWxnb3JpdGhtcy5hbGdMZXZlbCsrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIC8vbGV0IGN5Y2xpY0NvdW50ZXIgPSAwO1xuICAgICAgICAvL2xldCBpc2xhbmRzIDogR3JvYk5vZGVbXVtdID0gW107XG4gICAgICAgIC8vbGV0IHRyYWNrZXIgPSBuZXcgIE5hbWVWYWx1ZVRyYWNrZXI8R3JvYk5vZGU+KCk7IFxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgLy8gV2UgY3JlYXRlIG91ciBzdGFjaywgYSBsaXN0IG9mIGFsbCBub2RlcyB3aGVyZSBldmVyeSBub2RlIGhhcyBhIGxpbmsgYW5kIExvd0xpbmsgdmFsdWUuXG4gICAgICAgIC8vIEJGUyBTZWFyY2hpbmcgdG8gYXNpZ24gbGluayB2YWx1ZXM7XG4gICAgICAgIHdoaWxlIChxdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBxdWUucG9wKCk7XG4gICAgICAgICAgICBpZiAoY3Vyci50YXJqYW5BbGdvcml0aG1BbGdvcml0aG1JbmRleCAhPSBhbGdMZXZlbCkge1xuICAgICAgICAgICAgICAgIGN1cnIubGlua1ZhbHVlID0gY291bnRlcisrO1xuICAgICAgICAgICAgICAgIGN1cnIuTG93TGlua1ZhbHVlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgY3Vyci50YXJqYW5BbGdvcml0aG1BbGdvcml0aG1JbmRleCA9IGFsZ0xldmVsO1xuICAgICAgICAgICAgICAgIHF1ZS5wdXNoLmFwcGx5KHF1ZSwgT2JqZWN0LnZhbHVlcyhjdXJyLmRlcGVuZGVuY2llcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaChjdXJyKTtcbiAgICAgICAgICAgIC8vIGFkZCB0cmFja2luZyBmb3IgdGhpcyBsb2NhdGlvbi4gXG4gICAgICAgICAgICAvL3RyYWNrZXIubmFtZVRvTnVtYmVyKCBjdXJyLmdldExvY2F0aW9uS2V5KCkgLCBjdXJyLkxvd0xpbmtWYWx1ZSAsIGN1cnIgKTtcbiAgICAgICAgfVxuICAgICAgICBxdWUgPSBbXTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcXVlLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGdMZXZlbCA9IEdyb2JBbGdvcml0aG1zLmFsZ0xldmVsKys7XG4gICAgICAgIHdoaWxlIChxdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBxdWUucG9wKCk7XG4gICAgICAgICAgICB0YXJqYW5Ob2RlVmlzaXQoYWxnTGV2ZWwsIGN1cnIsIHN0cm9uZ0NvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhcmphbk5vZGVWaXNpdChhbGdMZXZlbCwgbm9kZSwgc3Ryb25nQ29tcG9uZW50cykge1xuICAgICAgICAgICAgLy8gU3RvcCBUaGUgYWxnb3JpdGhtIGlmIHRoZSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gdmlzaXRlZFxuICAgICAgICAgICAgaWYgKG5vZGUudGFyamFuQWxnb3JpdGhtQWxnb3JpdGhtSW5kZXggPT0gYWxnTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5Mb3dMaW5rVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVlID0gT2JqZWN0LnZhbHVlcyhub2RlLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICB2YXIgbG93TGlua1ZhbHVlID0gbm9kZS5Mb3dMaW5rVmFsdWU7XG4gICAgICAgICAgICBub2RlLnRhcmphbkFsZ29yaXRobUFsZ29yaXRobUluZGV4ID0gYWxnTGV2ZWw7XG4gICAgICAgICAgICB3aGlsZSAocXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHF1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbG93TGlua0NhbmRpZGF0ZSA9IHRhcmphbk5vZGVWaXNpdChhbGdMZXZlbCwgY3Vyciwgc3Ryb25nQ29tcG9uZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIuTG93TGlua1ZhbHVlID09IGxvd0xpbmtDYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb25nQ29tcG9uZW50c1tjdXJyLmdldExvY2F0aW9uS2V5KCldID0gY3VycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3Vyci5Mb3dMaW5rVmFsdWUgPCBsb3dMaW5rQ2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd0xpbmtWYWx1ZSA9IGxvd0xpbmtDYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5Mb3dMaW5rVmFsdWUgPSBsb3dMaW5rVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbG93TGlua1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbT2JqZWN0LmtleXMoc3Ryb25nQ29tcG9uZW50cykubGVuZ3RoID09IDAsIHN0cm9uZ0NvbXBvbmVudHNdO1xuICAgIH07XG4gICAgR3JvYkFsZ29yaXRobXMuYWxnTGV2ZWwgPSAxO1xuICAgIHJldHVybiBHcm9iQWxnb3JpdGhtcztcbn0oKSk7XG5leHBvcnRzLkdyb2JBbGdvcml0aG1zID0gR3JvYkFsZ29yaXRobXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUdyb2JOb2RlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQUdyYXBoSXRlbV8xID0gcmVxdWlyZShcIi4uL0Fic3RyYWN0aW9ucy9BR3JhcGhJdGVtXCIpO1xudmFyIFRhcmphbk5vZGVfMSA9IHJlcXVpcmUoXCIuL2FsZ29yaXRobS9UYXJqYW5Ob2RlXCIpO1xudmFyIEFHcm9iTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBR3JvYk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQUdyb2JOb2RlKG5hbWUsIGtleXN0YXJ0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwga2V5c3RhcnQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlcGVuZGVuY2llcyA9IHt9O1xuICAgICAgICBfdGhpcy5kZXBlbmRlbnRzID0ge307XG4gICAgICAgIF90aGlzLnVwZGF0ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICBfdGhpcy5ib251c2VzID0ge307XG4gICAgICAgIC8vIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuICAgICAgICAvLyAtLS0gVGFyamFuIEFsZ29yaXRobSBJbXBsZW1lbnRhdGlvbiAtLS0gLS0tIC0tLSAtLS1cbiAgICAgICAgLy8gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG4gICAgICAgIF90aGlzLnRhcmphbkFsZ29yaXRobUFsZ29yaXRobUluZGV4ID0gMDtcbiAgICAgICAgX3RoaXMuTG93TGlua1ZhbHVlID0gMDtcbiAgICAgICAgX3RoaXMubGlua1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIF90aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLmFkZEJvbnVzID0gZnVuY3Rpb24gKGJvbnVzSW5kZXgsIGJvbnVzLCBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgICAgIGJvbnVzLnVwZGF0ZSgpO1xuICAgICAgICAvLyBmaXJzdCBzZWUgaWYgdGhlcmUgaXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBpZiB0aGVyZSBhbHJlYWR5IGlzIGRvbnQgZG8gYSB0aGluZy4gXG4gICAgICAgIHZhciBwcmVTdHJvbmdDb21wb25lbnRzID0ge307XG4gICAgICAgIHZhciBhbHJlYWR5SGFkU3Ryb25nQ29tcHMgPSBUYXJqYW5Ob2RlXzEuR3JvYkFsZ29yaXRobXMuVGFyakFsZ28oW3RoaXNdLCBwcmVTdHJvbmdDb21wb25lbnRzKTtcbiAgICAgICAgaWYgKGFscmVhZHlIYWRTdHJvbmdDb21wc1swXSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBrZXk6ICdQcmUtQWRkQm9udXNFcnJvcicsIG1zZzogJ3RoaXMgbm9kZSBhbHJlYWR5IGhhZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMsIGJlZm9yZSBhZGRpbmcgYW5vdGhlciBub2RlLiBBZGRlZCBCb251cyBpcyB0aGVyZWZvcmUgcmVmdXNlZCcgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9udXNlc1tib251c0luZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5yZW1Cb251cyhib251c0luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvbnVzZXNbYm9udXNJbmRleF0gPSBib251cztcbiAgICAgICAgdGhpcy5hZGREZXBlbmRlbmN5KGJvbnVzKTtcbiAgICAgICAgLy8gZmlyc3Qgc2VlIGlmIHRoZXJlIGlzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgaWYgdGhlcmUgYWxyZWFkeSBpcyBkb250IGRvIGEgdGhpbmcuIFxuICAgICAgICB2YXIgU3Ryb25nQ29tcG9uZW50cyA9IHt9O1xuICAgICAgICB2YXIgU3Ryb25nQ29tcHMgPSBUYXJqYW5Ob2RlXzEuR3JvYkFsZ29yaXRobXMuVGFyakFsZ28oW3RoaXNdLCBTdHJvbmdDb21wb25lbnRzKTtcbiAgICAgICAgaWYgKFN0cm9uZ0NvbXBzWzBdKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7IGtleTogJ1ByZS1BZGRCb251c0Vycm9yJywgbXNnOiAndGhpcyBub2RlIGFscmVhZHkgaGFkIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgYmVmb3JlIGFkZGluZyBhbm90aGVyIG5vZGUuIEFkZGVkIEJvbnVzIGlzIHRoZXJlZm9yZSByZWZ1c2VkJyB9KTtcbiAgICAgICAgICAgIHRoaXMucmVtQm9udXMoYm9udXNJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLnJlbUJvbnVzID0gZnVuY3Rpb24gKGJvbnVzSW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvbnVzZXNbYm9udXNJbmRleF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvbnVzZXNbYm9udXNJbmRleF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvbnVzZXNbYm9udXNJbmRleF07XG4gICAgICAgIHRoaXMucmVtb3ZlRGVwZW5kZW5jeShub2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBBR3JvYk5vZGUuZ2V0VHlwZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdOb2R0ZTxUIGV4dGVuZHMgTm9kdGU8VD4+JztcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUuYWRkRGVwZW5kZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVudHNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXBlbmRlbnRzW2tleV0gPSBub2RlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUucmVtb3ZlRGVwZW5kZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVwZW5kZW50c1tub2RlLmdldEtleSgpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwZW5kZW50c1tub2RlLmdldEtleSgpXSA9PSBudWxsO1xuICAgIH07XG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS5nZXREZXBlbmRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gKF9hID0gT2JqZWN0LnZhbHVlcyh0aGlzLmRlcGVuZGVudHMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUucmVtb3ZlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUubnVsbGlmeURlcGVuZGVuY3kgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChfYSA9IE9iamVjdC52YWx1ZXModGhpcy5kZXBlbmRlbmNpZXMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZSgpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5ib251c2VzKSB7XG4gICAgICAgICAgICB2YXIgYm9udXMgPSB0aGlzLmJvbnVzZXNba2V5XTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJvbnVzLl9nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfTtcbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VncyA9IHRoaXMuZ2V0TG9jYXRpb25LZXlTZWdtZW50cygpO1xuICAgICAgICByZXR1cm4gc2Vncy5qb2luKCcuJyk7XG4gICAgfTtcbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uS2V5U2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB2YXIgc2VnID0gWycnLCAnJywgJyddO1xuICAgICAgICBzZWdbMF0gPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ3Vua25vd24nO1xuICAgICAgICBzZWdbMV0gPSAoX2UgPSAoX2QgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3Vua25vd24nO1xuICAgICAgICBzZWdbMl0gPSAoX2YgPSB0aGlzLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJ3Vua25vd24nO1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH07XG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAoT2JqZWN0LmtleXModGhpcy51cGRhdGVMaXN0ZW5lcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZGVsZXRlIHJlZmVyZW5jZXMgYWxsIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5kZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgICAgICAgIGN1cnIucmVtb3ZlRGVwZW5kZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRlcGVuZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5kZXBlbmRlbnRzW2tleV07XG4gICAgICAgICAgICBjdXJyLm51bGxpZnlEZXBlbmRlbmN5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIH07XG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24gKG5hbWUsIHBhcmVudENhbGwpIHtcbiAgICAgICAgaWYgKHBhcmVudENhbGwgPT09IHZvaWQgMCkgeyBwYXJlbnRDYWxsID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9sZG5hbWUgPSB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXROYW1lLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIGlmICghcGFyZW50Q2FsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlX25vZGVfbmFtZShvbGRuYW1lLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxvY2F0aW9uKHRoaXMucGFyZW50KTtcbiAgICB9O1xuICAgIC8qIGJ5IGxvY2F0aW9uIHdlIG1lYW4gdGhpcyBpdGVtcyBncm91cCAtIGNvbGxlY3Rpb24gLSBub2RlIGtleS4gICovXG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS51cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRlcGVuZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBkZXAgPSB0aGlzLmRlcGVuZGVudHNba2V5XTtcbiAgICAgICAgICAgIGRlcC51cGRhdGVEZXBlbmRlY3lzTG9jYXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUudXBkYXRlRGVwZW5kZWN5c0xvY2F0aW9uID0gZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICB9O1xuICAgIEFHcm9iTm9kZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS1cbiAgICAvLyAtRm9yIGluZGVwZW5kZW50IFVJIGltcGxlbWVudGF0aW9uJ3MgdG8gaGF2ZSBzb2VtdGhpbmcgdG8gYXR0YWNoIGEgbm9kZSdzIHVwZGF0ZSB0by4gXG4gICAgLy8gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS5hZGRVcGRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChrZXksIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZUxpc3RlbmVyc1trZXldICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJpZWQgdG8gYWRkIHVwZGF0ZWxpc3RlbmVyIHRvIG5vZGUgd2l0aCBrZXk6JyArIGtleSArICcuIGJ1dCB0aGVyZSB3YXMgYWxyZWFkeSBhIGxpc3RlbmVyIHVzaW5nIHRoYXQga2V5Jyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgQUdyb2JOb2RlLnByb3RvdHlwZS5yZW1vdmVVcGRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudXBkYXRlTGlzdGVuZXJzW2tleV07XG4gICAgfTtcbiAgICBBR3JvYk5vZGUucHJvdG90eXBlLnJlbW92ZUFsbFVwZGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBBR3JvYk5vZGU7XG59KEFHcmFwaEl0ZW1fMS5BR3JhcGhJdGVtKSk7XG5leHBvcnRzLkFHcm9iTm9kZSA9IEFHcm9iTm9kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ncm9iRGVyaXZlZFN5bWJvbFJlZ2V4ID0gdm9pZCAwO1xuZXhwb3J0cy5ncm9iRGVyaXZlZFN5bWJvbFJlZ2V4ID0gL0BbYS16QS1aXS9nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyb2JPcmlnaW4gPSB2b2lkIDA7XG52YXIgR3JvYk9yaWdpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm9iT3JpZ2luKCkge1xuICAgICAgICB0aGlzLnN0YW5kYXJkVmFsdWUgPSAxO1xuICAgIH1cbiAgICBHcm9iT3JpZ2luLlVua293bkxvY2F0aW9uS2V5ID0gJ3Vua25vd24udW5rbm93bi51bmtub3duJztcbiAgICByZXR1cm4gR3JvYk9yaWdpbjtcbn0oKSk7XG5leHBvcnRzLkdyb2JPcmlnaW4gPSBHcm9iT3JpZ2luO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyb2JEZXJpdmVkTm9kZSA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEFHcm9iTm9kdGVfMSA9IHJlcXVpcmUoXCIuL0FHcm9iTm9kdGVcIik7XG52YXIgVFRSUEdTeXN0ZW1zR3JhcGhEZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuLi9HcmFwaC9UVFJQR1N5c3RlbXNHcmFwaERlcGVuZGVuY2llc1wiKTtcbnZhciBHcm9iT3JpZ2luXzEgPSByZXF1aXJlKFwiLi9Hcm9iT3JpZ2luXCIpO1xudmFyIEdyb2JEZXJpdmVkTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhHcm9iRGVyaXZlZE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvYkRlcml2ZWROb2RlKG5hbWUsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCAnTkQnLCBwYXJlbnQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbGMgPSAnQGEnO1xuICAgICAgICBfdGhpcy5vcmlnaW5zID0gW107XG4gICAgICAgIF90aGlzLl92YWx1ZSA9IE5hTjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLmdldFR5cGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnZGVyaXZlZE5vZGUnO1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnByb3RvdHlwZS5nZXRUeXBlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gR3JvYkRlcml2ZWROb2RlLmdldFR5cGVTdHJpbmcoKTtcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBrZXkgPSBub2RlLmdldEtleSgpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llc1trZXldID0gbm9kZTtcbiAgICAgICAgbm9kZS5hZGREZXBlbmRlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnByb3RvdHlwZS5yZW1vdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSBkZXBlbmRlbmN5XG4gICAgICAgIHZhciBrZXkgPSBub2RlLmdldEtleSgpO1xuICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmNpZXNba2V5XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVwZW5kZW5jaWVzW2tleV07XG4gICAgICAgICAgICBub2RlLnJlbW92ZURlcGVuZGVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgb3JpZ2luIGRlcGVuZGVuY3kgXG4gICAgICAgIC8vIHdlIGZpbmQgdGhlIG9yaWdpbiwgd2l0aCB0aGUga2V5IHZhbHVlLCBhbmQgcmVtb3ZlIGl0LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3JpZ2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9yaWcgPSB0aGlzLm9yaWdpbnNbaV07XG4gICAgICAgICAgICBpZiAob3JpZy5vcmlnaW4gIT0gbnVsbCAmJiBvcmlnLm9yaWdpbi5nZXRLZXkoKSA9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBvcmlnLm9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jaWVzW2tleV0gPT0gbnVsbDtcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUubnVsbGlmeURlcGVuZGVuY3kgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBmaXJzdCBFbXB0eSB0aGUgb3JpZ2luLlxuICAgICAgICB2YXIga2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdmFyIG9yaWcgPSB0aGlzLm9yaWdpbnMuZmluZChmdW5jdGlvbiAocCkgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gcC5vcmlnaW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRLZXkoKSkgPT0ga2V5OyB9KTtcbiAgICAgICAgaWYgKG9yaWcpIHtcbiAgICAgICAgICAgIG9yaWcub3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIG9yaWcub3JpZ2luS2V5ID0gR3JvYk9yaWdpbl8xLkdyb2JPcmlnaW4uVW5rb3duTG9jYXRpb25LZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlbiBudWxpZnkgdGhlIGRlcGVuZGVuY3lcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRGVwZW5kZW5jeShub2RlKTtcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUuc2V0T3JpZ2luID0gZnVuY3Rpb24gKHN5bWJvbCwgbm9kZSwgc3RhbmRhcmRWYWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoc3RhbmRhcmRWYWx1ZSA9PT0gdm9pZCAwKSB7IHN0YW5kYXJkVmFsdWUgPSBudWxsOyB9XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbnMuZmluZChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5zeW1ib2wgPT0gc3ltYm9sOyB9KTtcbiAgICAgICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luLm9yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEZXBlbmRlbmN5KG9yaWdpbi5vcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoaXMgaXMgdGhlIHJpZ2h0IHR5cGUgb2Ygb2JqZWN0LlxuICAgICAgICB2YXIgbm9kZUtleSA9IChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5nZXRUeXBlU3RyaW5nKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICBpZiAoIVsnZGVyaXZlZE5vZGUnLCAnZml4ZWROb2RlJ10uZmluZChmdW5jdGlvbiAocCkgeyByZXR1cm4gcCA9PSBub2RlS2V5OyB9KSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXBlbmRlbmN5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdpbi5vcmlnaW4gPSBub2RlO1xuICAgICAgICBvcmlnaW4uc3RhbmRhcmRWYWx1ZSA9IChfYiA9IChzdGFuZGFyZFZhbHVlICE9PSBudWxsICYmIHN0YW5kYXJkVmFsdWUgIT09IHZvaWQgMCA/IHN0YW5kYXJkVmFsdWUgOiBvcmlnaW4uc3RhbmRhcmRWYWx1ZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgICAgIGlmIChvcmlnaW4ub3JpZ2luKVxuICAgICAgICAgICAgb3JpZ2luLm9yaWdpbktleSA9IG9yaWdpbi5vcmlnaW4uZ2V0TG9jYXRpb25LZXkoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhZE51bGxPcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5zLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmICghby5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBoYWROdWxsT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYWROdWxsT3JpZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbnNXaXRoTGlua3MgPSB0aGlzLm9yaWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLm9yaWdpbiAhPSBudWxsOyB9KTtcbiAgICAgICAgaWYgKG9yaWdpbnNXaXRoTGlua3MubGVuZ3RoICE9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLnVwZGF0ZU9yaWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5SZXMgPSB0aGlzLnBhcnNlQ2FsY3VsYXRpb25Ub09yaWdpbnModGhpcy5jYWxjKTtcbiAgICAgICAgaWYgKG9yaWdpblJlcykge1xuICAgICAgICAgICAgdmFyIHN5bWJvbHNUb1JlbV8xID0gb3JpZ2luUmVzLnN5bWJvbHNUb1JlbTtcbiAgICAgICAgICAgIHZhciBzeW1ib2xzVG9BZGQgPSBvcmlnaW5SZXMuc3ltYm9sc1RvQWRkO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN5bWJvbHMgXG4gICAgICAgICAgICBpZiAoc3ltYm9sc1RvUmVtXzEubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbnMgPSB0aGlzLm9yaWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiAhc3ltYm9sc1RvUmVtXzEuaW5jbHVkZXMocC5zeW1ib2wpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBpdGVtcyBpZiB0aGVyZSBpcyBhbnl0aGluZyB0byBhZGQuICBcbiAgICAgICAgICAgIGlmIChzeW1ib2xzVG9BZGQubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHNUb0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IG5ldyBHcm9iT3JpZ2luXzEuR3JvYk9yaWdpbigpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnLnN5bWJvbCA9IHN5bWJvbHNUb0FkZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZy5zdGFuZGFyZFZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZy5vcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBvcmlnLm9yaWdpbktleSA9IEdyb2JPcmlnaW5fMS5Hcm9iT3JpZ2luLlVua293bkxvY2F0aW9uS2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbnMucHVzaChvcmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgRGVwZW5kZW5jaWVzIFxuICAgICAgICAgICAgdmFyIG9sZERlcGVuZGVuY2llc18xID0ge307XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcygpLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIG9sZERlcGVuZGVuY2llc18xW3AuZ2V0TmFtZSgpXSA9IHA7IH0pO1xuICAgICAgICAgICAgdmFyIG5ld0RlcGVuZGVuY2llc18xID0ge307XG4gICAgICAgICAgICB0aGlzLm9yaWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyB2YXIgX2E7IGlmIChwLm9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3RGVwZW5kZW5jaWVzXzFbKF9hID0gcC5vcmlnaW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXROYW1lKCldID0gcC5vcmlnaW47XG4gICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBEZXBlbmRlbmNpZXMgXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkRGVwZW5kZW5jaWVzXzEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0RlcGVuZGVuY2llc18xW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZXBlbmRlbmN5KG9sZERlcGVuZGVuY2llc18xW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGFkZGVkOiBzeW1ib2xzVG9BZGQsIHJlbW92ZWQ6IHN5bWJvbHNUb1JlbV8xLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgYWRkZWQ6IDAsIHJlbW92ZWQ6IDAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnByb3RvdHlwZS5zZXRDYWxjID0gZnVuY3Rpb24gKGNhbGMsIHVwZGF0ZU9yaWdpbnMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZU9yaWdpbnMgPT09IHZvaWQgMCkgeyB1cGRhdGVPcmlnaW5zID0gdHJ1ZTsgfVxuICAgICAgICAvLyByZXNldCBUaGlzJyBWYWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBOYU47XG4gICAgICAgIC8vIHRlc3QgaWYgaXQgaXMgY2FsY3VsYXRlYWJsZVxuICAgICAgICB2YXIgdGVzdENhbGMgPSB0aGlzLnRlc3RDYWxjdWxhdGUoY2FsYyk7XG4gICAgICAgIGlmICh0ZXN0Q2FsYyA9PSBudWxsIHx8ICF0ZXN0Q2FsYy5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjID0gY2FsYztcbiAgICAgICAgLy8gdXBkYXRlIG9yaWdpbnMuXG4gICAgICAgIGlmICh1cGRhdGVPcmlnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGNhbGN1bGF0aW9uIFRvIGEgTnVtYmVyIG9mIE9yaWdpbnMuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLnBhcnNlQ2FsY3VsYXRpb25Ub09yaWdpbnMgPSBmdW5jdGlvbiAoY2FsYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjYWxjVmFsdWUgPSBjYWxjO1xuICAgICAgICAvLyBnZXQgc3ltYm9scyBmcm9tIHRoZSBjYWxjLiBhbmQgdHVybiBpdCBpbnRvIGFuIGFycmF5LiBpbXBvcnRhbnQsIHRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiB1bmlxdWUga2V5cy5cbiAgICAgICAgdmFyIHN5bWJvbHMgPSAoX2EgPSBjYWxjVmFsdWUubWF0Y2goVFRSUEdTeXN0ZW1zR3JhcGhEZXBlbmRlbmNpZXNfMS5ncm9iRGVyaXZlZFN5bWJvbFJlZ2V4KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHN5bWJvbHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc3ltYm9scykpO1xuICAgICAgICAvLyBnZXQgdGhlIGtleXMgdGhhdCBhcmUgYWxyZWFkeSB0aGVyZS5cbiAgICAgICAgdmFyIGV4aXN0aW5nS2V5c0FycmF5ID0gdGhpcy5vcmlnaW5zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5zeW1ib2w7IH0pO1xuICAgICAgICAvLyBnZXQgYSBsaXN0IG9mIHN5bWJvbHMgdG8gYWRkIGFuZCByZW1vdmUuXG4gICAgICAgIHZhciBzeW1ib2xzVG9BZGQgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIWV4aXN0aW5nS2V5c0FycmF5LmluY2x1ZGVzKHApOyB9KTtcbiAgICAgICAgdmFyIHN5bWJvbHNUb1JlbSA9IGV4aXN0aW5nS2V5c0FycmF5LmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIXN5bWJvbHMuaW5jbHVkZXMocCk7IH0pO1xuICAgICAgICByZXR1cm4geyBzeW1ib2xzVG9SZW06IHN5bWJvbHNUb1JlbSwgc3ltYm9sc1RvQWRkOiBzeW1ib2xzVG9BZGQsIHRvdGFsU3ltYm9sczogc3ltYm9scyB9O1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnN0YXRpY1BhcnNlQ2FsY3VsYXRpb25Ub09yaWdpbnMgPSBmdW5jdGlvbiAoY2FsYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjYWxjVmFsdWUgPSBjYWxjO1xuICAgICAgICAvLyBnZXQgc3ltYm9scyBmcm9tIHRoZSBjYWxjLiBhbmQgdHVybiBpdCBpbnRvIGFuIGFycmF5LiBpbXBvcnRhbnQsIHRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiB1bmlxdWUga2V5cy5cbiAgICAgICAgdmFyIHN5bWJvbHMgPSAoX2EgPSBjYWxjVmFsdWUubWF0Y2goVFRSUEdTeXN0ZW1zR3JhcGhEZXBlbmRlbmNpZXNfMS5ncm9iRGVyaXZlZFN5bWJvbFJlZ2V4KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHN5bWJvbHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc3ltYm9scykpO1xuICAgICAgICByZXR1cm4gc3ltYm9scztcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAodXNlVGVtcFZhbHVlcykge1xuICAgICAgICBpZiAodXNlVGVtcFZhbHVlcyA9PT0gdm9pZCAwKSB7IHVzZVRlbXBWYWx1ZXMgPSBmYWxzZTsgfVxuICAgICAgICAvL2NvbnN0IHN5bWJvbHMgPSB0aGlzLmNhbGMubWF0Y2goIGdyb2JEZXJpdmVkU3ltYm9sUmVnZXggKTsgIFxuICAgICAgICB2YXIgcmVjID0gdXNlVGVtcFZhbHVlcyA/XG4gICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXModGhpcy5vcmlnaW5zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gW3Auc3ltYm9sLCBwLnN0YW5kYXJkVmFsdWVdOyB9KSkgOlxuICAgICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMub3JpZ2lucy5tYXAoZnVuY3Rpb24gKHApIHsgdmFyIF9hOyByZXR1cm4gW3Auc3ltYm9sLCAoX2EgPSBwLm9yaWdpbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFZhbHVlKCldOyB9KSk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLmNhbGM7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLl9yZWNhbGN1bGF0ZShyZWMsIHN0YXRlbWVudCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcmVzLnZhbHVlO1xuICAgICAgICByZXR1cm4gcmVzLnN1Y2Nlc3M7XG4gICAgfTtcbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLl9yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChyZWMsIHN0YXRlbWVudCkge1xuICAgICAgICBpZiAocmVjID09PSB2b2lkIDApIHsgcmVjID0ge307IH1cbiAgICAgICAgcmV0dXJuIEdyb2JEZXJpdmVkTm9kZS5yZWNhbGN1bGF0ZShyZWMsIHN0YXRlbWVudCk7XG4gICAgfTtcbiAgICBHcm9iRGVyaXZlZE5vZGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAocmVjLCBzdGF0ZW1lbnQpIHtcbiAgICAgICAgaWYgKHJlYyA9PT0gdm9pZCAwKSB7IHJlYyA9IHt9OyB9XG4gICAgICAgIHZhciBzeW1ib2xzID0gc3RhdGVtZW50Lm1hdGNoKFRUUlBHU3lzdGVtc0dyYXBoRGVwZW5kZW5jaWVzXzEuZ3JvYkRlcml2ZWRTeW1ib2xSZWdleCk7XG4gICAgICAgIC8vbGV0IHJlYyA9IFxuICAgICAgICAvL1x0dXNlVGVtcFZhbHVlcyA/XG4gICAgICAgIC8vXHRPYmplY3QuZnJvbUVudHJpZXMoIG9yaWdpbnMubWFwKHAgPT4gWyBwLnN5bWJvbCwgcC5zdGFuZGFyZFZhbHVlXSkpOlx0XG4gICAgICAgIC8vXHRPYmplY3QuZnJvbUVudHJpZXMoIG9yaWdpbnMubWFwKHAgPT4gWyBwLnN5bWJvbCwgcC5vcmlnaW4/LmdldFZhbHVlKCkgXSkpO1xuICAgICAgICB2YXIgX3N0YXRlbWVudCA9IHN0YXRlbWVudDtcbiAgICAgICAgc3ltYm9scyA9PT0gbnVsbCB8fCBzeW1ib2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHYgPSByZWNba2V5XTtcbiAgICAgICAgICAgIF9zdGF0ZW1lbnQgPSBfc3RhdGVtZW50LnJlcGxhY2Uoa2V5LCB2ICsgXCJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVjYWxjU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGV2YWwoX3N0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZWNhbGNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2FsY1N1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVjYWxjU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFsdWUgPSBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogcmVjYWxjU3VjY2VzcywgdmFsdWU6IHZhbHVlIH07XG4gICAgfTtcbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLnRlc3RDYWxjdWxhdGUgPSBmdW5jdGlvbiAoc3RhdGVtZW50KSB7XG4gICAgICAgIHZhciBzeW1ib2xzID0gc3RhdGVtZW50Lm1hdGNoKFRUUlBHU3lzdGVtc0dyYXBoRGVwZW5kZW5jaWVzXzEuZ3JvYkRlcml2ZWRTeW1ib2xSZWdleCk7XG4gICAgICAgIHZhciByZWMgPSBzeW1ib2xzID8gT2JqZWN0LmZyb21FbnRyaWVzKHN5bWJvbHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBbcywgMV07IH0pKSA6IHt9O1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5fcmVjYWxjdWxhdGUocmVjLCBzdGF0ZW1lbnQpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgR3JvYkRlcml2ZWROb2RlLnRlc3RDYWxjdWxhdGUgPSBmdW5jdGlvbiAoc3RhdGVtZW50LCBzeW1ib2xzVG9WYWx1ZSkge1xuICAgICAgICBpZiAoc3ltYm9sc1RvVmFsdWUgPT09IHZvaWQgMCkgeyBzeW1ib2xzVG9WYWx1ZSA9IHt9OyB9XG4gICAgICAgIHZhciBzeW1ib2xzID0gc3RhdGVtZW50Lm1hdGNoKFRUUlBHU3lzdGVtc0dyYXBoRGVwZW5kZW5jaWVzXzEuZ3JvYkRlcml2ZWRTeW1ib2xSZWdleCk7XG4gICAgICAgIGZ1bmN0aW9uIG1hcFZhbHVlVG9TeW1ib2wocywgbSkge1xuICAgICAgICAgICAgaWYgKG1bc10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbVtzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWMgPSBzeW1ib2xzID8gT2JqZWN0LmZyb21FbnRyaWVzKHN5bWJvbHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBbcywgbWFwVmFsdWVUb1N5bWJvbChzLCBzeW1ib2xzVG9WYWx1ZSldOyB9KSkgOiB7fTtcbiAgICAgICAgdmFyIHJlcyA9IEdyb2JEZXJpdmVkTm9kZS5yZWNhbGN1bGF0ZShyZWMsIHN0YXRlbWVudCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBHcm9iRGVyaXZlZE5vZGUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIGlzZW50IFZhbGlkIFwiLmNvbmNhdCh0aGlzLmdldE5hbWUoKSwgXCIgXCIpLmNvbmNhdCh0aGlzLmdldExvY2F0aW9uS2V5KCksIFwiIFN0b3BwaW5nIHVwZGF0ZVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgcmVjYWxjdWxhdGVcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAvLyB0aGVuIGNhbGwgdXBkYXRlIGZvciBhbGwgZGVwZW5kZW50cyBcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuZGVwZW5kZW50cykge1xuICAgICAgICAgICAgdmFyIGRlcCA9IHRoaXMuZGVwZW5kZW50c1trXTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIGRlcC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuICAgIEdyb2JEZXJpdmVkTm9kZS5wcm90b3R5cGUudXBkYXRlRGVwZW5kZWN5c0xvY2F0aW9uID0gZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgdmFyIG9yaWcgPSB0aGlzLm9yaWdpbnMuZmluZChmdW5jdGlvbiAocCkgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gcC5vcmlnaW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXROYW1lKCkpID09IGRlcGVuZGVuY3kuZ2V0TmFtZSgpOyB9KTtcbiAgICAgICAgaWYgKCFvcmlnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvcmlnLm9yaWdpbktleSA9IGRlcGVuZGVuY3kuZ2V0TG9jYXRpb25LZXkoKTtcbiAgICB9O1xuICAgIHJldHVybiBHcm9iRGVyaXZlZE5vZGU7XG59KEFHcm9iTm9kdGVfMS5BR3JvYk5vZGUpKTtcbmV4cG9ydHMuR3JvYkRlcml2ZWROb2RlID0gR3JvYkRlcml2ZWROb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyb2JCb251c05vZGUgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBHcm9iRGVyaXZlZE5vZGVfMSA9IHJlcXVpcmUoXCIuL0dyb2JEZXJpdmVkTm9kZVwiKTtcbnZhciBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXJfMSA9IHJlcXVpcmUoXCIuLi9IZWxwZXJzL1RUUlBHU3lzdGVtQm9udXNEZXNpZ25lclwiKTtcbnZhciBHcm9iQm9udXNOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEdyb2JCb251c05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvYkJvbnVzTm9kZShuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHBhcmVudCkgfHwgdGhpcztcbiAgICB9XG4gICAgR3JvYkJvbnVzTm9kZS5DcmVhdGVOb2RlQ2hhaW4gPSBmdW5jdGlvbiAoc3lzLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXJfMS5UVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIuY3JlYXRlQm9udXNOb2RlQ2hhaW4oc3lzLCBuYW1lKTtcbiAgICB9O1xuICAgIEdyb2JCb251c05vZGUuZ2V0VHlwZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdib251c05vZGUnO1xuICAgIH07XG4gICAgR3JvYkJvbnVzTm9kZS5wcm90b3R5cGUuZ2V0VHlwZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEdyb2JCb251c05vZGUuZ2V0VHlwZVN0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb2JCb251c05vZGU7XG59KEdyb2JEZXJpdmVkTm9kZV8xLkdyb2JEZXJpdmVkTm9kZSkpO1xuZXhwb3J0cy5Hcm9iQm9udXNOb2RlID0gR3JvYkJvbnVzTm9kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIgPSB2b2lkIDA7XG52YXIgR3JvYkJvbnVzTm9kZV8xID0gcmVxdWlyZShcIi4uL05vZGVzL0dyb2JCb251c05vZGVcIik7XG52YXIgVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lcigpIHtcbiAgICB9XG4gICAgVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyLmNyZWF0ZUJvbnVzTm9kZUNoYWluID0gZnVuY3Rpb24gKHN5cywgbmFtZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyKCk7XG4gICAgICAgIGlmICghc3lzLmhhc0NvbGxlY3Rpb24oJ2V4dHJhJywgJ2JvbnVzJykpIHtcbiAgICAgICAgICAgIHN5cy5jcmVhdGVDb2xsZWN0aW9uKCdleHRyYScsICdib251cycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2wgPSBzeXMuZ2V0Q29sbGVjdGlvbignZXh0cmEnLCAnYm9udXMnKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBOb2RlLlxuICAgICAgICBpbnN0YW5jZS5hY3RpdmVOb2RlID0gaW5zdGFuY2UuY3JlYXRlTmV3Tm9kZShuYW1lLCBjb2wpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIucHJvdG90eXBlLmNyZWF0ZU5ld05vZGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgR3JvYkJvbnVzTm9kZV8xLkdyb2JCb251c05vZGUobmFtZSwgcGFyZW50KTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lci5wcm90b3R5cGUuYWRkQ2FsY3VsYXRpb24gPSBmdW5jdGlvbiAoY2FsYykge1xuICAgICAgICB0aGlzLmFjdGl2ZU5vZGUuc2V0Q2FsYyhjYWxjKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIucHJvdG90eXBlLmFkZE9yaWdpbiA9IGZ1bmN0aW9uIChzeW1ib2wsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVOb2RlLnNldE9yaWdpbihzeW1ib2wsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZU5vZGUudXBkYXRlT3JpZ2lucygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lci5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlTm9kZTtcbiAgICB9O1xuICAgIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lci5wcm90b3R5cGUuZ2V0T3JpZ2luU3RhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVOb2RlLnBhcnNlQ2FsY3VsYXRpb25Ub09yaWdpbnModGhpcy5hY3RpdmVOb2RlLmNhbGMpO1xuICAgIH07XG4gICAgVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyLnByb3RvdHlwZS5pc1ZhbGlkQ2FsY3VsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU5vZGUudGVzdENhbGN1bGF0ZSh0aGlzLmFjdGl2ZU5vZGUuY2FsYyk7XG4gICAgfTtcbiAgICBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU5vZGUuaXNWYWxpZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lcjtcbn0oKSk7XG5leHBvcnRzLlRUUlBHU3lzdGVtQm9udXNEZXNpZ25lciA9IFRUUlBHU3lzdGVtQm9udXNEZXNpZ25lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hcm9iRml4ZWROb2RlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQUdyb2JOb2R0ZV8xID0gcmVxdWlyZShcIi4vQUdyb2JOb2R0ZVwiKTtcbnZhciBHcm9iRml4ZWROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEdyb2JGaXhlZE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvYkZpeGVkTm9kZShuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgJ05GJywgcGFyZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fX192YWx1ZSA9IDE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR3JvYkZpeGVkTm9kZS5wcm90b3R5cGUuX2dldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX192YWx1ZTtcbiAgICB9O1xuICAgIEdyb2JGaXhlZE5vZGUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGVwZW5kZW50cykge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSB0aGlzLmRlcGVuZGVudHNba2V5XTtcbiAgICAgICAgICAgIGN1cnIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb2JGaXhlZE5vZGUuZ2V0VHlwZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdmaXhlZE5vZGUnO1xuICAgIH07XG4gICAgR3JvYkZpeGVkTm9kZS5wcm90b3R5cGUuZ2V0VHlwZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEdyb2JGaXhlZE5vZGUuZ2V0VHlwZVN0cmluZygpO1xuICAgIH07XG4gICAgR3JvYkZpeGVkTm9kZS5wcm90b3R5cGUuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBHcm9iRml4ZWROb2RlLnByb3RvdHlwZS5yZW1vdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIEdyb2JGaXhlZE5vZGUucHJvdG90eXBlLm51bGxpZnlEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIEdyb2JGaXhlZE5vZGUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5kZXBlbmRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgZGVwID0gdGhpcy5kZXBlbmRlbnRzW2tdO1xuICAgICAgICAgICAgZGVwLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JvYkZpeGVkTm9kZTtcbn0oQUdyb2JOb2R0ZV8xLkFHcm9iTm9kZSkpO1xuZXhwb3J0cy5Hcm9iRml4ZWROb2RlID0gR3JvYkZpeGVkTm9kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BRGF0YVJvdyA9IGV4cG9ydHMuQURhdGFUYWJsZSA9IHZvaWQgMDtcbnZhciBBRGF0YVRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFEYXRhVGFibGUoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIH1cbiAgICBBRGF0YVRhYmxlLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfTtcbiAgICBBRGF0YVRhYmxlLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9O1xuICAgIEFEYXRhVGFibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH07XG4gICAgQURhdGFUYWJsZS5wcm90b3R5cGUudXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH07XG4gICAgQURhdGFUYWJsZS5wcm90b3R5cGUuZ2V0TG9jYXRpb25LZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5nZXRMb2NhdGlvbktleVNlZ21lbnRzKCk7XG4gICAgICAgIHJldHVybiBzZWdzLmpvaW4oJy4nKTtcbiAgICB9O1xuICAgIEFEYXRhVGFibGUucHJvdG90eXBlLmdldExvY2F0aW9uS2V5U2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB2YXIgc2VnID0gWycnLCAnJywgJyddO1xuICAgICAgICBzZWdbMF0gPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ3Vua25vd24nO1xuICAgICAgICBzZWdbMV0gPSAoX2UgPSAoX2QgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3Vua25vd24nO1xuICAgICAgICBzZWdbMl0gPSAoX2YgPSB0aGlzLmdldE5hbWUoKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJ3Vua25vd24nO1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH07XG4gICAgQURhdGFUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBBRGF0YVRhYmxlO1xufSgpKTtcbmV4cG9ydHMuQURhdGFUYWJsZSA9IEFEYXRhVGFibGU7XG52YXIgQURhdGFSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQURhdGFSb3coKSB7XG4gICAgfVxuICAgIHJldHVybiBBRGF0YVJvdztcbn0oKSk7XG5leHBvcnRzLkFEYXRhUm93ID0gQURhdGFSb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZHY0ID0gZXhwb3J0cy5UVFJQR1N5c3RlbUhlbHBlciA9IGV4cG9ydHMuVFRSUEdTeXN0ZW0gPSBleHBvcnRzLkFEYXRhVGFibGUgPSBleHBvcnRzLkFEYXRhUm93ID0gZXhwb3J0cy5Hcm9iR3JvdXAgPSBleHBvcnRzLkdyb2JDb2xsZWN0aW9uID0gZXhwb3J0cy5Hcm9iQm9udXNOb2RlID0gZXhwb3J0cy5Hcm9iRGVyaXZlZE5vZGUgPSBleHBvcnRzLkdyb2JEZXJpdmVkT3JpZ2luID0gZXhwb3J0cy5Hcm9iRml4ZWROb2RlID0gZXhwb3J0cy5rZXlNYW5hZ2VySW5zdGFuY2UgPSB2b2lkIDA7XG52YXIgS2V5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3Rpb25zL0tleU1hbmFnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJrZXlNYW5hZ2VySW5zdGFuY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEtleU1hbmFnZXJfMS5rZXlNYW5hZ2VySW5zdGFuY2U7IH0gfSk7XG52YXIgVFRSUEdTeXN0ZW1HcmFwaE1vZGVsXzEgPSByZXF1aXJlKFwiLi9HcmFwaC9UVFJQR1N5c3RlbUdyYXBoTW9kZWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUVFJQR1N5c3RlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVFRSUEdTeXN0ZW1HcmFwaE1vZGVsXzEuVFRSUEdTeXN0ZW1HcmFwaE1vZGVsOyB9IH0pO1xudmFyIEdyb2JDb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9Hcm9iQ29sbGVjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdyb2JDb2xsZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHcm9iQ29sbGVjdGlvbl8xLkdyb2JDb2xsZWN0aW9uOyB9IH0pO1xudmFyIEdyb2JHcm91cF8xID0gcmVxdWlyZShcIi4vR3JvYkdyb3VwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR3JvYkdyb3VwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHcm9iR3JvdXBfMS5Hcm9iR3JvdXA7IH0gfSk7XG52YXIgVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyXzEgPSByZXF1aXJlKFwiLi9IZWxwZXJzL1RUUlBHU3lzdGVtQm9udXNEZXNpZ25lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRUUlBHU3lzdGVtSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXJfMS5UVFJQR1N5c3RlbUJvbnVzRGVzaWduZXI7IH0gfSk7XG52YXIgR3JvYkJvbnVzTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZXMvR3JvYkJvbnVzTm9kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdyb2JCb251c05vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdyb2JCb251c05vZGVfMS5Hcm9iQm9udXNOb2RlOyB9IH0pO1xudmFyIEdyb2JEZXJpdmVkTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZXMvR3JvYkRlcml2ZWROb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR3JvYkRlcml2ZWROb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHcm9iRGVyaXZlZE5vZGVfMS5Hcm9iRGVyaXZlZE5vZGU7IH0gfSk7XG52YXIgR3JvYkZpeGVkTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZXMvR3JvYkZpeGVkTm9kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdyb2JGaXhlZE5vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdyb2JGaXhlZE5vZGVfMS5Hcm9iRml4ZWROb2RlOyB9IH0pO1xudmFyIEdyb2JPcmlnaW5fMSA9IHJlcXVpcmUoXCIuL05vZGVzL0dyb2JPcmlnaW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHcm9iRGVyaXZlZE9yaWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR3JvYk9yaWdpbl8xLkdyb2JPcmlnaW47IH0gfSk7XG52YXIgRGF0YVRhYmxlXzEgPSByZXF1aXJlKFwiLi9UYWJsZXMvRGF0YVRhYmxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQURhdGFSb3dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFUYWJsZV8xLkFEYXRhUm93OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQURhdGFUYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0YVRhYmxlXzEuQURhdGFUYWJsZTsgfSB9KTtcbmZ1bmN0aW9uIHV1aWR2NCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCdcbiAgICAgICAgLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnRzLnV1aWR2NCA9IHV1aWR2NDtcbiIsImV4cG9ydCB2YXIgQkFTRV9TQ0hFTUUgPSAnX2Jhc2UnO1xuZXhwb3J0IHZhciBOb091dHB1dCA9IHtcbiAgICBvdXRFcnJvcjogZnVuY3Rpb24gKG1zZykgeyB9LFxuICAgIG91dExvZzogZnVuY3Rpb24gKG1zZykgeyB9XG59O1xuZXhwb3J0IHZhciBKU09OX1RBR1M7XG4oZnVuY3Rpb24gKEpTT05fVEFHUykge1xuICAgIEpTT05fVEFHU1tcIkpTT05fUFJPUEVSVFlcIl0gPSBcIkpTT05fUFJPUEVSVFlcIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX1BST1BFUlRZX1RZUEVEXCJdID0gXCJKU09OX1BST1BFUlRZX1RZUEVEXCI7XG4gICAgSlNPTl9UQUdTW1wiSlNPTl9QUk9QRVJUWV9UWVBFRF9TS0lQX0ZPUkNFRFwiXSA9IFwiSlNPTl9QUk9QRVJUWV9UWVBFRF9TS0lQX0ZPUkNFRFwiO1xuICAgIEpTT05fVEFHU1tcIkpTT05fUFJPUEVSVFlfTkFNRV9NQVBfSU5cIl0gPSBcIkpTT05fUFJPUEVSVFlfTkFNRV9NQVBfSU5cIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX1BST1BFUlRZX05BTUVfTUFQX09VVFwiXSA9IFwiSlNPTl9QUk9QRVJUWV9OQU1FX01BUF9PVVRcIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX1BST1BFUlRZX0ZVTkNfTUFQX0lOXCJdID0gXCJKU09OX1BST1BFUlRZX0ZVTkNfTUFQX0lOXCI7XG4gICAgSlNPTl9UQUdTW1wiSlNPTl9QUk9QRVJUWV9GVU5DX01BUF9PVVRcIl0gPSBcIkpTT05fUFJPUEVSVFlfRlVOQ19NQVBfT1VUXCI7XG4gICAgSlNPTl9UQUdTW1wiSlNPTl9QUk9QRVJUWV9GT1JDRV9CQVNFX1RZUEVcIl0gPSBcIkpTT05fUFJPUEVSVFlfRk9SQ0VfQkFTRV9UWVBFXCI7XG4gICAgSlNPTl9UQUdTW1wiSlNPTl9QUk9QRVJUWV9GT1JDRV9BUlJBWVwiXSA9IFwiSlNPTl9QUk9QRVJUWV9GT1JDRV9BUlJBWVwiO1xuICAgIEpTT05fVEFHU1tcIkpTT05fT0JKRUNUX09OX0FGVEVSX0RFX1NFUklBTElaQVRJT05cIl0gPSBcIkpTT05fT0JKRUNUX09OX0FGVEVSX0RFX1NFUklBTElaQVRJT05cIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX09CSkVDVF9PTl9BRlRFUl9TRVJJQUxJWkFUSU9OX0JFRk9SRV9TVFJJTkdcIl0gPSBcIkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT05fQkVGT1JFX1NUUklOR1wiO1xuICAgIEpTT05fVEFHU1tcIkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT05cIl0gPSBcIkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT05cIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX09CSkVDVF9PTl9CRUZPUkVfU0VSSUFMSVpBVElPTlwiXSA9IFwiSlNPTl9PQkpFQ1RfT05fQkVGT1JFX1NFUklBTElaQVRJT05cIjtcbiAgICBKU09OX1RBR1NbXCJKU09OX09CSkVDVF9PTl9CRUZPUkVfREVfU0VSSUFMSVpBVElPTlwiXSA9IFwiSlNPTl9PQkpFQ1RfT05fQkVGT1JFX0RFX1NFUklBTElaQVRJT05cIjtcbn0pKEpTT05fVEFHUyB8fCAoSlNPTl9UQUdTID0ge30pKTtcbmV4cG9ydCB2YXIgSlNPTl9CQVNFVFlQRVM7XG4oZnVuY3Rpb24gKEpTT05fQkFTRVRZUEVTKSB7XG4gICAgSlNPTl9CQVNFVFlQRVNbXCJzdHJpbmdcIl0gPSBcInN0cmluZ1wiO1xuICAgIEpTT05fQkFTRVRZUEVTW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xuICAgIEpTT05fQkFTRVRZUEVTW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbn0pKEpTT05fQkFTRVRZUEVTIHx8IChKU09OX0JBU0VUWVBFUyA9IHt9KSk7XG4iLCJpbXBvcnQgeyBCQVNFX1NDSEVNRSB9IGZyb20gXCIuL0pzb25Nb2R1bGVDb25zdGFudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUd1aWQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnXG4gICAgICAgIC5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxudmFyIHNlbGZLZXkgPSBjcmVhdGVHdWlkKCkgKyBcIlNFTEZcIjtcbnZhciBNZXRhRGF0YVRhZ05hbWUgPSAnZ2ptZCc7IC8vIEdyb2JheCBKc29uIE1ldGEgRGF0YTtcbnZhciBSZWZsZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmxlY3QoKSB7XG4gICAgfVxuICAgIFJlZmxlY3QuZ2V0UHJvdG90eXBlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYSA9IG9iai5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhID0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuICAgIFJlZmxlY3Quc2V0UHJvdG90eXBlID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG4gICAgICAgIC8vT2JqZWN0LnNldFByb3RvdHlwZU9mKCBvYmogLCBwcm90b3R5cGUgKVxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCBFcnJvciwgcGxlYXNlIHJlcG9ydCB0aGUgc2NlbmFyaW8gdG8gbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmosIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZmxlY3QuZ2V0T3JDcmVhdGVBbGxNZXRhRGF0YSA9IGZ1bmN0aW9uIChvYmosIGNyZWF0ZSkge1xuICAgICAgICBpZiAoY3JlYXRlID09PSB2b2lkIDApIHsgY3JlYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlKG9iaik7XG4gICAgICAgIGlmIChwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90b3R5cGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgYSA9IHByb3RvdHlwZTtcbiAgICAgICAgaWYgKCEoYVsnZ2ptZCddKSkge1xuICAgICAgICAgICAgaWYgKCFjcmVhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhWydnam1kJ10gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYVsnZ2ptZCddO1xuICAgICAgICBpZiAoIWFbcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGFbcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGFbcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuICAgIFJlZmxlY3QuZ2V0T3JDcmVhdGVEZWZpbmVkTWV0YURhdGEgPSBmdW5jdGlvbiAob2JqLCBzY2hlbWUsIGNyZWF0ZSkge1xuICAgICAgICBpZiAoY3JlYXRlID09PSB2b2lkIDApIHsgY3JlYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGEgPSBSZWZsZWN0LmdldE9yQ3JlYXRlQWxsTWV0YURhdGEob2JqLCBjcmVhdGUpO1xuICAgICAgICBpZiAoIWEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoYVtzY2hlbWVdKSkge1xuICAgICAgICAgICAgaWYgKCFjcmVhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhW3NjaGVtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYVtzY2hlbWVdO1xuICAgIH07XG4gICAgLy8gS0VZUyAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5LCBzY2hlbWUpIHtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgICAgIHZhciBhID0gUmVmbGVjdC5nZXRPckNyZWF0ZURlZmluZWRNZXRhRGF0YShvYmosIHNjaGVtZSk7XG4gICAgICAgIGlmICghYSB8fCAhYVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFba2V5XSk7XG4gICAgfTtcbiAgICBSZWZsZWN0LmdldE93bk1ldGFEYXRhS2V5cyA9IGZ1bmN0aW9uIChvYmosIHNjaGVtZSkge1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKG9iaiwgc2VsZktleSwgc2NoZW1lKTtcbiAgICB9O1xuICAgIC8vIEdFVCAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YVRhZywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgc2NoZW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgICAgIHZhciBhID0gUmVmbGVjdC5nZXRPckNyZWF0ZURlZmluZWRNZXRhRGF0YSh0YXJnZXQsIHNjaGVtZSk7XG4gICAgICAgIGlmICghYVtwcm9wZXJ0eUtleV0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIChfYSA9IGFbcHJvcGVydHlLZXldW21ldGFUYWddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH07XG4gICAgUmVmbGVjdC5nZXRPd25NZXRhRGF0YSA9IGZ1bmN0aW9uIChtZXRhVGFnLCB0YXJnZXQsIHNjaGVtZSkge1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0TWV0YWRhdGEobWV0YVRhZywgdGFyZ2V0LCBzZWxmS2V5LCBzY2hlbWUpO1xuICAgIH07XG4gICAgLy8gREVGSU5FIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhRGF0YSA9IGZ1bmN0aW9uIChtZXRhVGFnLCBkYXRhLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBzY2hlbWUpIHtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgICAgIHZhciBhID0gUmVmbGVjdC5nZXRPckNyZWF0ZURlZmluZWRNZXRhRGF0YSh0YXJnZXQsIHNjaGVtZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYVtwcm9wZXJ0eUtleV0pXG4gICAgICAgICAgICBhW3Byb3BlcnR5S2V5XSA9IHt9O1xuICAgICAgICBhW3Byb3BlcnR5S2V5XVttZXRhVGFnXSA9IGRhdGE7XG4gICAgfTtcbiAgICBSZWZsZWN0LmRlZmluZU93bk1ldGFEYXRhID0gZnVuY3Rpb24gKG1ldGFUYWcsIGRhdGEsIHRhcmdldCwgc2NoZW1lKSB7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkgeyBzY2hlbWUgPSBCQVNFX1NDSEVNRTsgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVNZXRhRGF0YShtZXRhVGFnLCBkYXRhLCB0YXJnZXQsIHNlbGZLZXksIHNjaGVtZSk7XG4gICAgfTtcbiAgICAvLyBoYXMgLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS1cbiAgICBSZWZsZWN0Lmhhc01ldGFEYXRhID0gZnVuY3Rpb24gKG1ldGFUYWcsIHRhcmdldCwga2V5LCBzY2hlbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgdmFyIGEgPSBSZWZsZWN0LmdldE9yQ3JlYXRlRGVmaW5lZE1ldGFEYXRhKHRhcmdldCwgc2NoZW1lKTtcbiAgICAgICAgaWYgKGEgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCEoYVtrZXldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIChfYSA9IGFba2V5XVttZXRhVGFnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgfTtcbiAgICBSZWZsZWN0Lmhhc093bk1ldGFEYXRhID0gZnVuY3Rpb24gKG1ldGFUYWcsIHRhcmdldCwgc2NoZW1lKSB7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkgeyBzY2hlbWUgPSBCQVNFX1NDSEVNRTsgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXNNZXRhRGF0YShtZXRhVGFnLCB0YXJnZXQsIHNlbGZLZXksIHNjaGVtZSk7XG4gICAgfTtcbiAgICBSZWZsZWN0LmdldEFsbE1ldGEgPSBmdW5jdGlvbiAob2JqLCBzY2hlbWUpIHtcbiAgICAgICAgaWYgKHNjaGVtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3JDcmVhdGVEZWZpbmVkTWV0YURhdGEob2JqLCBzY2hlbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3JDcmVhdGVBbGxNZXRhRGF0YShvYmosIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVmbGVjdDtcbn0oKSk7XG5leHBvcnQgeyBSZWZsZWN0IH07XG4iLCJpbXBvcnQgeyBCQVNFX1NDSEVNRSB9IGZyb20gXCIuL0pzb25Nb2R1bGVDb25zdGFudHNcIjtcbmltcG9ydCB7IFJlZmxlY3QgfSBmcm9tIFwiLi9SZWZsZWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gaGFzTWV0YURhdGFJblNjaGVtZShtZXRhVGFnLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBzY2hlbWUpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZGF0YSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEobWV0YVRhZywgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIGlmIChkYXRhW3NjaGVtZV0gIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIEdFVCAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFUYWcsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkgeyBzY2hlbWUgPSBCQVNFX1NDSEVNRTsgfVxuICAgIHJldHVybiBSZWZsZWN0LmdldE1ldGFkYXRhKG1ldGFUYWcsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duTWV0YURhdGEobWV0YVRhZywgdGFyZ2V0LCBzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25NZXRhRGF0YShtZXRhVGFnLCB0YXJnZXQsIHNjaGVtZSk7XG59XG4vLyBERUZJTkUgLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS1cbmV4cG9ydCBmdW5jdGlvbiBzZXRNZXRhZGF0YShtZXRhVGFnLCB2YWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgc2NoZW1lKSB7XG4gICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhRGF0YShtZXRhVGFnLCB2YWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgc2NoZW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRPd25NZXRhRGF0YShtZXRhVGFnLCB0YXJnZXQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICBSZWZsZWN0LmRlZmluZU93bk1ldGFEYXRhKG1ldGFUYWcsIHZhbHVlLCB0YXJnZXQsIHNjaGVtZSk7XG59XG4vLyBLRVlTIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duTWV0YURhdGFLZXlzKHRhcmdldCwgc2NoZW1lKSB7XG4gICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgdmFyIGtleXMgPSBSZWZsZWN0LmdldE93bk1ldGFEYXRhS2V5cyh0YXJnZXQsIHNjaGVtZSk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0YURhdGFLZXlzKHRhcmdldCwga2V5LCBzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICB2YXIga2V5cyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCwga2V5LCBzY2hlbWUpO1xuICAgIHJldHVybiBrZXlzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc01ldGFEYXRhKHRhcmdldCwgc2NoZW1lKSB7XG4gICAgdmFyIGEgPSBSZWZsZWN0LmdldEFsbE1ldGEodGFyZ2V0LCBzY2hlbWUpO1xuICAgIGlmICghYSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3RvdHlwZShvYmopIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGUob2JqKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm90b3R5cGUob2JqLCBwcm90b3R5cGUpIHtcbiAgICBSZWZsZWN0LnNldFByb3RvdHlwZShvYmosIHByb3RvdHlwZSk7XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlKG9iaikgPT0gcHJvdG90eXBlO1xufVxuIiwiaW1wb3J0IHsgQkFTRV9TQ0hFTUUsIEpTT05fQkFTRVRZUEVTLCBKU09OX1RBR1MgfSBmcm9tIFwiLi9Kc29uTW9kdWxlQ29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzZXRNZXRhZGF0YSwgc2V0T3duTWV0YURhdGEgfSBmcm9tIFwiLi9Kc29uTW9kdWxlQmFzZUZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbikge1xuICAgIGlmICghb3B0aW9uKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKCFvcHRpb24uc2NoZW1lIHx8IG9wdGlvbi5zY2hlbWUubGVuZ3RoID09IDApXG4gICAgICAgIG9wdGlvbi5zY2hlbWUgPSBbQkFTRV9TQ0hFTUVdO1xuICAgIG9wdGlvbi5tYXBwaW5nRnVuY3Rpb25zID0gbnVsbDtcbiAgICBvcHRpb24udHlwZSA9IG51bGw7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSBudWxsO1xuICAgIG9wdGlvbi5mb3JjZUJhc2VUeXBlID0gbnVsbDtcbiAgICByZXR1cm4gb3B0aW9uO1xufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIHByb3BlcnR5LCB0aGlzIGlzIHRoZSBwcm9wZXJ0eSB0aGF0IG90aGVyIHByb3BlcnRpZXMgdXNlLlxuICogaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHRoZSBtb3JlIHNwZWNpZmlrIHByb3BlcnRpZXMgd2hlbiBwb3NzaWJsZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBKc29uUHJvcGVydHkob3B0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIHZhciBzY2hlbWVzO1xuICAgICAgICBpZiAoIShvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uc2NoZW1lKSkge1xuICAgICAgICAgICAgc2NoZW1lcyA9IFtCQVNFX1NDSEVNRV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb24uc2NoZW1lKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zY2hlbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlbWVzID0gW0JBU0VfU0NIRU1FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtZXMgPSBvcHRpb24uc2NoZW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZW1lcyA9IFtvcHRpb24uc2NoZW1lXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBzY2hlbWVzW2ldO1xuICAgICAgICAgICAgc2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFksIHRydWUsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb24uZm9yY2VCYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uLmZvcmNlQmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBKU09OX0JBU0VUWVBFUy5zdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSlNPTl9CQVNFVFlQRVMubnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIEpTT05fQkFTRVRZUEVTLmJvb2w6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9GT1JDRV9CQVNFX1RZUEUsIG9wdGlvbi5mb3JjZUJhc2VUeXBlLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBzY2hlbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb24uaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHNldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX0ZPUkNFX0FSUkFZLCB0cnVlLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBzY2hlbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgc2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfTkFNRV9NQVBfSU4sIHByb3BlcnR5S2V5LCB0YXJnZXQsIG9wdGlvbi5uYW1lLCBzY2hlbWUpO1xuICAgICAgICAgICAgICAgIHNldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX05BTUVfTUFQX09VVCwgb3B0aW9uLm5hbWUsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uLm1hcHBpbmdGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9GVU5DX01BUF9JTiwgb3B0aW9uLm1hcHBpbmdGdW5jdGlvbnMuaW4sIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG4gICAgICAgICAgICAgICAgc2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRlVOQ19NQVBfT1VULCBvcHRpb24ubWFwcGluZ0Z1bmN0aW9ucy5vdXQsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9UWVBFRCwgb3B0aW9uLnR5cGUsIHRhcmdldCwgcHJvcGVydHlLZXksIHNjaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNraXBGb3JjZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9UWVBFRF9TS0lQX0ZPUkNFRCwgdHJ1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgcHJvcGVydHksIHRoYXQgZW5zdXJlIHdoYXQgZXZlciBpcyBkZXNlcmlhbGl6ZWR8c2VyaWFsaXplZCBpcyBhbiBhcnJheVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBKc29uQXJyYXlQcm9wZXJ0eShvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSB0cnVlO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25OdW1iZXIob3B0aW9uKSB7XG4gICAgb3B0aW9uID0gY2xlYW5Ob25BY2Nlc2libGVTZXR0aW5ncyhvcHRpb24pO1xuICAgIG9wdGlvbi5mb3JjZUJhc2VUeXBlID0gSlNPTl9CQVNFVFlQRVMubnVtYmVyO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25TdHJpbmcob3B0aW9uKSB7XG4gICAgb3B0aW9uID0gY2xlYW5Ob25BY2Nlc2libGVTZXR0aW5ncyhvcHRpb24pO1xuICAgIG9wdGlvbi5mb3JjZUJhc2VUeXBlID0gSlNPTl9CQVNFVFlQRVMuc3RyaW5nO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBib29sZWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBKc29uQm9vbGVhbihvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLmZvcmNlQmFzZVR5cGUgPSBKU09OX0JBU0VUWVBFUy5ib29sO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBjbGFzcyBpbnN0YW5jZSxcbiAqIHdoZW4gZGVzZXJpbGl6aW5nIGl0IHdpbGwgYmUgY3JlYXRlZCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIHdoZW4gc2VyaWFsaXppZ24gaXQgd2lsbCBmb3JjZSBpdCB0aHJvdWdoIHRoZSBwcm90b3R5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBKc29uQ2xhc3NUeXBlZCh0eXBlLCBvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBudW1iZXIgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25BcnJheU51bWJlcihvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLmZvcmNlQmFzZVR5cGUgPSBKU09OX0JBU0VUWVBFUy5udW1iZXI7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSB0cnVlO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBzdHJpbmcgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25BcnJheVN0cmluZyhvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLmZvcmNlQmFzZVR5cGUgPSBKU09OX0JBU0VUWVBFUy5zdHJpbmc7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSB0cnVlO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBib29sZWFuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBKc29uQXJyYXlCb29sZWFuKG9wdGlvbikge1xuICAgIG9wdGlvbiA9IGNsZWFuTm9uQWNjZXNpYmxlU2V0dGluZ3Mob3B0aW9uKTtcbiAgICBvcHRpb24uZm9yY2VCYXNlVHlwZSA9IEpTT05fQkFTRVRZUEVTLmJvb2w7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSB0cnVlO1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY29udmVydHMgdG8gYSBjbGFzc2luc3RhbmNlIGFycmF5XG4gKiB3aGVuIGRlc2VyaWxpemluZyBpdCB3aWxsIGJlIGNyZWF0ZWQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IuXG4gKiB3aGVuIHNlcmlhbGl6aWduIGl0IHdpbGwgZm9yY2UgaXQgdGhyb3VnaCB0aGUgcHJvdG90eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gSnNvbkFycmF5Q2xhc3NUeXBlZCh0eXBlLCBvcHRpb24pIHtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbik7XG4gICAgb3B0aW9uLmlzQXJyYXkgPSB0cnVlO1xuICAgIG9wdGlvbi50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gSnNvblByb3BlcnR5KG9wdGlvbik7XG59XG4vKipcbiAqIFRoaXMgaXMgYSBwcm9wZXJ0eSB0aGF0IGhlbHBzIGVhc2UgbWFwcGluZyBzb21ldGhpbmcgaW4gYW5kIG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gSnNvbk1hcHBpbmcocGFyYW1zKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGNsZWFuIHRoZSBpbnB1dC5cbiAgICB2YXIgb3B0aW9uID0gY2xlYW5Ob25BY2Nlc2libGVTZXR0aW5ncygoX2EgPSBwYXJhbXMub3B0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSk7XG4gICAgLy8gc2V0IHRoZSB0eXBlXG4gICAgaWYgKHBhcmFtcy50eXBlKVxuICAgICAgICBvcHRpb24udHlwZSA9IHBhcmFtcy50eXBlO1xuICAgIC8vIFNldCBtYXBwaW5nIGZ1bmN0aW9ucyBcbiAgICBvcHRpb24ubWFwcGluZ0Z1bmN0aW9ucyA9IHtcbiAgICAgICAgb3V0OiBwYXJhbXMub3V0RnVuY3Rpb24sXG4gICAgICAgIGluOiBwYXJhbXMuaW5GdW5jdGlvbixcbiAgICB9O1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRvIGVhc2UgdGhlIGFjdGlvbiBvZiBoYXZpbmcgYSByZWNvcmQgaW4gdGhlIHN5c3RlbSBidXQgYW4gYXJyYXkgaW4gdGhlIGpzb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25NYXBwaW5nUmVjb3JkSW5BcnJheU91dChvcHRpb24pIHtcbiAgICAvLyBjbGVhbiB0aGUgaW5wdXQuXG4gICAgdmFyIHR5cGUgPSBvcHRpb24udHlwZTtcbiAgICBvcHRpb24gPSBjbGVhbk5vbkFjY2VzaWJsZVNldHRpbmdzKG9wdGlvbiAhPT0gbnVsbCAmJiBvcHRpb24gIT09IHZvaWQgMCA/IG9wdGlvbiA6IHt9KTtcbiAgICB2YXIgb3V0ZnVuYyA9IGZ1bmN0aW9uIChjb2wsIHMpIHsgcmV0dXJuIE9iamVjdC52YWx1ZXMoY29sKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHMocCk7IH0pOyB9O1xuICAgIHZhciBpbmZ1bmMgPSBmdW5jdGlvbiAoY29sLCBkKSB7XG4gICAgICAgIHZhciByID0ge307XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29sLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIG8gPSBkKHApO1xuICAgICAgICAgICAgdmFyIHYgPSBvW29wdGlvbi5LZXlQcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gb1tvcHRpb24uS2V5UHJvcGVydHlOYW1lXSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFmdGVyIGNhbGxpbmcgZnVuY3Rpb24gXCIuY29uY2F0KG9wdGlvbi5LZXlQcm9wZXJ0eU5hbWUsIFwiIGtleSB2YWx1ZSB3YXMgJ1wiKS5jb25jYXQodiwgXCInIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VBZGRvbiA9IHYubGVuZ3RoID4gMCA/ICcsIE5vdGUgdGhhdCBtZXNzYWdlIG11c3QgaGF2ZSAwIEFyZ3VtZW50cywgdGhhdCBhcmVudCBlaXRoZXIgb3B0aW9uYWwgb3IgaGF2ZSBkZWZhdWx0IHZhbHVlcycgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggY2FsbGlnbiBtZXRob2QgJ1wiLmNvbmNhdChvcHRpb24uS2V5UHJvcGVydHlOYW1lLCBcIidcIikuY29uY2F0KG1lc3NhZ2VBZGRvbik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3ZdID0gbztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgb3B0aW9uLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvLyBTZXQgbWFwcGluZyBmdW5jdGlvbnMgXG4gICAgb3B0aW9uLm1hcHBpbmdGdW5jdGlvbnMgPSB7XG4gICAgICAgIG91dDogb3V0ZnVuYyxcbiAgICAgICAgaW46IGluZnVuYyxcbiAgICB9O1xuICAgIHJldHVybiBKc29uUHJvcGVydHkob3B0aW9uKTtcbn1cbmZ1bmN0aW9uIGNsZWFuT2JqZWN0T3B0aW9ucyhvcHRpb24pIHtcbiAgICBpZiAoIW9wdGlvbilcbiAgICAgICAgb3B0aW9uID0ge307XG4gICAgaWYgKCFvcHRpb24ub25BZnRlckRlU2VyaWFsaXphdGlvbikge1xuICAgICAgICBvcHRpb24ub25BZnRlckRlU2VyaWFsaXphdGlvbiA9IGZ1bmN0aW9uIChvKSB7IH07XG4gICAgfVxuICAgIGlmICghb3B0aW9uLnNjaGVtZSB8fCBvcHRpb24uc2NoZW1lLmxlbmd0aCA9PSAwKVxuICAgICAgICBvcHRpb24uc2NoZW1lID0gW0JBU0VfU0NIRU1FXTtcbiAgICByZXR1cm4gb3B0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEpzb25PYmplY3Qob3B0aW9uKSB7XG4gICAgb3B0aW9uID0gY2xlYW5PYmplY3RPcHRpb25zKG9wdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHNjaGVtZXMgPSBvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uc2NoZW1lO1xuICAgICAgICBpZiAoIXNjaGVtZXMgfHwgc2NoZW1lcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHNjaGVtZXMgPSBbQkFTRV9TQ0hFTUVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBzY2hlbWVzW2ldO1xuICAgICAgICAgICAgLy8gU0VSSUFMSVpBVElPTiBcbiAgICAgICAgICAgIGlmIChvcHRpb24ub25BZnRlckRlU2VyaWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICBzZXRPd25NZXRhRGF0YShKU09OX1RBR1MuSlNPTl9PQkpFQ1RfT05fQUZURVJfREVfU0VSSUFMSVpBVElPTiwgdGFyZ2V0LCBvcHRpb24ub25BZnRlckRlU2VyaWFsaXphdGlvbiwgc2NoZW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24ub25BZnRlclNlcmlhbGl6YXRpb25fYmVmb3JlU3RyaW5nKVxuICAgICAgICAgICAgICAgIHNldE93bk1ldGFEYXRhKEpTT05fVEFHUy5KU09OX09CSkVDVF9PTl9BRlRFUl9TRVJJQUxJWkFUSU9OX0JFRk9SRV9TVFJJTkcsIHRhcmdldCwgb3B0aW9uLm9uQWZ0ZXJTZXJpYWxpemF0aW9uX2JlZm9yZVN0cmluZywgc2NoZW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24ub25BZnRlclNlcmlhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgc2V0T3duTWV0YURhdGEoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT04sIHRhcmdldCwgb3B0aW9uLm9uQWZ0ZXJTZXJpYWxpemF0aW9uLCBzY2hlbWUpO1xuICAgICAgICAgICAgLy8gREUgU0VSSUFMSVpBVElPTiBcbiAgICAgICAgICAgIGlmIChvcHRpb24ub25CZWZvcmVTZXJpYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIHNldE93bk1ldGFEYXRhKEpTT05fVEFHUy5KU09OX09CSkVDVF9PTl9CRUZPUkVfU0VSSUFMSVpBVElPTiwgdGFyZ2V0LCBvcHRpb24ub25CZWZvcmVTZXJpYWxpemF0aW9uLCBzY2hlbWUpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5vbkJlZm9yZURlU2VyaWFsaXphdGlvbilcbiAgICAgICAgICAgICAgICBzZXRPd25NZXRhRGF0YShKU09OX1RBR1MuSlNPTl9PQkpFQ1RfT05fQkVGT1JFX0RFX1NFUklBTElaQVRJT04sIHRhcmdldCwgb3B0aW9uLm9uQmVmb3JlRGVTZXJpYWxpemF0aW9uLCBzY2hlbWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGdldE1ldGFkYXRhLCBnZXRPd25NZXRhRGF0YSwgZ2V0T3duTWV0YURhdGFLZXlzLCBnZXRNZXRhRGF0YUtleXMsIGhhc01ldGFEYXRhLCBnZXRQcm90b3R5cGUsIHNldFByb3RvdHlwZSB9IGZyb20gXCIuL0pzb25Nb2R1bGVCYXNlRnVuY3Rpb25cIjtcbmltcG9ydCB7IEJBU0VfU0NIRU1FLCBKU09OX0JBU0VUWVBFUywgSlNPTl9UQUdTLCBOb091dHB1dCB9IGZyb20gXCIuL0pzb25Nb2R1bGVDb25zdGFudHNcIjtcbnZhciBKU09OSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OSGFuZGxlcigpIHtcbiAgICB9XG4gICAgSlNPTkhhbmRsZXIuc2VyaWFsaXplID0gZnVuY3Rpb24gKG9iaiwgc2NoZW1lKSB7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkgeyBzY2hlbWUgPSBCQVNFX1NDSEVNRTsgfVxuICAgICAgICB2YXIgbyA9IEpTT05IYW5kbGVyLnNlcmlhbGl6ZVJhdyhvYmosIHNjaGVtZSk7XG4gICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gQWZ0ZXIgc2VyaWFsaXplIGZ1bmN0aW9uIGdldCBpdCBhbmQgcnVuIGl0LiBcbiAgICAgICAgdmFyIE9iamVjdE1ldGEgPSBnZXRPd25NZXRhRGF0YUtleXMob2JqKTtcbiAgICAgICAgaWYgKE9iamVjdE1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT04pKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGdldE93bk1ldGFEYXRhKEpTT05fVEFHUy5KU09OX09CSkVDVF9PTl9BRlRFUl9TRVJJQUxJWkFUSU9OLCBvYmosIHNjaGVtZSk7XG4gICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICBzdHIgPSBmKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIEpTT05IYW5kbGVyLnNlcmlhbGl6ZVJhdyA9IGZ1bmN0aW9uIChvYmosIHNjaGVtZSwgcGFyZW50TmFtZSkge1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09IHZvaWQgMCkgeyBwYXJlbnROYW1lID0gJ0ZJUlNUJzsgfVxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYmFzZSB0eXBlIGp1c3QgcmV0dXJuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OSGFuZGxlci5kZXNlcmlhbGl6ZUFuZEZvcmNlU2ltcGxlKCdzdHJpbmcnLCBvYmosIHNjaGVtZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBjYXNlIHRoaXMgaXMgYSByZWd1bGFyIG9iamVjdCB3aXRoIG5vIGRlY29yYXRvcnMgXG4gICAgICAgIGlmICghaGFzTWV0YURhdGEob2JqLCBzY2hlbWUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlcmlhbGl6ZWRPYmplY3QgaXMgYSBuZXcgb2JqZWN0LCB3aXRob3V0IG5vbiBKc29ucHJvcGVydGllc1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEVWRU5UIEJGT1JFIFNFUklBTElaQVRJT05cbiAgICAgICAgdmFyIE9iamVjdE1ldGEgPSBnZXRPd25NZXRhRGF0YUtleXMob2JqKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gQWZ0ZXIgc2VyaWFsaXplIGZ1bmN0aW9uIGdldCBpdCBhbmQgcnVuIGl0LiBcbiAgICAgICAgaWYgKE9iamVjdE1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0JFRk9SRV9TRVJJQUxJWkFUSU9OKSkge1xuICAgICAgICAgICAgLy8gZ2V0IG1ldGEgZGF0YSBmdW5jdGlvbiBhbmQgcnVuIGl0IG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gICAgICAgICAgICB2YXIgZiA9IGdldE93bk1ldGFEYXRhKEpTT05fVEFHUy5KU09OX09CSkVDVF9PTl9CRUZPUkVfU0VSSUFMSVpBVElPTiwgb2JqLCBzY2hlbWUpO1xuICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgZihvYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBwcm9wZXJ0eW5hbWVzIGFuZCBsb29wIHRocm91Z2ggXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVzO1xuICAgICAgICBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgLy8gZ2V0IGJhc2ljIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIG1ldGEgPSBnZXRNZXRhRGF0YUtleXMob2JqLCBrZXksIHNjaGVtZSk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc2NoZW1lIHdlIGFyZSBhYm91dCB0byBleHBvcnQgaGF2ZSBUaGUgUHJvcGVydHkgaW4gaXRcbiAgICAgICAgICAgIGlmICghbWV0YS5pbmNsdWRlcyhKU09OX1RBR1MuSlNPTl9QUk9QRVJUWSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSwgYnV0IGlmIHRoZXJlIGlzIGEgbWFwcGVkIG91dCBuYW1lLCBnZXQgdGhhdCBpbnN0ZWFkXG4gICAgICAgICAgICB2YXIgUHJvcGVydHlOYW1lID0ga2V5O1xuICAgICAgICAgICAgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfTkFNRV9NQVBfT1VUKSkge1xuICAgICAgICAgICAgICAgIFByb3BlcnR5TmFtZSA9IGdldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX05BTUVfTUFQX09VVCwgb2JqLCBrZXksIHNjaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBpcyB0eXBlZCwgdGhlbiB3ZSBleGNhbmdlIHRoZSBwcm90b3R5cGVzIGZvciBlYWNoIG9iamVjdCBhcyB3ZSBkZXNlcmlhbGl6ZS4gXG4gICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIGluIGEgZnVuY2l0b24gdG8gbWluaW1pemUgaWYgc3RhdGVtZW50IGNoYW9zO1xuICAgICAgICAgICAgdmFyIHR5cGVkY29udmVyc2lvbiA9IGZ1bmN0aW9uICh2LCBzZXIpIHsgcmV0dXJuIHY7IH07XG4gICAgICAgICAgICB2YXIgc2tpcEZvcmNlVHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfVFlQRURfU0tJUF9GT1JDRUQpKSB7XG4gICAgICAgICAgICAgICAgc2tpcEZvcmNlVHlwZSA9IGdldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX1RZUEVEX1NLSVBfRk9SQ0VELCBvYmosIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX1RZUEVEKSAmJiAhc2tpcEZvcmNlVHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGVkY29udmVyc2lvbiA9IGZ1bmN0aW9uICh2LCBzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHByb3RvdHlwZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXJpbmcgPSAoZ2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfVFlQRUQsIG9iaiwga2V5LCBzY2hlbWUpKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBnZXRQcm90b3R5cGUodik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBwcm90b3R5cGUgc2VyaWFsaXplIHRoZW4gc2V0IHByb3RvdHlwZSBiYWNrIFxuICAgICAgICAgICAgICAgICAgICBzZXRQcm90b3R5cGUodiwgZHVyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBzZXIodik7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3RvdHlwZSh2LCBiZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb25lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIG1hcHBpbmcgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRlVOQ19NQVBfT1VUKSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRGdW5jdGlvbl8xID0gZ2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRlVOQ19NQVBfT1VULCBvYmosIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgX291dEYgPSBmdW5jdGlvbiAobzEpIHsgcmV0dXJuIG91dEZ1bmN0aW9uXzEobzEsIGZ1bmN0aW9uIChvMikgeyByZXR1cm4gdHlwZWRjb252ZXJzaW9uKG8yLCBmdW5jdGlvbiAobzMpIHsgcmV0dXJuIEpTT05IYW5kbGVyLnNlcmlhbGl6ZVJhdyhvMywgc2NoZW1lLCBwYXJlbnROYW1lICsgJzonICsga2V5KTsgfSk7IH0pOyB9O1xuICAgICAgICAgICAgICAgIG91dCA9IF9vdXRGKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRk9SQ0VfQVJSQVkpKSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdHlwZWRjb252ZXJzaW9uKG9ialtrZXldW2pdLCBmdW5jdGlvbiAobykgeyByZXR1cm4gSlNPTkhhbmRsZXIuc2VyaWFsaXplUmF3KG8sIHNjaGVtZSwgcGFyZW50TmFtZSArICc6WycgKyBqICsgJ106JyArIGtleSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqW2tleV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godHlwZWRjb252ZXJzaW9uKG9ialtrZXldLCBmdW5jdGlvbiAobykgeyByZXR1cm4gSlNPTkhhbmRsZXIuc2VyaWFsaXplUmF3KG8sIHNjaGVtZSwgcGFyZW50TmFtZSArICc6JyArIGtleSk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCA9IHR5cGVkY29udmVyc2lvbihvYmpba2V5XSwgZnVuY3Rpb24gKG8pIHsgcmV0dXJuIEpTT05IYW5kbGVyLnNlcmlhbGl6ZVJhdyhvLCBzY2hlbWUsIHBhcmVudE5hbWUgKyAnOicgKyBrZXkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhBTkRMRSBGb3JjZSBUeXBpbmdcbiAgICAgICAgICAgIGlmIChtZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX0ZPUkNFX0JBU0VfVFlQRSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZWtleV8xID0gZ2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRk9SQ0VfQkFTRV9UWVBFLCBvYmosIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udkZ1bmMgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gSlNPTkhhbmRsZXIuZGVzZXJpYWxpemVBbmRGb3JjZVNpbXBsZSh0eXBla2V5XzEsIGUsIHNjaGVtZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRk9SQ0VfQVJSQVkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gb3V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3b3V0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IHRlbXAubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3b3V0LnB1c2goY29udkZ1bmModGVtcFtpXzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gbmV3b3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gY29udkZ1bmMob2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtQcm9wZXJ0eU5hbWVdID0gb3V0O1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gQWZ0ZXIgc2VyaWFsaXplIGZ1bmN0aW9uIGdldCBpdCBhbmQgcnVuIGl0LiBcbiAgICAgICAgaWYgKE9iamVjdE1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT05fQkVGT1JFX1NUUklORykpIHtcbiAgICAgICAgICAgIHZhciBmID0gZ2V0T3duTWV0YURhdGEoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX1NFUklBTElaQVRJT05fQkVGT1JFX1NUUklORywgb2JqLCBzY2hlbWUpO1xuICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgZihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBKU09OSGFuZGxlci5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGpzb24sIHNjaGVtZSwgd3JpdGVPdXQpIHtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7IHNjaGVtZSA9IEJBU0VfU0NIRU1FOyB9XG4gICAgICAgIGlmICghd3JpdGVPdXQpIHtcbiAgICAgICAgICAgIHdyaXRlT3V0ID0gTm9PdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YganNvbjtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHdyaXRlT3V0Lm91dEVycm9yKCdDYW5ub3QgZGVyc2VyaWFsaXplIHR5cGUgb2YgJyArIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5kZXNlcmlhbGl6ZVJhdyh0YXJnZXQsIGpzb25baV0sIHNjaGVtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplUmF3KHRhcmdldCwganNvbiwgc2NoZW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkhhbmRsZXIuZGVzZXJpYWxpemVBbmRGb3JjZVNpbXBsZSA9IGZ1bmN0aW9uICh0eXBla2V5LCBvYmosIHNjaGVtZSkge1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgdmFyIG91dCA9IG9iajtcbiAgICAgICAgdmFyIGNvbnZGdW5jID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGU7IH07XG4gICAgICAgIHN3aXRjaCAodHlwZWtleSkge1xuICAgICAgICAgICAgY2FzZSBKU09OX0JBU0VUWVBFUy5ib29sOlxuICAgICAgICAgICAgICAgIGNvbnZGdW5jID0gZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBCb29sZWFuKGlucHV0KTsgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSlNPTl9CQVNFVFlQRVMuc3RyaW5nOlxuICAgICAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBzdHIgPSBvYmoucmVwbGFjZUFsbChcIjw8ZHA+PlwiLCdcXFxcXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgICAgICAvL3N0ciA9IHN0ci5yZXBsYWNlQWxsKFwiPDxkcD4+XCIsJ1xcXFxcIicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNNZXRhRGF0YShvYmosIHNjaGVtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OSGFuZGxlci5zZXJpYWxpemUob2JqLCBzY2hlbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RyID0gc3RyLnJlcGxhY2VBbGwoJ1xcXFxcIicsXCI8PGRwPj5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBzdHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnZGdW5jID0gZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBTdHJpbmcoaW5wdXQpOyB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBKU09OX0JBU0VUWVBFUy5udW1iZXI6XG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udkZ1bmMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyVmFsdWUgPSBOdW1iZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihudW1iZXJWYWx1ZSkgPyAwIDogbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvdXQgPSBjb252RnVuYyhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgSlNPTkhhbmRsZXIuZGVzZXJpYWxpemVSYXcgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmosIHNjaGVtZSwgcGFyZW50TmFtZSkge1xuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHsgc2NoZW1lID0gQkFTRV9TQ0hFTUU7IH1cbiAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09IHZvaWQgMCkgeyBwYXJlbnROYW1lID0gJ0ZJUlNUJzsgfVxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXJpYWxpemVkT2JqZWN0IGlzIGEgbmV3IG9iamVjdCwgd2l0aG91dCBub24gSnNvbnByb3BlcnRpZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIC8vIEVWRU5UIE9OIEFGVEVSIERFU0VSSUFMSVpFXG4gICAgICAgIHZhciBPYmplY3RNZXRhID0gZ2V0T3duTWV0YURhdGFLZXlzKHRhcmdldCk7XG4gICAgICAgIGlmIChPYmplY3RNZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX09CSkVDVF9PTl9CRUZPUkVfREVfU0VSSUFMSVpBVElPTikpIHtcbiAgICAgICAgICAgIC8vIGdldCBtZXRhIGRhdGEgZnVuY3Rpb24gYW5kIHJ1biBpdCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdFxuICAgICAgICAgICAgdmFyIGYgPSBnZXRPd25NZXRhRGF0YShKU09OX1RBR1MuSlNPTl9PQkpFQ1RfT05fQkVGT1JFX0RFX1NFUklBTElaQVRJT04sIHJlc3VsdCwgc2NoZW1lKTtcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGYocmVzdWx0LCBvYmopO1xuICAgICAgICAgICAgLy8gaW5jYXNlIHRoZSBCZWZvcmUgaGFzIGNoYW5nZWQgdGhlIHR5cGUgXG4gICAgICAgICAgICBpZiAoIUpTT05IYW5kbGVyLmFyZVNhbWVQcm90b3R5cGVzKHJlc3VsdCwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGdldFByb3RvdHlwZShyZXN1bHQpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBwcm9wZXJ0eW5hbWVzIGFuZCBsb29wIHRocm91Z2ggXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgICAgICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgLy8gZ2V0IGJhc2ljIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIGluS2V5ID0ga2V5O1xuICAgICAgICAgICAgdmFyIG1ldGEgPSBnZXRNZXRhRGF0YUtleXModGFyZ2V0LCBrZXksIHNjaGVtZSk7XG4gICAgICAgICAgICB2YXIgUHJvcGVydHlOYW1lID0ga2V5O1xuICAgICAgICAgICAgaWYgKG1ldGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBPdXQga2V5LCBjb252ZXJ0IGl0IHRvIGFuIElOIEtleSwgc28gd2UgY2FuIGdldCB0aGUgcmlnaHQgbWV0YSBkYXRhLiBcbiAgICAgICAgICAgIGlmIChtZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX05BTUVfTUFQX0lOKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBvdXQga2V5IGZyb20gdGhlIGluIEtleVxuICAgICAgICAgICAgICAgIGtleSA9IGdldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX05BTUVfTUFQX0lOLCBwcm90b3R5cGUsIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoYXQgYSBrZXkgYmVsb25nZWQgdG8gYW5vdGhlciBzY2hlbWUsIHRoZW4gdGhlIGtleSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAvL1x0aWYoa2V5PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIC8vXHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vXHR9IFxuICAgICAgICAgICAgICAgIG1ldGEgPSBnZXRNZXRhRGF0YUtleXModGFyZ2V0LCBrZXksIHNjaGVtZSk7XG4gICAgICAgICAgICAgICAgUHJvcGVydHlOYW1lID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVyZSBpcyBhbnksIEdlbmVyaWNzIHRha2UgcHJpb3JpdHlcbiAgICAgICAgICAgIHZhciBvdXQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNvbnN0ciA9IGdldE1ldGFkYXRhKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX1RZUEVELCBwcm90b3R5cGUsIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgIGlmIChtZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX0ZVTkNfTUFQX0lOKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbkZ1bmN0aW9uID0gZ2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRlVOQ19NQVBfSU4sIHByb3RvdHlwZSwga2V5LCBzY2hlbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gaW5GdW5jdGlvbihvYmpbaW5LZXldLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gSlNPTkhhbmRsZXIuZGVzZXJpYWxpemVSYXcoY29uc3RyLCBvYmosIHNjaGVtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gaW5GdW5jdGlvbihvYmpbaW5LZXldLCBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRk9SQ0VfQVJSQVkpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgbmVlZHMgZGVzZXJpYWxpemluZ1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0XzEgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRfMSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBKU09OSGFuZGxlci5kZXNlcmlhbGl6ZVJhdyhjb25zdHIsIGUsIHNjaGVtZSwga2V5KTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHN0YXRlZCBhYm92ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzaW1wbGUgdHlwZS4gRVZFTiBhZnRlciBkZXNlcmlhbGl6aW5nXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnQyID0gZnVuY3Rpb24gKGUsIHR5cGVrZXkpIHsgcmV0dXJuIGNvbnZlcnRfMShlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YS5pbmNsdWRlcyhKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9GT1JDRV9CQVNFX1RZUEUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnQyID0gZnVuY3Rpb24gKGUsIHR5cGVrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OSGFuZGxlci5kZXNlcmlhbGl6ZUFuZEZvcmNlU2ltcGxlKHR5cGVrZXksIGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgc3RhdGVkIGFib3ZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0eXBla2V5ID0gZ2V0TWV0YWRhdGEoSlNPTl9UQUdTLkpTT05fUFJPUEVSVFlfRk9SQ0VfQkFTRV9UWVBFLCBwcm90b3R5cGUsIGtleSwgc2NoZW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9ialtpbktleV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBvYmpbaW5LZXldW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNvbnZlcnQyKGUsIHR5cGVrZXkpO1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCA9IEpTT05IYW5kbGVyLmRlc2VyaWFsaXplUmF3KGNvbnN0ciwgb2JqW2luS2V5XSwgc2NoZW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRhLmluY2x1ZGVzKEpTT05fVEFHUy5KU09OX1BST1BFUlRZX0ZPUkNFX0JBU0VfVFlQRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVLZXkgPSBnZXRNZXRhZGF0YShKU09OX1RBR1MuSlNPTl9QUk9QRVJUWV9GT1JDRV9CQVNFX1RZUEUsIHRhcmdldCwga2V5LCBzY2hlbWUpO1xuICAgICAgICAgICAgICAgICAgICBvdXQgPSBKU09OSGFuZGxlci5kZXNlcmlhbGl6ZUFuZEZvcmNlU2ltcGxlKHR5cGVLZXksIG9ialtpbktleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gb2JqW2luS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbUHJvcGVydHlOYW1lXSA9IG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8zKGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVWRU5UIE9OIEFGVEVSIERFU0VSSUFMSVpFXG4gICAgICAgIE9iamVjdE1ldGEgPSBnZXRPd25NZXRhRGF0YUtleXMocmVzdWx0KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gQWZ0ZXIgc2VyaWFsaXplIGZ1bmN0aW9uIGdldCBpdCBhbmQgcnVuIGl0LiBcbiAgICAgICAgaWYgKE9iamVjdE1ldGEuaW5jbHVkZXMoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX0RFX1NFUklBTElaQVRJT04pKSB7XG4gICAgICAgICAgICAvLyBnZXQgbWV0YSBkYXRhIGZ1bmN0aW9uIGFuZCBydW4gaXQgb24gdGhlIHJlc3VsdGluZyBvYmplY3RcbiAgICAgICAgICAgIHZhciBmID0gZ2V0T3duTWV0YURhdGEoSlNPTl9UQUdTLkpTT05fT0JKRUNUX09OX0FGVEVSX0RFX1NFUklBTElaQVRJT04sIHJlc3VsdCwgc2NoZW1lKTtcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgIGYocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSlNPTkhhbmRsZXIuY2hhbmdlUHJvdG90eXBlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGUoc291cmNlKTtcbiAgICAgICAgc2V0UHJvdG90eXBlKHRhcmdldCwgcHJvdG90eXBlKTtcbiAgICB9O1xuICAgIEpTT05IYW5kbGVyLmFyZVNhbWVQcm90b3R5cGVzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUxID0gZ2V0UHJvdG90eXBlKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm90b3R5cGUyID0gZ2V0UHJvdG90eXBlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUxID09IHByb3RvdHlwZTI7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkhhbmRsZXI7XG59KCkpO1xuZXhwb3J0IHsgSlNPTkhhbmRsZXIgfTtcbiIsIiBcbmltcG9ydCB7IEdyb2JDb2xsZWN0aW9uICwgR3JvYkdyb3VwICwgdHlwZSBHcm9iTm9kZVR5cGUgLCBHcm9iRGVyaXZlZE5vZGUsIEdyb2JEZXJpdmVkT3JpZ2luLCBHcm9iRml4ZWROb2RlLCBUVFJQR1N5c3RlbSAsIHV1aWR2NCB9IGZyb20gXCJ0dHJwZy1zeXN0ZW0tZ3JhcGhcIjtcbmltcG9ydCB7IEpzb25PYmplY3QsIEpzb25NYXBwaW5nUmVjb3JkSW5BcnJheU91dCwgSnNvbkNsYXNzVHlwZWQsIEpzb25TdHJpbmcsIEpzb25OdW1iZXIsIEpzb25BcnJheUNsYXNzVHlwZWQgfSBmcm9tIFwiZ3JvYmF4LWpzb24taGFuZGxlclwiO1xuaW1wb3J0IHsgQkFTRV9TQ0hFTUUgfSBmcm9tIFwiZ3JvYmF4LWpzb24taGFuZGxlclwiO1xuIFxuXG4vLyBpZiBzb21ldGhpbmcgaXMgQUdyYXBoSXRlbSBcbi8qXG5ASnNvblN0cmluZygpIFxucHVibGljIG5hbWUgO1xuKi9cbi8vIG9yaWdpbnNcbmV4cG9ydCBjbGFzcyBHcm9iSkRlcml2ZWRPcmlnaW4gZXh0ZW5kcyBHcm9iRGVyaXZlZE9yaWdpbiB7IFxuXHRASnNvblN0cmluZygpXG5cdHB1YmxpYyBzeW1ib2w6IHN0cmluZzsgXG5cdFxuXHRASnNvblN0cmluZygpXG5cdHB1YmxpYyBvcmlnaW5LZXk6IHN0cmluZyA7XG59XG5cbiBcbi8vIE5PREVTICBcbmV4cG9ydCBjbGFzcyBHcm9iSkRlcml2ZWROb2RlIGV4dGVuZHMgR3JvYkRlcml2ZWROb2RlIHtcblx0QEpzb25TdHJpbmcoKSBcblx0cHVibGljIG5hbWUgO1xuXG5cdEBKc29uU3RyaW5nKHtuYW1lIDogJ2NhbGN1bGF0aW9uU3RyaW5nJ30pXG5cdHB1YmxpYyBjYWxjOnN0cmluZztcblxuXHRASnNvbkFycmF5Q2xhc3NUeXBlZChHcm9iSkRlcml2ZWRPcmlnaW4se25hbWU6J2NhbGNPcmlnaW5zJ30pXG5cdHB1YmxpYyBvcmlnaW5zIDogR3JvYkpEZXJpdmVkT3JpZ2luW107XG59IFxuZXhwb3J0IGNsYXNzIEdyb2JKRml4ZWROb2RlIGV4dGVuZHMgR3JvYkZpeGVkTm9kZSB7XG5cblx0QEpzb25TdHJpbmcoKSBcblx0cHVibGljIG5hbWUgO1xuXG5cdEBKc29uTnVtYmVyKHtuYW1lIDogJ3N0YW5kYXJkVmFsdWUnfSlcblx0cHVibGljIF9fX3ZhbHVlOm51bWJlclxufVxuZXhwb3J0IHR5cGUgR3JvYkpOb2RlVHlwZSA9IEdyb2JKRGVyaXZlZE5vZGUgfCBHcm9iSkZpeGVkTm9kZTtcblxuIFxuXG4vLyAgQ09MTEVDVElPTlMgXG5leHBvcnQgY2xhc3MgR3JvYkNvbGxlY3Rpb25EZXJpdmVkIGV4dGVuZHMgR3JvYkNvbGxlY3Rpb248R3JvYkpEZXJpdmVkTm9kZT57IFxuXHRASnNvblN0cmluZygpIFxuXHRwdWJsaWMgbmFtZSA7XG5cdFxuXHRASnNvbk1hcHBpbmdSZWNvcmRJbkFycmF5T3V0KHtLZXlQcm9wZXJ0eU5hbWU6J2dldE5hbWUnLCBuYW1lOidkYXRhJyx0eXBlOkdyb2JKRGVyaXZlZE5vZGUgfSlcblx0bm9kZXNfbmFtZXM6IFJlY29yZDxzdHJpbmcsIEdyb2JKRGVyaXZlZE5vZGU+ID0ge31cbn0gXG5leHBvcnQgY2xhc3MgR3JvYkNvbGxlY3Rpb25GaXhlZCBleHRlbmRzIEdyb2JDb2xsZWN0aW9uPEdyb2JKRml4ZWROb2RlPntcblxuXHRASnNvblN0cmluZygpIFxuXHRwdWJsaWMgbmFtZSA7XG5cblx0QEpzb25NYXBwaW5nUmVjb3JkSW5BcnJheU91dCh7S2V5UHJvcGVydHlOYW1lOidnZXROYW1lJywgbmFtZTonZGF0YScsdHlwZTpHcm9iSkZpeGVkTm9kZSAgfSlcblx0bm9kZXNfbmFtZXM6IFJlY29yZDxzdHJpbmcsIEdyb2JKRml4ZWROb2RlPiA9IHt9XG59XG5cblxuXG5cblxuLy8gIEdST1VQUyBcbmV4cG9ydCBjbGFzcyBHcm9iR3JvdXBEZXJpdmVkIGV4dGVuZHMgR3JvYkdyb3VwPEdyb2JEZXJpdmVkTm9kZT57XG5cdFxuXHRASnNvblN0cmluZygpIFxuXHRwdWJsaWMgbmFtZSA7XG5cblx0QEpzb25NYXBwaW5nUmVjb3JkSW5BcnJheU91dCh7S2V5UHJvcGVydHlOYW1lOidnZXROYW1lJywgbmFtZTonZGF0YScsdHlwZSA6R3JvYkNvbGxlY3Rpb25EZXJpdmVkICB9KVxuXHRjb2xsZWN0aW9uc19uYW1lczogUmVjb3JkPHN0cmluZywgR3JvYkNvbGxlY3Rpb25EZXJpdmVkID4gPSB7fTtcblxufSBcbmV4cG9ydCBjbGFzcyBHcm9iR3JvdXBGaXhlZCBleHRlbmRzIEdyb2JHcm91cDxHcm9iRml4ZWROb2RlPntcblx0XG5cdEBKc29uU3RyaW5nKCkgXG5cdHB1YmxpYyBuYW1lIDtcblxuXHRASnNvbk1hcHBpbmdSZWNvcmRJbkFycmF5T3V0KHtLZXlQcm9wZXJ0eU5hbWU6J2dldE5hbWUnLCBuYW1lOidkYXRhJywgdHlwZSA6R3JvYkNvbGxlY3Rpb25GaXhlZCAgfSlcblx0Y29sbGVjdGlvbnNfbmFtZXM6IFJlY29yZDxzdHJpbmcsR3JvYkNvbGxlY3Rpb25GaXhlZD4gPSB7fTtcblxufVxuXG5cblxuXG5cbiBcbmV4cG9ydCBjbGFzcyBUVFJQR19TQ0hFTUVTIHsgXG5cdHN0YXRpYyBQUkVWSUVXID0nbWluaSc7XG59IFxuXG4vKipcbiAqICBoYW5kbGVzIE1vZGVsIG9wZXJhdGlvbnMgYW5kIERhdGEgQ29udGFpbm1lbnQsIFxuICogRW5zdXJlcyB0aGF0IGRhdGEgaXMgbWFpbnRhaW5lZCwgYXMgd2VsbCBhcyBncmFwaGxpbmtzXG4qL1xuQEpzb25PYmplY3Qoe1xuXHRvbkJlZm9yZVNlcmlhbGl6YXRpb246KHNlbGY6VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZykgPT4ge30sXG5cdG9uQWZ0ZXJEZVNlcmlhbGl6YXRpb246KHNlbGY6VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZywgLi4uYXJncyApID0+IHtcblx0XHRcblx0XHQvLyBhZGQgZGVyaXZlZCBhbmQgZml4ZWQgdG8gZ3JvdXBzIFxuXHRcdGlmICggIXNlbGYuZml4ZWRcdCApe1xuXHRcdFx0c2VsZi5fY3JlYXRlR3JvdXAoJ2ZpeGVkJyk7XG5cdFx0XHRzZWxmLmZpeGVkXHQgPSBzZWxmLl9nZXRHcm91cCgnZml4ZWQnKVx0IGFzIEdyb2JHcm91cEZpeGVkXHQ7XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmRhdGFbJ2ZpeGVkJ10gPSBzZWxmLmZpeGVkO1xuXHRcdH1cblx0XHRpZiAoICFzZWxmLmRlcml2ZWQgKXtcblx0XHRcdHNlbGYuX2NyZWF0ZUdyb3VwKCdkZXJpdmVkJyk7XG5cdFx0XHRzZWxmLmRlcml2ZWQgPSBzZWxmLl9nZXRHcm91cCgnZGVyaXZlZCcpIGFzIEdyb2JHcm91cERlcml2ZWQ7XHRcblx0XHR9ZWxzZXtcblx0XHRcdHNlbGYuZGF0YVsnZGVyaXZlZCddID0gc2VsZi5kZXJpdmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvciBhbGwgZ3JvdXBzIFxuXHRcdGZvcihjb25zdCBncm91cF9rZXkgaW4gKHNlbGYgYXMgYW55KS5kYXRhICl7XG5cdFx0XHRjb25zdCBncm91cCA9IChzZWxmIGFzIGFueSkuZGF0YVtncm91cF9rZXldO1xuXHRcdFx0Z3JvdXAucGFyZW50ID0gc2VsZjtcblxuXHRcdFx0Zm9yKGNvbnN0IGNvbF9rZXkgaW4gKGdyb3VwIGFzIGFueSkuY29sbGVjdGlvbnNfbmFtZXMgKXtcblx0XHRcdFx0Y29uc3QgY29sbGVjdGlvbiA6IEdyb2JDb2xsZWN0aW9uPEdyb2JOb2RlVHlwZT4gPSBncm91cC5jb2xsZWN0aW9uc19uYW1lc1tjb2xfa2V5XTtcblx0XHRcdFx0Y29sbGVjdGlvbi5wYXJlbnQgPSBncm91cDtcblx0XHRcdFx0Z3JvdXAuY29sbGVjdGlvbnNfbmFtZXNbY29sbGVjdGlvbi5nZXROYW1lKCldID0gY29sbGVjdGlvbjtcblxuXHRcdFx0XHRmb3IoIGNvbnN0IG5vZGVfa2V5IGluIChjb2xsZWN0aW9uIGFzIGFueSkubm9kZXNfbmFtZXMgKXtcblx0XHRcdFx0XHRjb25zdCBub2RlID0gKGNvbGxlY3Rpb24gYXMgYW55KS5ub2Rlc19uYW1lc1tub2RlX2tleV07XG5cdFx0XHRcdFx0bm9kZS5wYXJlbnQgPSBjb2xsZWN0aW9uO1xuXHRcdFx0XHRcdGNvbGxlY3Rpb24ubm9kZXNfbmFtZXNbbm9kZS5nZXROYW1lKCldID0gbm9kZTtcblxuXHRcdFx0XHRcdGNvbnN0IG9yaWdpbnMgOiBHcm9iRGVyaXZlZE9yaWdpbltdID0gbm9kZS5vcmlnaW5zID8/IFtdO1xuXHRcdFx0XHRcdG9yaWdpbnMuZm9yRWFjaCggb3JpZ2luICA9PiB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IG9yaWdpbi5vcmlnaW5LZXkuc3BsaXQoJy4nKTtcblx0XHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IHNlbGYuZ2V0Tm9kZShrZXlzWzBdIGFzIGFueSxrZXlzWzFdLGtleXNbMl0pXG5cdFx0XHRcdFx0XHRvcmlnaW4ub3JpZ2luID0gdGFyZ2V0O1xuXG5cdFx0XHRcdFx0XHRub2RlLmFkZERlcGVuZGVuY3kodGFyZ2V0KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgZ3JvdXBzID0gT2JqZWN0LnZhbHVlcygoc2VsZiBhcyBhbnkpLmRhdGEpOyBcblx0fVxufSlcbmV4cG9ydCBjbGFzcyBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nIGV4dGVuZHMgVFRSUEdTeXN0ZW0ge1xuXHQgIFxuXHRASnNvbkNsYXNzVHlwZWQgKCBHcm9iR3JvdXBGaXhlZCApXG5cdHB1YmxpYyBmaXhlZCBcdDogR3JvYkdyb3VwRml4ZWRcdDtcblxuXHRASnNvbkNsYXNzVHlwZWQgKCBHcm9iR3JvdXBEZXJpdmVkIClcblx0cHVibGljIGRlcml2ZWQgXHQ6IEdyb2JHcm91cERlcml2ZWRcdDtcblxuXHRASnNvblN0cmluZygpXG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W0JBU0VfU0NIRU1FLFRUUlBHX1NDSEVNRVMuUFJFVklFV119KVxuXHRwdWJsaWMgYXV0aG9yIDogc3RyaW5nID0gXCJcIjtcblxuXHRASnNvblN0cmluZygpXG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W0JBU0VfU0NIRU1FLFRUUlBHX1NDSEVNRVMuUFJFVklFV119KVxuXHRwdWJsaWMgdmVyc2lvbjogc3RyaW5nID0gXCJcIjtcblx0XG5cdEBKc29uU3RyaW5nKClcblx0QEpzb25TdHJpbmcoe3NjaGVtZTpbQkFTRV9TQ0hFTUUsVFRSUEdfU0NIRU1FUy5QUkVWSUVXXX0pXG5cdHB1YmxpYyBzeXN0ZW1Db2RlTmFtZTpzdHJpbmcgPSB1dWlkdjQoKTtcblx0XG5cdEBKc29uU3RyaW5nKClcblx0QEpzb25TdHJpbmcoe3NjaGVtZTpbQkFTRV9TQ0hFTUUsVFRSUEdfU0NIRU1FUy5QUkVWSUVXXX0pXG5cdHB1YmxpYyBzeXN0ZW1OYW1lOnN0cmluZyA9IFwiXCI7XG5cdFxuXHRwdWJsaWMgY29uc3RydWN0b3IoKXtcblx0XHRzdXBlcigpOyBcblx0fVxuXG5cblx0c2V0RGVmYXVsdFZhbHVlcyggZGVmdWFsdFZhbHVlcyA6IHtncm91cDpzdHJpbmcsIGNvbDpzdHJpbmcgLCBrZXk6c3RyaW5nICwgdmFsdWV9W10gKXtcblxuXHRcdGxldCBvYmogPSB7fTtcblx0XHRjb25zdCBncm91cEtleSA9ICdkZXJpdmVkJztcblx0XHRjb25zdCBjb2xLZXlzID0gT2JqZWN0LmtleXModGhpcy5kZXJpdmVkLmNvbGxlY3Rpb25zX25hbWVzKTtcblx0XHRmb3IgKGxldCBjID0gMDsgYyA8IE9iamVjdC5rZXlzKHRoaXMuZGVyaXZlZC5jb2xsZWN0aW9uc19uYW1lcykubGVuZ3RoOyBjKyspIHtcblx0XHRcdGNvbnN0IGNvbEtleSA9IGNvbEtleXNbY107XG5cdFx0XHRjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5kZXJpdmVkLmNvbGxlY3Rpb25zX25hbWVzW2NvbEtleV07XG5cblx0XHRcdGNvbnN0IG5vZGVLZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbi5ub2Rlc19uYW1lcyk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVLZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IG5vZGVLZXkgPSBub2RlS2V5c1tpXTtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGNvbGxlY3Rpb24ubm9kZXNfbmFtZXNbbm9kZUtleV07XG5cdFx0XHRcdFxuXHRcdFx0XHRvYmpbZ3JvdXBLZXkgKycuJysgY29sS2V5ICsnLicrIG5vZGVLZXldID0gKCkgPT4gbm9kZS5zZXRWYWx1ZSggbm9kZS5nZXRWYWx1ZSgpID8/IDAgKVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG59XG5cblxuIiwiaW1wb3J0IHsgQkFTRV9TQ0hFTUUsIEpzb25OdW1iZXIgfSBmcm9tIFwiZ3JvYmF4LWpzb24taGFuZGxlclwiO1xuaW1wb3J0IHsga2V5TWFuYWdlckluc3RhbmNlIH0gZnJvbSBcInR0cnBnLXN5c3RlbS1ncmFwaFwiO1xuaW1wb3J0IHsgSnNvbkJvb2xlYW4sIEpzb25PYmplY3QsIEpzb25Qcm9wZXJ0eSwgSnNvblN0cmluZyB9IGZyb20gXCJncm9iYXgtanNvbi1oYW5kbGVyXCI7XG5cblxuZXhwb3J0IGNsYXNzIFN5c3RlbVByZXZpZXdTY2hlbWVzeyBcblx0c3RhdGljIEJBU0UgPSBCQVNFX1NDSEVNRTtcblx0c3RhdGljIFBBR0UgXHQ9ICdQQUdFJzsgXG59XG5cbkBKc29uT2JqZWN0KHtcblx0XG59KVxuZXhwb3J0IGNsYXNzIFN5c3RlbVByZXZpZXcge1xuXG5cblx0QEpzb25OdW1iZXIoe3NjaGVtZTpbU3lzdGVtUHJldmlld1NjaGVtZXMuQkFTRSAsIFN5c3RlbVByZXZpZXdTY2hlbWVzLlBBR0VdfSlcblx0cHVibGljIGlkIDogbnVtYmVyIDtcblx0cHVibGljIGZpbGVQYXRoOnN0cmluZyA7XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKCl7XG5cdFx0XG5cdH1cblx0cHVibGljIGluaXQoKXtcblx0XHR0aGlzLmF1dGhvciA9IFwiZ3JvYmF4XCI7XG5cdFx0dGhpcy52ZXJzaW9uID0gXCIwLjAuMVwiO1x0XG5cdFx0dGhpcy5jb2RlID0gXCJncm9iZG5kXCI7XG5cdFx0dGhpcy5uYW1lID0gXCJHcm9iYXgnIERuRCBUVFBSUEdcIjtcblx0fVxuXG5cdEBKc29uQm9vbGVhbih7c2NoZW1lOltTeXN0ZW1QcmV2aWV3U2NoZW1lcy5CQVNFXX0pXG5cdHB1YmxpYyBpc0VkaXRhYmxlXHRcdDogYm9vbGVhbiA9IHRydWUgO1xuXG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W1N5c3RlbVByZXZpZXdTY2hlbWVzLkJBU0VdfSlcblx0cHVibGljIGF1dGhvclx0XHRcdDogc3RyaW5nIDtcblx0XG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W1N5c3RlbVByZXZpZXdTY2hlbWVzLkJBU0UsU3lzdGVtUHJldmlld1NjaGVtZXMuUEFHRV19KVxuXHRwdWJsaWMgdmVyc2lvblx0XHRcdDogc3RyaW5nIDtcblx0XG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W1N5c3RlbVByZXZpZXdTY2hlbWVzLkJBU0UsU3lzdGVtUHJldmlld1NjaGVtZXMuUEFHRV19KVxuXHRwdWJsaWMgY29kZVx0OiBzdHJpbmcgO1x0XG5cblx0QEpzb25TdHJpbmcoe3NjaGVtZTpbU3lzdGVtUHJldmlld1NjaGVtZXMuQkFTRSxTeXN0ZW1QcmV2aWV3U2NoZW1lcy5QQUdFXX0pXG5cdHB1YmxpYyBuYW1lXHRcdDogc3RyaW5nIDtcblx0XG5cdHB1YmxpYyBmb2xkZXJQYXRoXHRcdDogc3RyaW5nIDtcblx0cHVibGljIGZvbGRlck5hbWVcdFx0OiBzdHJpbmcgO1xuXHRcbn1cblxuXG5leHBvcnQgY2xhc3MgRmlsbGVkU3lzdGVtUHJldmlldyAgZXh0ZW5kcyBTeXN0ZW1QcmV2aWV3ICB7XG5cdHB1YmxpYyBjb25zdHJ1Y3Rvcigpe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5hdXRob3IgPSBcImdyb2JheFwiO1xuXHRcdHRoaXMudmVyc2lvbiA9IFwiMC4wLjFcIjtcblx0XHR0aGlzLmNvZGUgPSBcImdyb2JkbmRcIjtcblx0XHR0aGlzLm5hbWUgPSBcIkdyb2JheCcgRG5EIFRUUFJQR1wiO1xuXHR9XG59IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBzcGVjaWFsXHQ9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHRleHQgIFx0PSBcIkJhc2ljIGluZm9ybWF0aW9uIGFuZCBzZXR0aW5nc1wiO1xuXHRleHBvcnQgbGV0IHRpdGxlIFx0PSBcIkhvbWVcIjtcblxuXHRsZXQgYWN0aXZlO1xuXHRleHBvcnQgZnVuY3Rpb24gc2V0QWN0aXZlKCB0byA6IGJvb2xlYW4pe1xuXHRcdGFjdGl2ZSA9IHRvO1xuXHR9XG5cdGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXHRcblx0ZnVuY3Rpb24gb25DbGljaygpeyBcblx0XHRkaXNwYXRjaCgnY2xpY2snKVxuXHR9XG48L3NjcmlwdD5cbjxkaXYgY2xhc3M9eyBzcGVjaWFsID8gXCJNZW51U0J0blwiIDogXCJNZW51QnRuXCJ9IG9uOmNsaWNrPXtvbkNsaWNrfSBvbjprZXlwcmVzcyBkYXRhLWFjdGl2ZT17YWN0aXZlfSA+XG5cdDxkaXYgY2xhc3M9XCJNZW51QnRuSWNvblwiPlxuXHRcdFgyXG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPVwiTWVudUJ0blRleHRcIj5cblx0XHQ8IS0taDQ+e3RpdGxlfTwvaDQtLT5cblx0XHQ8cD57dGl0bGV9PC9wPlxuXHQ8L2Rpdj5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBNZW51QnRuIGZyb20gXCIuL01lbnVCdG4uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgb24gfSBmcm9tIFwiZXZlbnRzXCI7XG5cblxuXHRleHBvcnQgbGV0IHRpdGxlOnN0cmluZ3xudWxsID0gbnVsbDtcblx0ZXhwb3J0IGxldCByZWd1bGFyT3B0aW9ucyA6IHN0cmluZ1tdID0gW11cblx0ZXhwb3J0IGxldCBzcGVjaWFsT3B0aW9ucyA6IHN0cmluZ1tdID0gW107XG5cdGV4cG9ydCBsZXQgc3RhcnRDaG9zZW4gOiBzdHJpbmcgPSBcIlwiO1xuXHQkOiBvcHRpb25zID0gcmVndWxhck9wdGlvbnMuY29uY2F0KC4uLnNwZWNpYWxPcHRpb25zKTtcblx0bGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cdFxuXHRcblx0bGV0IGJ0bkFyciA6IE1lbnVCdG5bXSA9IFtdO1xuXHRsZXQgY2hvc2VuIDogTWVudUJ0biB8IG51bGwgPSBudWxsO1xuXHRmdW5jdGlvbiBvbkJ0bkNsaWNrKCBpICl7XG5cdFx0Y29uc3QgYnRuID0gYnRuQXJyW2ldO1xuXHRcdGlmKGJ0biA9PSBjaG9zZW4pe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKGNob3Nlbilcblx0XHRcdGNob3Nlbi5zZXRBY3RpdmUoZmFsc2UpXG5cblx0XHRidG4uc2V0QWN0aXZlKHRydWUpO1xuXHRcdGNob3NlbiA9IGJ0bjtcblx0XHRkaXNwYXRjaCgnY2hhbmdlUGFnZScsIG9wdGlvbnNbaV0pO1xuXHR9XG4gXG5cdG9uTW91bnQoKCk9Pntcblx0XHRsZXQgaSA9IG9wdGlvbnMuZmluZEluZGV4KCBwID0+IHAgPT0gc3RhcnRDaG9zZW4gKTtcblx0XHRpZihpICE9IC0xKXtcblx0XHRcdG9uQnRuQ2xpY2soaSk7XG5cdFx0fVxuXHR9KVxuPC9zY3JpcHQ+XG48ZGl2IGNsYXNzPVwiTWVudVwiID5cblx0eyNpZiB0aXRsZX1cblx0XHQ8ZGl2IGNsYXNzPVwiTWVudVRpdGxlXCIgPlxuXHRcdFx0PHA+e3RpdGxlfTwvcD5cblx0XHQ8L2Rpdj5cblx0ey9pZn1cblx0PHNlY3Rpb24gY2xhc3M9XCJNZW51QnRuQ29udGFpbmVyXCIgPlxuXHRcdHsjZWFjaCBvcHRpb25zIGFzIG9wdCxpIH1cblx0XHRcdDxNZW51QnRuIFxuXHRcdFx0XHRzcGVjaWFsPXtzcGVjaWFsT3B0aW9ucy5pbmNsdWRlcyhvcHQpfVxuXHRcdFx0XHR0aXRsZT17b3B0fVxuXHRcdFx0XHRiaW5kOnRoaXM9e2J0bkFycltpXX1cblx0XHRcdFx0b246Y2xpY2s9eygpID0+IG9uQnRuQ2xpY2soaSl9XG5cdFx0XHQvPlx0XG5cdFx0ey9lYWNofVxuXHQ8L3NlY3Rpb24+XG48L2Rpdj4iLCJpbXBvcnQgeyBjdWJpY091dCAsIFx0ZWxhc3RpY0luT3V0fSBmcm9tICdzdmVsdGUvZWFzaW5nJztcbiBcblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VTbGlkZShub2RlLCBwYXJhbXMpIHtcblxuXHRjb25zdCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0Y29uc3QgaGVpZ2h0XHQ9IHJlY3QuaGVpZ2h0O1xuXHRjb25zdCB3aWR0aFx0XHQ9IHJlY3Qud2lkdGg7XG5cdFxuXHRjb25zdCBwYXJlbnQgPSBwYXJhbXMucGFyZW50O1xuXHRpZihwYXJlbnQpe1xuXHRcdGNvbnN0IG9yaWdUcmFuc2l0aW9uID0gcGFyZW50LnN0eWxlLnRyYW5zaXRpb247XG5cdFx0Y29uc3Qgb3JpZ0hlaWdodCA9IHBhcmVudC5zdHlsZS5oZWlnaHQ7XG5cdFx0cGFyZW50LnN0eWxlLnRyYW5zaXRpb24gKz0gJyBlYXNlICcgKyAocGFyYW1zLmR1cmF0aW9uIHx8IDQwMCApLzEwMDAgKyAncyBoZWlnaHQnO1xuXHRcdHBhcmVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdHNldFRpbWVvdXQoXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdHBhcmVudC5zdHlsZS50cmFuc2l0aW9uID0gb3JpZ1RyYW5zaXRpb247XG5cdFx0XHRcdHBhcmVudC5zdHlsZS5oZWlnaHQgPSBvcmlnSGVpZ2h0O1xuXHRcdFx0fSxcblx0XHRcdHBhcmFtcy5kdXJhdGlvbiB8fCA0MDAgXG5cdFx0KVxuXHR9XG5cdFxuXG5cdHJldHVybiB7XG5cdFx0ZGVsYXk6IHBhcmFtcy5kZWxheSB8fCAwLFxuXHRcdGR1cmF0aW9uOiBwYXJhbXMuZHVyYXRpb24gfHwgNDAwLFxuXHRcdGVhc2luZzogcGFyYW1zLmVhc2luZyB8fCBjdWJpY091dCxcblx0XHRjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHRoZWlnaHQ6JHtoZWlnaHR9cHg7XG5cdFx0XHR3aWR0aDoke3dpZHRofXB4O1xuXHRcdFx0cG9zaXRpb246YWJzb2x1dGU7XG5cdFx0XHR0cmFuc2Zvcm0tb3JpZ2luOiB0b3A7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHt1KndpZHRofXB4KTtcblx0XHRcdGBcblx0fTtcbn0iLCJcbmltcG9ydCB7IGdldCwgd3JpdGFibGUsIHR5cGUgV3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnOyBcbmltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbmltcG9ydCB7IEdyb2JKRGVyaXZlZE5vZGUsIEdyb2JKRml4ZWROb2RlLCBHcm9iSk5vZGVUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vZ3JhcGhEZXNpZ25lcic7XG5pbXBvcnQgU3RhdGljTWVzc2FnZUhhbmRsZXIgZnJvbSAnLi4vLi4vLi4vQ29tcG9uZW50cy9NZXNzYWdlcy9TdGF0aWNNZXNzYWdlSGFuZGxlci5zdmVsdGUnXG5pbXBvcnQgeyBHcm9iRGVyaXZlZE5vZGUsIEdyb2JGaXhlZE5vZGUsIEdyb2JOb2RlVHlwZSB9IGZyb20gJ3R0cnBnLXN5c3RlbS1ncmFwaCc7XG5pbXBvcnQgeyBBR3JvYk5vZGUgfSBmcm9tICd0dHJwZy1zeXN0ZW0tZ3JhcGgvZGlzdC9Ob2Rlcy9BR3JvYk5vZHRlJztcbmltcG9ydCB7IFVJTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSU5vZGUnO1xuaW1wb3J0IHsgVUlTeXN0ZW0gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9ncmFwaERlc2lnbmVyL1VJQ29tcG9zaXRpb24vVUlTeXN0ZW0nO1xuIFxuXG5jbGFzcyBBSXRlbUNvbnRyb2xsZXI8VCBleHRlbmRzIEFHcm9iTm9kZTxUPj4ge1xuXG5cdHB1YmxpYyB1aU5vZGVcdFx0XHQ6IFVJTm9kZTtcblx0cHVibGljIG5vZGVcdFx0XHRcdDogVCA7XG5cdHB1YmxpYyBzeXN0ZW1cdFx0XHQ6IFVJU3lzdGVtIDtcblx0cHVibGljIG1lc3NhZ2VIYW5kbGVyXHQ6IFN0YXRpY01lc3NhZ2VIYW5kbGVyIHwgbnVsbCA9IG51bGw7XG5cblx0cHVibGljIGlzVmFsaWRcdFx0OiBXcml0YWJsZTxib29sZWFuPlx0PSB3cml0YWJsZSh0cnVlKTsgXG5cblx0Ly8gbmFtZSBhbmQgc3RhbmRhcmQgdmFsdWUsIGlzdmFsZGkgYXJlIGZvciBhbGwgbm9kZXMuXG5cdHB1YmxpYyBuYW1lIFx0XHQ6IFdyaXRhYmxlPHN0cmluZz5cdD0gd3JpdGFibGUoJycpOyBcblx0cHVibGljIHN0YW5kYXJkVmFsdWU6IFdyaXRhYmxlPG51bWJlcj5cdD0gd3JpdGFibGUoMSk7ICBcblx0XG5cdHB1YmxpYyBzZXRDb250cm9sbGVyRGVwcyggdWlOb2RlIDogVUlOb2RlLCBzeXN0ZW0gOiBVSVN5c3RlbSwgb3V0IDogKG1zZykgPT4gYW55ICl7XG5cdFx0dGhpcy51aU5vZGUgPSB1aU5vZGU7XG5cdFx0dGhpcy5ub2RlXHQ9IHVpTm9kZS5saW5rIGFzIGFueTtcblx0XHR0aGlzLnN5c3RlbSA9IHN5c3RlbTtcblxuXHRcdC8vIGJhc2UgZm9yIGZpeGVkIGl0ZW1zXG5cdFx0dGhpcy5pc1ZhbGlkIFx0XHQuc2V0KHRydWUpIFxuXHRcdHRoaXMubmFtZSBcdFx0XHQuc2V0KHRoaXMudWlOb2RlPy5uYW1lXHQ/PyAnJykgXG5cdFx0dGhpcy5zdGFuZGFyZFZhbHVlIFx0LnNldCgwKSBcblx0fSBcblxuXHQvLyAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG5cdC8vIC0tLSBwcm90ZWN0ZWQgdmFsaWRhdGlvbiBmdW5jdGlvbnMtIC0tLSAtLS0gcHJvdGVjdGVkIHZhbGlkYXRpb24gZnVuY3Rpb25zLSAtLS1cblx0Ly8gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLVxuXHRwcm90ZWN0ZWQgdmFsaWRhdGVOYW1lKCBuYW1lICwgb3V0IDogKCBtc2cgKSA9PiBhbnkpe1xuXHRcdFxuXHRcdGxldCBpc1ZhbGlkID0gdHJ1ZTsgXG5cdFx0aWYgKG5hbWUgPT0gJycpe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0b3V0KCdUaGUgbmFtZSBjYW5ub3QgYmUgZW1wdHknKVxuXHRcdH1cblx0XHRlbHNlIGlmIChuYW1lLmluY2x1ZGVzKCcuJykpe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0b3V0KCdUaGUgbmFtZSBjYW5ub3QgY29udGFpbiBcIi5cIicpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0aGlzLnVpTm9kZS5wYXJlbnQuaGFzTm9kZSggbmFtZSApICYmIG5hbWUgIT0gdGhpcy51aU5vZGUubmFtZSApe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0b3V0KCdUaGUgbmFtZSBpcyBhbHJlYWR5IGluIHVzZSwgaW4gdGhlIHNhbWUgY29sbGVjdGlvbicpXG5cdFx0fVxuXHRcdHJldHVybiBpc1ZhbGlkO1xuXHR9XG5cblx0Ly8gVmFsaWRhdGlvbiBcblx0cHJvdGVjdGVkIF9vdXRMaXN0IDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cdHByb3RlY3RlZCBfY2hlY2tJc1ZhbGlkKCAgb3V0cHV0ID0gdHJ1ZSApeyBcblx0XHRcblx0XHRpZighdGhpcy51aU5vZGUgfHwgIXRoaXMuc3lzdGVtKXsgXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENyZWF0ZSB2YWx1ZXMgdG8gc3RhcnQgd2l0aC5cblx0XHRsZXQgaXNWYWxpZCA9IHRydWU7IFxuXG5cdFx0Ly8gY3JlYXRlIGFuIG91dCBtZXRob2QuIGJhc2VkIGluIHdldGhlciBvciBub3QgdG8gaGF2ZSBhbiBvdXRwdXQuIFxuXHRcdGxldCBfb3V0ID0gb3V0cHV0ID8gKG1zZykgPT4ge3RoaXMuX291dExpc3QuYWRkKG1zZyl9IDogKG1zZykgPT4ge307XG5cdFx0XG5cdFx0Ly8gdmFsaWRhdGUgbGllbiBmb3IgZWFjaCB2YWxpZGF0ZU1ldGhvZC4gXG5cdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgdGhpcy52YWxpZGF0ZU5hbWUoIGdldCh0aGlzLm5hbWUpID8/ICcnICwgX291dCApO1xuXHRcdHJldHVybiBpc1ZhbGlkO1xuXG5cdH1cblx0cHVibGljIGNoZWNrSXNWYWxpZCggb3V0cHV0ID0gdHJ1ZSApeyAgXG5cdFx0aWYgKG91dHB1dCl7XG5cdFx0XHR0aGlzLm1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVBbGxNZXNzYWdlcygpO1xuXHRcdH1cblx0XHRsZXQgdmFsaWQgPSB0aGlzLl9jaGVja0lzVmFsaWQoIG91dHB1dCApOyBcblx0XHR0aGlzLmlzVmFsaWQuc2V0KCB2YWxpZCApOyBcblx0XHRyZXR1cm4gdmFsaWQ7XG5cdH0gIFxuXG59XG5cbmV4cG9ydCBjbGFzcyBGaXhlZEl0ZW1Db250cm9sbGVyXHRleHRlbmRzIEFJdGVtQ29udHJvbGxlcjxHcm9iRml4ZWROb2RlPntcblxuXG5cdC8vIFNhdmVcblx0cHVibGljIHNhdmVOb2RlQ2hhbmdlcyggKXtcblx0XHRsZXQgc3VjY2VzcyA9IHRoaXMuY2hlY2tJc1ZhbGlkKHRydWUpO1xuXHRcdGlmICghc3VjY2Vzcyl7XG5cdFx0XHRyZXR1cm4gZmFsc2UgO1xuXHRcdH1cblx0XHRcblx0XHQvLyB1cGRhdGUgYWxsIGJ1dCBuYW1lO1xuXHRcdHRoaXMubm9kZS5zZXRWYWx1ZVx0KCBnZXQodGhpcy5zdGFuZGFyZFZhbHVlKSApO1xuXG5cdFx0Ly8gbmFtZSB0cmlnZ2VycyB1cGRhdGUgXG5cdFx0dGhpcy5ub2RlLnNldE5hbWVcdCggZ2V0KHRoaXMubmFtZSkgKTtcblxuXHRcdHJldHVybiB0cnVlO1x0XG5cdH0gXG5cblxufSBcbmV4cG9ydCB0eXBlIG9yaWdpblJvd0RhdGEgPSB7a2V5OiBzdHJpbmcsIHNlZ21lbnRzOihzdHJpbmd8bnVsbClbXSAsIGFjdGl2ZSA6Ym9vbGVhbiAsIHRlc3RWYWx1ZSA6bnVtYmVyLCBpbkNhbGM6Ym9vbGVhbiwgdGFyZ2V0OiBHcm9iSk5vZGVUeXBlIHwgbnVsbCAsIGlzU2VsZWN0QWxsVGFyZ2V0OiBib29sZWFuIH07XG5leHBvcnQgY2xhc3MgRGVyaXZlZEl0ZW1Db250cm9sbGVyXHRleHRlbmRzIEFJdGVtQ29udHJvbGxlcjxHcm9iRGVyaXZlZE5vZGU+IHtcblx0XG5cdC8vIGNhbGMgdmFyaWFibGVzIGFyZSBmb3IgZGVyaXZlZCBub2RlcyBcblx0cHVibGljIGNhbGNcdFx0XHQ6IFdyaXRhYmxlPHN0cmluZz5cdD0gd3JpdGFibGUoJycpOyBcblx0cHVibGljIHJlc3VsdFZhbHVlXHQ6IFdyaXRhYmxlPG51bWJlcj5cdD0gd3JpdGFibGUoMCk7IFxuXHRwdWJsaWMgcmVzdWx0U3VjY2VzczogV3JpdGFibGU8Ym9vbGVhbj5cdD0gd3JpdGFibGUodHJ1ZSk7XG5cdHB1YmxpYyBtYXBwZWRPcmlnaW5zOiBXcml0YWJsZTxvcmlnaW5Sb3dEYXRhW10+ID0gd3JpdGFibGUoW10pOyBcbiBcblx0cHVibGljIHNldENvbnRyb2xsZXJEZXBzKCBub2RlIDogVUlOb2RlLCBzeXN0ZW0gOiBVSVN5c3RlbSAsIG91dCA6IChtc2cpID0+IGFueSApe1xuXHRcdFxuXHRcdHN1cGVyLnNldENvbnRyb2xsZXJEZXBzKG5vZGUsc3lzdGVtLG91dCk7XG5cblx0XHQvLyBiYXNlIGZvciBkZXJpdmVkIGl0ZW1zIFxuXHRcdHRoaXMuY2FsY1x0XHRcdC5zZXQodGhpcy51aU5vZGUubGluaz8uY2FsYyA/PyAnJyk7XG5cdFx0dGhpcy5yZXN1bHRWYWx1ZVx0LnNldCgwKTtcdFx0XG5cdFx0dGhpcy5yZXN1bHRTdWNjZXNzXHQuc2V0KHRydWUpO1x0XG5cdFx0dGhpcy51cGRhdGVNYXBwZWRPcmlnaW5zKCk7XHRcblx0fSAgXG5cdHB1YmxpYyB1cGRhdGVNYXBwZWRPcmlnaW5zKCl7XG5cdFx0bGV0IG0gPSB0aGlzLnVpTm9kZT8ubGluaz8ub3JpZ2lucz8ubWFwKCBcblx0XHRcdHAgPT4ge1xuXHRcdFx0XHRyZXR1cm4geyBcblx0XHRcdFx0XHRrZXk6cC5zeW1ib2wsXG5cdFx0XHRcdFx0c2VnbWVudHM6cC5vcmlnaW5LZXkuc3BsaXQoJy4nKSxcblx0XHRcdFx0XHRhY3RpdmU6IGdldCh0aGlzLmNhbGMpLmluY2x1ZGVzKHAuc3ltYm9sKSxcblx0XHRcdFx0XHR0ZXN0VmFsdWU6IHAuc3RhbmRhcmRWYWx1ZSAsXG5cdFx0XHRcdFx0aW5DYWxjOiBnZXQodGhpcy5jYWxjKS5pbmNsdWRlcyhwLnN5bWJvbCkgLFxuXHRcdFx0XHRcdHRhcmdldDogcC5vcmlnaW4gLFxuXHRcdFx0XHRcdGlzU2VsZWN0QWxsVGFyZ2V0IDogdHJ1ZSBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCkgPz8gW107XHRcblx0XHR0aGlzLm1hcHBlZE9yaWdpbnNcdC5zZXQobSk7XHRcblx0fVxuXG5cdC8vIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS1cblx0Ly8gLS0tIHByb3RlY3RlZCB2YWxpZGF0aW9uIGZ1bmN0aW9ucy0gLS0tIC0tLSBwcm90ZWN0ZWQgdmFsaWRhdGlvbiBmdW5jdGlvbnMtIC0tLVxuXHQvLyAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tIC0tLSAtLS0gLS0tXG5cdHByb3RlY3RlZCB2YWxpZGF0ZU9yaWdpbnMoICBtYXBwZWRPcmlnaW5zOm9yaWdpblJvd0RhdGFbXSwgY2FsYzpzdHJpbmcgLCBvdXQgOiAobXNnKSA9PiBhbnkgKXtcblx0XHRcblx0XHQvLyB2YWxpZGF0ZSB0aGF0IGFsbCBpbkNhbGMgYXJlIGZpbmlzaGVkXG5cdFx0bGV0IGlzVmFsaWQgPSB0cnVlIDsgIFxuXHRcdGxldCBzdHJPdXQgPSBcIlwiO1xuXHRcdG1hcHBlZE9yaWdpbnMuZm9yRWFjaCggb2JqID0+IHtcblx0XHRcdGlmIChvYmouaW5DYWxjICYmICEob2JqLnRhcmdldCkpe1xuXHRcdFx0XHRvdXQoYENhbm5vdCBzYXZlIHVudGlsIGFsbCBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgY2FsYyBpcyBkZWZpbmVkIFxcbiAke29iai5rZXl9IEhhZCBubyB0YXJnZXQgXFxuYCk7XG5cdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdGlmICghaXNWYWxpZCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFNldCBDYWxjIGFuZCBkZXBlbmRlbmNpZXMgXG5cdFx0bGV0IE5NYXAgPSBtYXBwZWRPcmlnaW5zLmZpbHRlciggcCA9PiBjYWxjLmluY2x1ZGVzKHAua2V5KSApOyBcblx0XHROTWFwLmZvckVhY2goIG8gPT4ge1x0XG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGlmIGl0IGhhcyBzZWdtZW50c1xuXHRcdFx0aWYgKCFvLnNlZ21lbnRzKXsgXG5cdFx0XHRcdG91dChgQ29udGVudHMgb2YgJHtvLmtleX0ncyBzZWdtZW50cyB3YXMgTnVsbCEnYCk7XG5cdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBjaGVjayB0aGF0IGl0IGNhbiBjcmVhdGUgdGhlIHByb3BwZXIgdGFyZ2V0LiBBS0EgdGFyZ2V0IGV4aXN0cyBpbiB0aGUgc3lzdGVtLiBub3QganVzdCBlbXB0eSBvYmotXG5cdFx0XHRsZXQgZGVwID0gdGhpcy5zeXN0ZW0uZ2V0Tm9kZShvLnNlZ21lbnRzWzBdIGFzIGFueSxvLnNlZ21lbnRzWzFdIGFzIGFueSAsby5zZWdtZW50c1syXSBhcyBhbnkpIDtcblx0XHRcdGlmICghZGVwICl7XG5cdFx0XHRcdG91dChgVGFyZ2V0IG9mICR7by5rZXl9IGxvY2F0aW9uICR7by5zZWdtZW50c1swXSArJy4nKyBvLnNlZ21lbnRzWzFdICsnLicrIG8uc2VnbWVudHNbMl0gfSB3YXMgaW52YWxpZCEnYCk7XG5cdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pOyBcblxuXHRcdHJldHVybiBpc1ZhbGlkO1xuXHR9XG5cdHByb3RlY3RlZCB2YWxpZGF0ZUNhbGN1bGF0aW9uKCBjYWxjOnN0cmluZyAsIG1hcHBlZE9yaWdpbnM6b3JpZ2luUm93RGF0YVtdICwgb3V0IDogKG1zZykgPT4gYW55ICl7XG5cdFx0XG5cdFx0Ly8gZmlyc3QgdGVzdCB0aGUgY2FsY3VsYXRpb24uXG5cdFx0bGV0IG8gPSB7fTtcblx0XHRsZXQgbWFwcGVkS2V5cyA6IHN0cmluZ1tdID0gW107XG5cdFx0bWFwcGVkT3JpZ2lucy5mb3JFYWNoKCBwID0+IHsgb1twLmtleV09IHAudGVzdFZhbHVlIDsgbWFwcGVkS2V5cy5wdXNoKHAua2V5KSB9ICk7XG5cdFx0bGV0IGNhbGNyZXMgPSBHcm9iSkRlcml2ZWROb2RlLnRlc3RDYWxjdWxhdGUoIGNhbGMgLCBvICk7XG5cdFx0XG5cdFx0bGV0IHN1Y2Nlcz0gY2FsY3Jlcy5zdWNjZXNzO1xuXHRcdGxldCB2YWx1ZSA9IGNhbGNyZXMudmFsdWU7XG5cblx0XHQvLyBpZiB0aGVyZSBpcyBhbiBjYWxjIGVycm9yIHNob3duIHJlbW92ZSBpdC4gLiBBbHNvIG1lc3NhZ2VoYW5kbGVyIGhhcyB0byBiZSBpbml0aWFsaXplZFxuXHRcdGlmICggIXN1Y2NlcyApeyBcblx0XHRcdG91dChgQ2FsY3VsYXRpb24gaXMgaW52YWxpZCwgbWVhbmluZyBpdCBjb3VsZCBub3QgcGFyc2VgKTtcblx0XHR9IFxuXG5cdFx0dGhpcy5yZXN1bHRWYWx1ZSBcdC5zZXQodmFsdWUpO1xuXHRcdHRoaXMucmVzdWx0U3VjY2VzcyBcdC5zZXQoc3VjY2VzKTtcblx0XHRyZXR1cm4gc3VjY2VzIGFzIGJvb2xlYW47XG5cdH1cblx0cHJvdGVjdGVkIHZhbGlkYXRlQ2FsY3VsYXRpb25PcmlnaW5zKCBjYWxjOnN0cmluZyAsIG1hcHBlZE9yaWdpbnM6b3JpZ2luUm93RGF0YVtdICwgb3V0IDogKG1zZykgPT4gYW55ICl7XG5cdFxuXHRcdGxldCBzeW1ib2xzID0gR3JvYkpEZXJpdmVkTm9kZS5zdGF0aWNQYXJzZUNhbGN1bGF0aW9uVG9PcmlnaW5zKGNhbGMpO1xuXHRcdG1hcHBlZE9yaWdpbnMuZm9yRWFjaCggbyAgPT4ge1xuXHRcdFx0c3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKCBwID0+IHAgIT0gby5rZXkgKTtcblx0XHRcdG91dCggby5rZXkgKyAnbWlzc2luZycgKTtcblx0XHR9KTtcblxuXHRcdGxldCBpc1ZhbGlkID0gdHJ1ZTtcblx0XHRzeW1ib2xzLmZvckVhY2goIHMgID0+IHtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdG91dChgc3ltYm9sICR7c30gd2FzIG1pc3NpbmcgZnJvbSBvcmlnaW5zIGApO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGlzVmFsaWQ7XG5cdH0gXG5cblx0Ly8gVmFsaWRhdGlvbiBcblx0cHJvdGVjdGVkIF9jaGVja0lzVmFsaWQoICBvdXRwdXQgPSB0cnVlICApe1xuXHRcdCBcblx0XHQvLyBjcmVhdGUgYW4gb3V0IG1ldGhvZC4gYmFzZWQgaW4gd2V0aGVyIG9yIG5vdCB0byBoYXZlIGFuIG91dHB1dC4gXG5cdFx0bGV0IF9vdXQgPSBvdXRwdXQgPyAobXNnKSA9PiB7dGhpcy5fb3V0TGlzdC5hZGQobXNnKX0gOiAobXNnKSA9PiB7fTtcblx0XHRsZXQgaXNWYWxpZCA9IHN1cGVyLl9jaGVja0lzVmFsaWQoIG91dHB1dCApXG5cblx0XHQvLyBDaGVjayBuYW1lIGlzIHZhbGlkIFxuXHRcdGlzVmFsaWQgPSBpc1ZhbGlkICYmIHRoaXMudmFsaWRhdGVPcmlnaW5zXHRcdFx0KCBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKSBcdCwgZ2V0KHRoaXMuY2FsYykgXHRcdFx0LCBfb3V0ICk7XG5cdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgdGhpcy52YWxpZGF0ZUNhbGN1bGF0aW9uT3JpZ2lucyggZ2V0KHRoaXMuY2FsYyApXHRcdFx0LCBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKVx0LCBfb3V0ICk7XG5cdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgdGhpcy52YWxpZGF0ZUNhbGN1bGF0aW9uXHRcdCggZ2V0KHRoaXMuY2FsYyApXHRcdFx0LCBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKVx0LCBfb3V0ICk7XG5cblx0XHRyZXR1cm4gaXNWYWxpZDtcblxuXHR9XG5cdHB1YmxpYyBjaGVja0lzVmFsaWQoIG91dHB1dCA9IHRydWUgKXsgIFxuXHRcdGlmIChvdXRwdXQpe1xuXHRcdFx0dGhpcy5tZXNzYWdlSGFuZGxlcj8ucmVtb3ZlQWxsTWVzc2FnZXMoKTtcblx0XHR9XG5cdFx0bGV0IHZhbGlkID0gdGhpcy5fY2hlY2tJc1ZhbGlkKCBvdXRwdXQgKTsgXG5cdFx0dGhpcy5pc1ZhbGlkLnNldCggdmFsaWQgKTsgXG5cdFx0cmV0dXJuIHZhbGlkO1xuXHR9ICBcblx0XG5cdC8vIFNhdmVcblx0cHVibGljIHNhdmVOb2RlQ2hhbmdlcyggKXtcblx0XHRsZXQgc3VjY2VzcyA9IHRoaXMuY2hlY2tJc1ZhbGlkKHRydWUpO1xuXHRcdGlmICghc3VjY2Vzcyl7XG5cdFx0XHRyZXR1cm4gZmFsc2UgO1xuXHRcdH1cblx0XHRcblx0XHQvLyB1cGRhdGUgYWxsIGJ1dCBuYW1lO1xuXHRcdHRoaXMubm9kZS5zZXRWYWx1ZVx0KCBnZXQodGhpcy5zdGFuZGFyZFZhbHVlKSApO1xuXHRcdHRoaXMubm9kZS5zZXRDYWxjXHQoIGdldCh0aGlzLmNhbGMpICk7XG5cdFx0bGV0IE5NYXAgPSBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKS5maWx0ZXIoIHAgPT4gcC5pbkNhbGMgKTsgXG5cdFx0XG5cdFx0Tk1hcC5mb3JFYWNoKCBvID0+IHtcblx0XHRcdFxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0bGV0IGRlcCA9IHRoaXMuc3lzdGVtLnN5cy5nZXROb2RlKG8uc2VnbWVudHNbMF0gYXMgYW55LG8uc2VnbWVudHNbMV0gYXMgYW55ICxvLnNlZ21lbnRzWzJdIGFzIGFueSkgO1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dGhpcy5ub2RlLnNldE9yaWdpbiggby5rZXkgLCBkZXAgLCBvLnRlc3RWYWx1ZSA/PyAwICk7XG5cdFx0fSk7ICBcblxuXHRcdC8vIG5hbWUgdHJpZ2dlcnMgdXBkYXRlIFxuXHRcdHRoaXMubm9kZS5zZXROYW1lXHQoIGdldCh0aGlzLm5hbWUpICk7XG5cdFx0dGhpcy51aU5vZGUubmFtZSA9IGdldCh0aGlzLm5hbWUpO1xuXG5cdFx0cmV0dXJuIHRydWU7XHRcblx0fSBcblx0cHVibGljIG9uS2V5RXhjaGFuZ2UoIGUgKXsgXG5cdFx0dGhpcy5tYXBwZWRPcmlnaW5zLnVwZGF0ZSggbWFwcGVkT3JpZ2lucyA9PiB7XG5cdFx0XHRjb25zdCBzMCA9IGUuZGV0YWlsLm9sZDtcblx0XHRcdGNvbnN0IHMxID0gZS5kZXRhaWwubmV3OyBcblx0XHRcdGxldCB0MCA6IG9yaWdpblJvd0RhdGEgfCB1bmRlZmluZWQgPSBtYXBwZWRPcmlnaW5zLmZpbmQoIHAgPT4gcC5rZXkgPT0gczAgKTtcblx0XHRcdGlmICghdDApXG5cdFx0XHRcdHJldHVybiBtYXBwZWRPcmlnaW5zO1xuXG5cdFx0XHRsZXQgdDEgOiBvcmlnaW5Sb3dEYXRhIHwgdW5kZWZpbmVkID0gbWFwcGVkT3JpZ2lucy5maW5kKCBwID0+IHAua2V5ID09IHMxICk7XG5cdFx0XHRpZiAoIXQxKVxuXHRcdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblxuXHRcdFx0Ly8gd2UgZXZhbCBpZiBzMCBpcyBpbiB0aGUgY2FsYy4gdGhlbiB3ZSBuZWVkIHRvIGV4Y2hhbmdlIHRoZW4gZGVsZXRlLiBcblx0XHRcdHQwLmtleSA9IHMxO1xuXHRcdFx0dDAuaW5DYWxjID0gZ2V0KHRoaXMuY2FsYykuaW5jbHVkZXMoczEpO1xuXHRcdFx0dDEua2V5ID0gczA7XG5cdFx0XHR0MS5pbkNhbGMgPSBnZXQodGhpcy5jYWxjKS5pbmNsdWRlcyhzMCk7XG5cdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblx0XHR9KVxuXHRcdHJldHVybiBcblx0fVxuXHRwdWJsaWMgb25LZXlEZWxldGUoIGUgKXsgXG5cdFx0dGhpcy5tYXBwZWRPcmlnaW5zLnVwZGF0ZSggbWFwcGVkT3JpZ2lucyA9PiB7XG5cdFx0XHRjb25zdCBrZXkgPSBlLmRldGFpbDtcblx0XHRcdGxldCBvbGQgOiBvcmlnaW5Sb3dEYXRhIHwgdW5kZWZpbmVkID0gbWFwcGVkT3JpZ2lucy5maW5kKCBwID0+IHAua2V5ID09IGtleSApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIW9sZClcblx0XHRcdFx0cmV0dXJuIG1hcHBlZE9yaWdpbnM7XG5cblx0XHRcdGlmICghb2xkLmFjdGl2ZSB8fCAhb2xkLmluQ2FsYyl7XG5cdFx0XHRcdG1hcHBlZE9yaWdpbnMgPSBtYXBwZWRPcmlnaW5zLmZpbHRlciggcCA9PiBwLmtleSAhPSBvbGQua2V5IClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZC5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0b2xkLnNlZ21lbnRzID0gbmV3IEFycmF5KDMpLmZpbGwobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblx0XHR9KVxuXHR9XG5cdHB1YmxpYyByZWNhbGN1bGF0ZUNhbGNBbmRPcmlnaW5zKCl7IFxuXHRcdC8vLyBIYW5kbGUgQ2FsY3VsYXRpb25cblx0XHRsZXQgbyA9IHt9OyBcblx0XHRnZXQodGhpcy5tYXBwZWRPcmlnaW5zKS5mb3JFYWNoKCBwID0+IHsgb1twLmtleV09IHAudGVzdFZhbHVlOyB9ICk7XG5cdFx0bGV0IGNhbGMgPSBnZXQodGhpcy5jYWxjKSA7IFxuXHRcdGxldCByZXMgPSBHcm9iSkRlcml2ZWROb2RlLnRlc3RDYWxjdWxhdGUoIGNhbGMgLCBvICk7XG5cblx0XHQvLyBzYXZlIGFuZCBwcm9jY2VzcyB2YWx1ZXMgXG5cdFx0dGhpcy5yZXN1bHRWYWx1ZVx0LnNldChyZXMudmFsdWUpO1xuXHRcdHRoaXMucmVzdWx0U3VjY2Vzc1x0LnNldChyZXMuc3VjY2Vzcyk7XG5cblx0XHQvLy8gSGFuZGxlIEFkZCBPcmlnaW5zLiBcblx0XHQvLyBjYWxjdWxhdGUgdGhlIHN5bWJvbHNcblx0XHRsZXQgc3ltYm9scyA9IEdyb2JKRGVyaXZlZE5vZGUuc3RhdGljUGFyc2VDYWxjdWxhdGlvblRvT3JpZ2lucyggY2FsYyApO1xuXG5cdFx0Ly9yZW1vdmUga2V5cyB0aGF0IGFscmVhZHkgZXhpc3RzIGZyb20gdGhlIGFycmF5LiBhbmQgbGVhdmUgYSBwdXJlIHRvQWRkIGxpc3QuXG5cdFx0dGhpcy5tYXBwZWRPcmlnaW5zLnVwZGF0ZSggbWFwcGVkT3JpZ2lucyA9PntcblxuXHRcdFx0bWFwcGVkT3JpZ2lucy5mb3JFYWNoKCBkID0+IHtcblx0XHRcdFx0bGV0IGluQ2FsYyA9IHN5bWJvbHMuaW5jbHVkZXMoZC5rZXkpO1xuXHRcdFx0XHRpZiAoIGluQ2FsYyApe1xuXHRcdFx0XHRcdHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlciggcCA9PiBwICE9IGQua2V5ICk7XG5cdFx0XHRcdFx0ZC5pbkNhbGMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIGluIGNhc2UgYW4gaXRlbSBpcyBubyBsb25nZXIgaW4gdGhlIGNhbGMsIG1hcmsgaXQgYXMgc3VjaC4gXG5cdFx0XHRcdFx0ZC5pbkNhbGMgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdFxuXG5cdFx0XHQvLyBmb3IgZWFjaCByZW1haW5pbmcsIGFkZCBpdC4gXG5cdFx0XHRzeW1ib2xzLmZvckVhY2goIHMgPT4ge1xuXHRcdFx0XHRtYXBwZWRPcmlnaW5zLnB1c2goe2tleTpzICwgc2VnbWVudHM6bmV3IEFycmF5KDMpLmZpbGwobnVsbCkgLCBhY3RpdmU6ZmFsc2UgLCB0ZXN0VmFsdWU6IDEsIGluQ2FsYzp0cnVlLCB0YXJnZXQgOiBudWxsICwgaXNTZWxlY3RBbGxUYXJnZXQgOiB0cnVlICB9KVxuXHRcdFx0fSkgIFxuXHRcdFx0cmV0dXJuIG1hcHBlZE9yaWdpbnM7XG5cdFx0fSlcblx0fVxufVxuXG4iLCJcbmV4cG9ydCBjbGFzcyBTdHJpbmdGdW5jdGlvbnN7XG5cblx0cHVibGljIHN0YXRpYyBpc1ZhbGlkV2luZG93c0ZpbGVTdHJpbmcoIHN0ciA6IHN0cmluZyApe1xuXG5cdFx0aWYoIXN0cilcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gYSBXaW5kb3dzIGZpbGUgbmFtZVxuXHRcdGNvbnN0IGludmFsaWRDaGFyc1JlZ2V4ID0gL1s8PjpcIi9cXFxcfD8qXFx4MDAtXFx4MUZdL2c7XG5cdFx0XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHN0cmluZyBjb250YWlucyBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzIG9yIHJlc2VydmVkIG5hbWVzXG5cdFx0cmV0dXJuICFpbnZhbGlkQ2hhcnNSZWdleC50ZXN0KHN0cikgJiYgIS9eKGNvbnxwcm58YXV4fG51bHxjb21bMC05XXxscHRbMC05XSkkL2kudGVzdChzdHIpICYmIHN0ci5sZW5ndGggPD0gMjU1O1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBpc1ZhbGlkU3lzdGVtQ29kZU5hbWUoIHN0ciA6IHN0cmluZyApe1xuXG5cdFx0aWYoIXN0cilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRjb25zdCByZWdleCA9IC9bXmEtekEtWjAtOV0vO1xuXHRcdHJldHVybiAhcmVnZXgudGVzdChzdHIpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBDb252ZXJ0VG9WYWxpZFdpbmRvd3NGaWxlU3RyaW5nKCBzdHIgOiBzdHJpbmcgKXtcblx0XHQvL3ZhciBvdXQgPSAoc3RyLnJlcGxhY2UoL1sgJlxcL1xcXFwjLCsoKSR+JS4nXCI6Kj88Pnt9XS9nLCBcIlwiKSk7XG5cdFx0Ly9yZXR1cm4gb3V0OyBcblx0XHQvLyBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggaW52YWxpZCBjaGFyYWN0ZXJzIGluIGEgV2luZG93cyBmaWxlIG5hbWVcblx0XHRjb25zdCBpbnZhbGlkQ2hhcnNSZWdleCA9IC9bPD46XCIvXFxcXHw/KlxceDAwLVxceDFGXS9nO1xuXG5cdFx0Ly8gUmVwbGFjZSBpbnZhbGlkIGNoYXJhY3RlcnMgd2l0aCBhbiB1bmRlcnNjb3JlXG5cdFx0Y29uc3QgdmFsaWRTdHIgPSBzdHIucmVwbGFjZShpbnZhbGlkQ2hhcnNSZWdleCwgXCJfXCIpO1xuXG5cdFx0Ly8gRW5zdXJlIHRoZSBzdHJpbmcgaXMgbm90IGxvbmdlciB0aGFuIDI1NSBjaGFyYWN0ZXJzXG5cdFx0cmV0dXJuIHZhbGlkU3RyLnNsaWNlKDAsIDI1NSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljICB1dWlkdjQoKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnXG5cdFx0LnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRcdGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCBcblx0XHRcdFx0diA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0XHR9KTtcblx0fVxuIFxuXHRwdWJsaWMgc3RhdGljICB1dWlkU2hvcnQoKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eCdcblx0XHQucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0Y29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIFxuXHRcdFx0XHR2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuXHRcdFx0cmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRwcml2YXRlIHN0YXRpYyByZWN1cnNpdmVGaW5kTmV3TmFtZV9MT09QPFQ+KCB0ZXN0TmFtZSA6IHN0cmluZyAsIGNvdW50ZXI6bnVtYmVyLCBhcnJheTpUW10gLCBnZXROYW1lIDogKCBpdGVtOlQgKSA9PiBzdHJpbmcgKSA6IHN0cmluZ3tcblx0XHRsZXQgaSA9IGFycmF5LmZpbmRJbmRleCggcCA9PiBnZXROYW1lKHApID09IHRlc3ROYW1lICsgY291bnRlciApO1xuXHRcdGlmIChpID09IC0xKVxuXHRcdFx0cmV0dXJuIHRlc3ROYW1lICsgY291bnRlciA7XG5cdFx0cmV0dXJuIHRoaXMucmVjdXJzaXZlRmluZE5ld05hbWVfTE9PUCggdGVzdE5hbWUgLCArK2NvdW50ZXIgLCBhcnJheSAsIGdldE5hbWUgKTtcblx0fVxuXG5cblx0cHVibGljIHN0YXRpYyByZWN1cnNpdmVGaW5kTmV3TmFtZTxUPiggdGVzdE5hbWUgOiBzdHJpbmcsIGFycmF5OlRbXSAsIGdldE5hbWUgOiAoIGl0ZW06VCApID0+IHN0cmluZyApIDogc3RyaW5ne1xuXHRcdGxldCBpID0gYXJyYXkuZmluZEluZGV4KCBwID0+IGdldE5hbWUocCkgPT0gdGVzdE5hbWUgKTtcblx0XHRpZiAoaSA9PSAtMSlcblx0XHRcdHJldHVybiB0ZXN0TmFtZSAgO1xuXHRcdHJldHVybiB0aGlzLnJlY3Vyc2l2ZUZpbmROZXdOYW1lX0xPT1AoIHRlc3ROYW1lICwgMCAsIGFycmF5ICwgZ2V0TmFtZSApO1xuXHR9XG5cblxufSIsImltcG9ydCB7IFN0cmluZ0Z1bmN0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9jb3JlL0Jhc2VGdW5jdGlvbnMvc3RyaW5nZnVuY3Rpb25zXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpZXdFbGVtZW50IHtcblx0a2V5OiBzdHJpbmc7XG5cdG5hbWU6IHN0cmluZztcblx0bmFtZUVkaXQ6IHN0cmluZztcblx0dmFsaWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpZXdFbGVtZW50VXBkYXRlYWJsZSBleHRlbmRzIFVwZGF0ZUxpc3RlbmVyIHtcblx0a2V5OiBzdHJpbmc7XG5cdG5hbWU6IHN0cmluZztcblx0bmFtZUVkaXQ6IHN0cmluZztcblx0dmFsaWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVMaXN0ZW5lciB7XG5cblx0cHJvdGVjdGVkIGd1aWQgPSBTdHJpbmdGdW5jdGlvbnMudXVpZHY0KCk7XG5cdHB1YmxpYyBsaXN0ZW5lcnNLZXllZCA9IHt9O1xuXHRwdWJsaWMgbGlzdGVuZXJzRXZlbnRzID0ge307XG5cblx0cHJvdGVjdGVkIGNhbGxVcGRhdGVMaXN0ZW5lcnMoZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzRXZlbnRzW2V2ZW50XSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVyc0V2ZW50c1tldmVudF0pO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qga2V5ID0ga2V5c1tpXTtcblx0XHRcdHRoaXMubGlzdGVuZXJzRXZlbnRzW2V2ZW50XVtrZXldLmNhbGwoKTtcblx0XHR9XG5cdH1cblx0YWRkRXZlbnRMaXN0ZW5lcihrZXksIGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiAoKSA9PiBhbnkpIHtcblxuXHRcdGlmICghdGhpcy5saXN0ZW5lcnNFdmVudHNbZXZlbnRdKSB7XG5cdFx0XHR0aGlzLmxpc3RlbmVyc0V2ZW50c1tldmVudF0gPSB7fTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzS2V5ZWRba2V5XSkge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnNLZXllZFtrZXldID0ge307XG5cdFx0fVxuXG5cdFx0dGhpcy5saXN0ZW5lcnNLZXllZFtrZXldW2V2ZW50XSA9IGxpc3RlbmVyO1xuXHRcdHRoaXMubGlzdGVuZXJzRXZlbnRzW2V2ZW50XVtrZXldID0gbGlzdGVuZXI7XG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKGtleSkge1xuXG5cdFx0Ly8gZmlyc3QgZ2V0IGFsbCBldmVudHMgXG5cdFx0bGV0IGV2ZW50cyA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzS2V5ZWRba2V5XSA/PyB7fSk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGUgPSBldmVudHNbaV07XG5cblx0XHRcdC8vZGVsZXRlIHRoaXMga2V5IGZyb20gYWxsIGV2ZW50cyBcblx0XHRcdGRlbGV0ZSB0aGlzLmxpc3RlbmVyc0V2ZW50c1tlXVtrZXldO1xuXHRcdH1cblxuXHRcdC8vIGRlbHRlIHRoaXMga2V5IFxuXHRcdGRlbGV0ZSB0aGlzLmxpc3RlbmVyc0tleWVkW2tleV07XG5cdH1cblx0cmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKSB7XG5cdFx0dGhpcy5saXN0ZW5lcnNLZXllZCA9IHt9O1xuXHRcdHRoaXMubGlzdGVuZXJzRXZlbnRzID0ge307XG5cdH1cbn1cbmV4cG9ydCBlbnVtIHVwZGF0ZUV2ZW50cyB7XG5cdHZhbGlkQ2hhbmdlID0gJ1ZhbGlkVXBkYXRlZCcsXG5cdHVwZGF0ZSA9ICd1cGRhdGUnLFxuXG59XG4iLCJpbXBvcnQgeyBTdHJpbmdGdW5jdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvY29yZS9CYXNlRnVuY3Rpb25zL3N0cmluZ2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgSVZpZXdFbGVtZW50VXBkYXRlYWJsZSwgdXBkYXRlRXZlbnRzLCBVcGRhdGVMaXN0ZW5lciB9IGZyb20gXCIuL1ZhcmlvdXNcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IFVJR3JvdXAgfSBmcm9tIFwiLi9VSUdyb3VwXCI7XG5pbXBvcnQgeyBHcm9iR3JvdXAsIEdyb2JOb2RlVHlwZSB9IGZyb20gXCJ0dHJwZy1zeXN0ZW0tZ3JhcGhcIjtcbmltcG9ydCB7IFVJU3lzdGVtIH0gZnJvbSBcIi4vVUlTeXN0ZW1cIjtcbmltcG9ydCB7IFVJQ29sbGVjdGlvbiB9IGZyb20gXCIuL1VJQ29sbGVjdGlvblwiO1xuXG5leHBvcnQgY2xhc3MgVUlOb2RlIGV4dGVuZHMgVXBkYXRlTGlzdGVuZXIgaW1wbGVtZW50cyBJVmlld0VsZW1lbnRVcGRhdGVhYmxlIHtcblxuXHRzeXM6IFVJU3lzdGVtO1xuXHRsaW5rOiBHcm9iTm9kZVR5cGU7XG5cdGtleTogc3RyaW5nO1xuXHRuYW1lOiBzdHJpbmc7XG5cdG5hbWVFZGl0OiBzdHJpbmc7XG5cdHZhbGlkOiBib29sZWFuO1xuXHRwYXJlbnQ6IFVJQ29sbGVjdGlvblxuXG4gICAgcHJpdmF0ZSBfaXNDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIFxuXG5cdGNvbnN0cnVjdG9yKHN5c3RlbTogVUlTeXN0ZW0sIG5vZGU6IEdyb2JOb2RlVHlwZSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyggbm9kZS51cGRhdGVMaXN0ZW5lcnMgKTtcblx0XHRpZiAobmFtZXMuaW5jbHVkZXMoIG5vZGUuZ2V0S2V5KCkpICl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3dhcyB3YXMgYWxyZWFkeSBjcmVhdGVkJyk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMubGluayA9IG5vZGU7XG5cdFx0dGhpcy5zeXMgPSBzeXN0ZW07XG5cblx0XHR0aGlzLmtleSA9IG5vZGUuZ2V0S2V5KCk7XG5cdFx0dGhpcy5uYW1lID0gbm9kZS5nZXROYW1lKCk7XG5cdFx0dGhpcy5uYW1lRWRpdCA9IG5vZGUuZ2V0TmFtZSgpO1xuXHRcdHRoaXMudmFsaWQgPSBub2RlLmlzVmFsaWQoKTtcblx0XHRcblx0XHR0aGlzLmxpbmsuYWRkVXBkYXRlTGlzdGVuZXIodGhpcy5rZXksIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9pc0NvbnN0cnVjdGVkID0gdHJ1ZTtcblx0fVxuXG5cdHVwZGF0ZSgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2lzQ29uc3RydWN0ZWQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuXHRcdGxldCB2YWxpZE9yaWcgPSB0aGlzLnZhbGlkO1xuXG5cdFx0dGhpcy5rZXkgPSB0aGlzLmxpbmsuZ2V0S2V5KCk7XG5cdFx0dGhpcy5uYW1lID0gdGhpcy5saW5rLmdldE5hbWUoKTtcblx0XHR0aGlzLm5hbWVFZGl0ID0gdGhpcy5saW5rLmdldE5hbWUoKTtcblx0XHR0aGlzLnZhbGlkID0gdGhpcy5saW5rLmlzVmFsaWQoKTtcblxuXHRcdGlmICh2YWxpZE9yaWcgIT0gdGhpcy52YWxpZCkge1xuXHRcdFx0dGhpcy5jYWxsVXBkYXRlTGlzdGVuZXJzKHVwZGF0ZUV2ZW50cy52YWxpZENoYW5nZSk7XG5cdFx0fVxuXHRcdHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycyh1cGRhdGVFdmVudHMudXBkYXRlKTtcblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0dGhpcy5saW5rLnJlbW92ZVVwZGF0ZUxpc3RlbmVyKHRoaXMua2V5KTtcblx0XHQvL0B0cy1pZ25vcmVcblx0XHR0aGlzLmxpbmsgPSBudWxsO1xuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHRoaXMuc3lzID0gbnVsbDtcblx0XHQvL0B0cy1pZ25vcmVcblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdH1cblxufSIsIlxuXG5pbXBvcnQgeyBTdHJpbmdGdW5jdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvY29yZS9CYXNlRnVuY3Rpb25zL3N0cmluZ2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgSVZpZXdFbGVtZW50VXBkYXRlYWJsZSwgdXBkYXRlRXZlbnRzLCBVcGRhdGVMaXN0ZW5lciB9IGZyb20gXCIuL1ZhcmlvdXNcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFwiLi5cIjsgXG5pbXBvcnQgeyBHcm9iQ29sbGVjdGlvbiwgR3JvYkdyb3VwLCBHcm9iTm9kZVR5cGUgfSBmcm9tIFwidHRycGctc3lzdGVtLWdyYXBoXCI7XG5pbXBvcnQgeyBVSVN5c3RlbSB9IGZyb20gXCIuL1VJU3lzdGVtXCI7XG5pbXBvcnQgeyBVSU5vZGUgfSBmcm9tIFwiLi9VSU5vZGVcIjtcbmltcG9ydCB7IFVJR3JvdXAgfSBmcm9tIFwiLi9VSUdyb3VwXCI7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gXCJjb25zb2xlXCI7XG5cbmV4cG9ydCBjbGFzcyBVSUNvbGxlY3Rpb24gZXh0ZW5kcyBVcGRhdGVMaXN0ZW5lciBpbXBsZW1lbnRzIElWaWV3RWxlbWVudFVwZGF0ZWFibGUge1xuXG5cdHN5czogVUlTeXN0ZW07XG5cdGxpbms6IEdyb2JDb2xsZWN0aW9uPEdyb2JOb2RlVHlwZT47IGRlcml2ZWRDb2xcblx0bm9kZXM6IFVJTm9kZVtdID0gW107XG5cdGtleTogc3RyaW5nO1xuXHRuYW1lOiBzdHJpbmc7XG5cdG5hbWVFZGl0OiBzdHJpbmc7XG5cdHZhbGlkOiBib29sZWFuO1xuXHRwYXJlbnQ6IFVJR3JvdXA7XG5cbiAgICBwcml2YXRlIF9pc0NvbnN0cnVjdGVkID0gZmFsc2U7XG5cblx0Y29uc3RydWN0b3Ioc3lzdGVtOiBVSVN5c3RlbSwgY29sOiBHcm9iQ29sbGVjdGlvbjxHcm9iTm9kZVR5cGU+KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnN5cyA9IHN5c3RlbTtcblx0XHR0aGlzLmxpbmsgPSBjb2w7XG5cblx0XHR0aGlzLmtleSA9IGNvbC5nZXRLZXkoKTtcblx0XHR0aGlzLm5hbWUgPSBjb2wuZ2V0TmFtZSgpO1xuXHRcdHRoaXMubmFtZUVkaXQgPSB0aGlzLm5hbWU7XG5cblx0XHR2YXIgaXNWYWxpZCA9IHRydWU7XG5cdFx0dmFyIG5vZGVOYW1lcyA9IGNvbC5nZXROb2RlTmFtZXMoKTsgXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFxuXHRcdFx0Y29uc3QgbiA9IG5vZGVOYW1lc1tpXTtcblx0XHRcdGNvbnN0IG5vZGUgPSBjb2wuZ2V0Tm9kZShuKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFub2RlKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgdWlub2RlID0gdGhpcy5fYWRkTm9kZShub2RlLCB0aGlzLnN5cyk7XG5cdFx0XHRpc1ZhbGlkID0gaXNWYWxpZCAmJiB1aW5vZGUudmFsaWQ7XG5cdFx0fVxuXHRcdHRoaXMudmFsaWQgPSBpc1ZhbGlkO1xuICAgICAgICB0aGlzLl9pc0NvbnN0cnVjdGVkID0gdHJ1ZTtcblx0fVxuXG5cdGlzVmFsaWRVcGRhdGUoKSB7XG5cdFx0dmFyIG9yaWcgPSB0aGlzLnZhbGlkO1xuXG5cdFx0dmFyIGlzVmFsaWQgPSB0cnVlO1xuXHRcdHRoaXMubm9kZXMuZm9yRWFjaChwID0+IHtcblx0XHRcdGlzVmFsaWQgPSBpc1ZhbGlkICYmIHAudmFsaWQ7XG5cdFx0fSlcblx0XHR0aGlzLnZhbGlkID0gaXNWYWxpZDtcblxuXHRcdGlmIChvcmlnICE9IHRoaXMudmFsaWQpIHtcblx0XHRcdHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycyh1cGRhdGVFdmVudHMudmFsaWRDaGFuZ2UpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZSgpIHsgXG4gICAgICAgIGlmKCF0aGlzLl9pc0NvbnN0cnVjdGVkKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0dGhpcy5rZXkgXHRcdD0gdGhpcy5saW5rLmdldEtleSgpO1xuXHRcdHRoaXMubmFtZSBcdFx0PSB0aGlzLmxpbmsuZ2V0TmFtZSgpO1xuXHRcdHRoaXMubmFtZUVkaXQgXHQ9IHRoaXMubGluay5nZXROYW1lKCk7XG5cdFx0IFxuXHRcdFxuXHRcdGNvbnN0IG5vZGVOYW1lcyA9IHRoaXMubGluay5nZXROb2RlTmFtZXMoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XG5cdFx0XHQvLyBpZiBhbHJlYWR5IGV4aXN0cy4gZG9udCBtYWtlIGEgbmV3XG5cdFx0XHRjb25zdCBuID0gbm9kZU5hbWVzW2ldO1xuXHRcdFx0aWYodGhpcy5faGFzTm9kZShuKSl7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuIFxuXHRcdFx0Y29uc3Qgbm9kID0gdGhpcy5saW5rLmdldE5vZGUobik7ICBcblx0XHRcdGlmICghbm9kKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Y29uc29sZS5sb2cobm9kLmdldEtleSgpKTtcblx0XHRcdDtcblx0XHRcdGNvbnN0IHVpbm9kID0gdGhpcy5fYWRkTm9kZShub2QsdGhpcy5zeXMpO1xuXHRcdH0gXG5cdFx0dGhpcy5pc1ZhbGlkVXBkYXRlKCk7XG5cdFx0dGhpcy5jYWxsVXBkYXRlTGlzdGVuZXJzKHVwZGF0ZUV2ZW50cy51cGRhdGUpO1xuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdC8vIGdldCByaWQgb2Ygbm9kZSBsaXN0ZW5lclxuXHRcdHRoaXMubGluay5yZW1vdmVVcGRhdGVMaXN0ZW5lcih0aGlzLmtleSk7XG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXG5cdFx0Ly8gZGlzcG9zZSBvZiBhbGwgY2hpbGRyZW4uIFxuXHRcdHRoaXMubm9kZXMuZm9yRWFjaChuID0+IG4uZGlzcG9zZSgpKTtcblxuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHRoaXMubGluayA9IG51bGw7XG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0dGhpcy5zeXMgPSBudWxsO1xuXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0fVxuXG5cdHB1YmxpYyBnZXROb2RlKG5hbWU6IHN0cmluZykge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQuZ2V0Tm9kZSh0aGlzLnBhcmVudC5uYW1lLCB0aGlzLm5hbWUsIG5hbWUpXG5cdH1cblxuXHRwdWJsaWMgaGFzTm9kZShuYW1lOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50Lmhhc05vZGUodGhpcy5wYXJlbnQubmFtZSwgdGhpcy5uYW1lLCBuYW1lKVxuXHR9XG5cblx0cHVibGljIGFkZE5vZGUobmFtZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50LnBhcmVudC5hZGROb2RlKHRoaXMucGFyZW50Lm5hbWUsIHRoaXMubmFtZSwgbmFtZSlcblx0fVxuXG5cdHB1YmxpYyByZW1Ob2RlKG5hbWU6IHN0cmluZykge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQucmVtTm9kZSh0aGlzLnBhcmVudC5uYW1lLCB0aGlzLm5hbWUsIG5hbWUpO1xuXHR9XG5cblx0cHVibGljIHJlbmFtZU5vZGUobmFtZTogc3RyaW5nLCByZW5hbWU6IHN0cmluZykge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQucmVuYW1lTm9kZSh0aGlzLnBhcmVudC5uYW1lLCB0aGlzLm5hbWUsIG5hbWUsIHJlbmFtZSlcblx0fVxuXG5cblxuXHRwdWJsaWMgX2dldE5vZGUobmFtZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMuZmluZChwID0+IHAubmFtZSA9PSBuYW1lKTtcblx0fVxuXG5cdHB1YmxpYyBfaGFzTm9kZShuYW1lOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gISEodGhpcy5ub2Rlcy5maW5kKHAgPT4gcC5uYW1lID09IG5hbWUpKVxuXHR9XG5cblx0cHVibGljIF9hZGROb2RlKGxpbms6IEdyb2JOb2RlVHlwZSwgc3lzdGVtOiBVSVN5c3RlbSkgeyAgIFxuXHRcdGxldCB1Tm9kZSA9IG5ldyBVSU5vZGUoc3lzdGVtLCBsaW5rKTtcblx0XHR0aGlzLm5vZGVzLnB1c2godU5vZGUpO1xuXHRcdHVOb2RlLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5rZXksIHVwZGF0ZUV2ZW50cy52YWxpZENoYW5nZSwgdGhpcy5pc1ZhbGlkVXBkYXRlLmJpbmQodGhpcykpO1xuXHRcdHVOb2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICB0aGlzLnVwZGF0ZSgpO1xuXHRcdHJldHVybiB1Tm9kZTtcblx0fVxuXG5cdHB1YmxpYyBfcmVtTm9kZShuYW1lOiBzdHJpbmcpIHtcblx0XHRsZXQgdU5vZGUgPSB0aGlzLm5vZGVzLmZpbmQocCA9PiBwLm5hbWUgPT0gbmFtZSk7XG5cdFx0dGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKHAgPT4gcC5uYW1lICE9IG5hbWUpO1xuXHRcdHVOb2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMua2V5KTtcblx0XHR1Tm9kZT8uZGlzcG9zZSgpO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH1cblxuXG59IiwiXG5pbXBvcnQgeyBTdHJpbmdGdW5jdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvY29yZS9CYXNlRnVuY3Rpb25zL3N0cmluZ2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgSVZpZXdFbGVtZW50VXBkYXRlYWJsZSwgdXBkYXRlRXZlbnRzLCBVcGRhdGVMaXN0ZW5lciB9IGZyb20gXCIuL1ZhcmlvdXNcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFwiLi5cIjsgXG5pbXBvcnQgeyBHcm9iQ29sbGVjdGlvbiwgR3JvYkdyb3VwLCBHcm9iTm9kZVR5cGUgfSBmcm9tIFwidHRycGctc3lzdGVtLWdyYXBoXCI7XG5pbXBvcnQgeyBVSVN5c3RlbSB9IGZyb20gXCIuL1VJU3lzdGVtXCI7XG5pbXBvcnQgeyBVSUNvbGxlY3Rpb24gfSBmcm9tIFwiLi9VSUNvbGxlY3Rpb25cIjtcblxuZXhwb3J0IGNsYXNzIFVJR3JvdXAgZXh0ZW5kcyBVcGRhdGVMaXN0ZW5lciBpbXBsZW1lbnRzIElWaWV3RWxlbWVudFVwZGF0ZWFibGUge1xuXG5cblx0c3lzOiBVSVN5c3RlbTtcblx0bGluazogR3JvYkdyb3VwPEdyb2JOb2RlVHlwZT47XG5cdGNvbGxlY3Rpb25zOiBVSUNvbGxlY3Rpb25bXSA9IFtdO1xuXHRrZXk6IHN0cmluZztcblx0bmFtZTogc3RyaW5nO1xuXHRuYW1lRWRpdDogc3RyaW5nO1xuXHR2YWxpZDogYm9vbGVhbjtcblx0cGFyZW50OiBVSVN5c3RlbTtcblxuICAgIHByaXZhdGUgX2lzQ29uc3RydWN0ZWQgPSBmYWxzZTtcblxuXHRjb25zdHJ1Y3RvcihzeXN0ZW06IFVJU3lzdGVtLCBncm91cDogR3JvYkdyb3VwPEdyb2JOb2RlVHlwZT4pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc3lzID0gc3lzdGVtO1xuXHRcdHRoaXMubGluayA9IGdyb3VwO1xuXG5cdFx0dGhpcy5rZXkgPSBncm91cC5nZXRLZXkoKTtcblx0XHR0aGlzLm5hbWUgPSBncm91cC5nZXROYW1lKCk7XG5cdFx0dGhpcy5uYW1lRWRpdCA9IHRoaXMubmFtZTtcblxuXHRcdHZhciBpc1ZhbGlkID0gdHJ1ZTtcblx0XHR2YXIgY29sTmFtZXMgPSBncm91cC5nZXRDb2xsZWN0aW9uc05hbWVzKCk7IFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG4gPSBjb2xOYW1lc1tpXTtcblx0XHRcdGNvbnN0IGNvbCA9IGdyb3VwLmdldENvbGxlY3Rpb24obik7XG5cblx0XHRcdGlmICghY29sKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgdWljb2wgPSB0aGlzLl9hZGRDb2xsZWN0aW9uKHRoaXMuc3lzLCBjb2wpO1xuXHRcdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgdWljb2wudmFsaWQ7XG5cdFx0fVxuXHRcdHRoaXMubGluay5hZGRVcGRhdGVMaXN0ZW5lcih0aGlzLmtleSwgdGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cdFx0dGhpcy52YWxpZCA9IGlzVmFsaWQ7XG4gICAgICAgIHRoaXMuX2lzQ29uc3RydWN0ZWQgPSB0cnVlO1xuXG5cdH1cblxuXHRpc1ZhbGlkVXBkYXRlKCkge1xuXG5cdFx0bGV0IG9yaWcgPSB0aGlzLnZhbGlkO1xuXG5cdFx0dmFyIGlzVmFsaWQgPSB0cnVlO1xuXHRcdHRoaXMuY29sbGVjdGlvbnMuZm9yRWFjaChwID0+IHtcblx0XHRcdGlzVmFsaWQgPSBpc1ZhbGlkICYmIHAudmFsaWQ7XG5cdFx0fSlcblx0XHR0aGlzLnZhbGlkID0gaXNWYWxpZDtcblxuXHRcdGlmIChvcmlnICE9IHRoaXMudmFsaWQpIHtcblx0XHRcdHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycyh1cGRhdGVFdmVudHMudmFsaWRDaGFuZ2UpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuICAgICAgICBpZighdGhpcy5faXNDb25zdHJ1Y3RlZCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG5cdFx0dGhpcy5rZXkgPSB0aGlzLmxpbmsuZ2V0S2V5KCk7XG5cdFx0dGhpcy5uYW1lID0gdGhpcy5saW5rLmdldE5hbWUoKTtcblx0XHR0aGlzLm5hbWVFZGl0ID0gdGhpcy5saW5rLmdldE5hbWUoKTtcblx0XHR2YXIgY29sTmFtZXMgPSB0aGlzLmxpbmsuZ2V0Q29sbGVjdGlvbnNOYW1lcygpO1xuXHRcdFxuXHRcdC8vIFVJR3JvdXAgVXBkYXRlXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2xOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XG5cdFx0XHQvLyBpZiBhbHJlYWR5IGV4aXN0cy4gZG9udCBtYWtlIGEgbmV3XG5cdFx0XHRjb25zdCBuID0gY29sTmFtZXNbaV07XG5cdFx0XHRpZih0aGlzLl9oYXNDb2xsZWN0aW9uKG4pKXtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbCA9IHRoaXMubGluay5nZXRDb2xsZWN0aW9uKG4pOyBcblx0XHRcdGlmICghY29sKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgdWljb2wgPSB0aGlzLl9hZGRDb2xsZWN0aW9uKHRoaXMuc3lzLCBjb2wpO1xuXHRcdH0gXG5cblx0XHR0aGlzLmlzVmFsaWRVcGRhdGUoKTtcblx0XHR0aGlzLmNhbGxVcGRhdGVMaXN0ZW5lcnModXBkYXRlRXZlbnRzLnVwZGF0ZSk7XG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHRcdHRoaXMuY29sbGVjdGlvbnMuZm9yRWFjaChuID0+IG4uZGlzcG9zZSgpKTtcblxuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHRoaXMubGluayA9IG51bGw7XG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0dGhpcy5zeXMgPSBudWxsO1xuXG5cdFx0dGhpcy5jb2xsZWN0aW9ucyA9IFtdO1xuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0fVxuXG5cdHB1YmxpYyBnZXRDb2xsZWN0aW9uKGdyb3VwOiBzdHJpbmcsIGNvbDogc3RyaW5nKSB7XG5cdFx0dGhpcy5wYXJlbnQuZ2V0Q29sbGVjdGlvbihncm91cCwgY29sKTtcblx0fVxuXHRwdWJsaWMgaGFzQ29sbGVjdGlvbihncm91cDogc3RyaW5nLCBjb2w6IHN0cmluZykge1xuXHRcdHRoaXMucGFyZW50Lmhhc0NvbGxlY3Rpb24oZ3JvdXAsIGNvbCk7XG5cdH1cblx0cHVibGljIGFkZENvbGxlY3Rpb24oZ3JvdXA6IHN0cmluZywgY29sOiBzdHJpbmcpIHtcblx0XHR0aGlzLnBhcmVudC5hZGRDb2xsZWN0aW9uKGdyb3VwLCBjb2wpO1xuXHR9XG5cdHB1YmxpYyByZW1Db2xsZWN0aW9uKGdyb3VwOiBzdHJpbmcsIGNvbDogc3RyaW5nKSB7IFxuXHRcdHRoaXMucGFyZW50LnJlbUNvbGxlY3Rpb24oZ3JvdXAsIGNvbCk7XG5cdH1cblxuXHRwdWJsaWMgX2dldENvbGxlY3Rpb24oY29sOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gdGhpcy5jb2xsZWN0aW9ucy5maW5kKHAgPT4gcC5uYW1lID09IGNvbCk7XG5cdH1cblx0cHVibGljIF9oYXNDb2xsZWN0aW9uKGNvbDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuY29sbGVjdGlvbnMuZmluZChwID0+IHAubmFtZSA9PSBjb2wpKTtcblx0fVxuXHRwdWJsaWMgX2FkZENvbGxlY3Rpb24oc3lzdGVtOiBVSVN5c3RlbSwgY29sOiBHcm9iQ29sbGVjdGlvbjxHcm9iTm9kZVR5cGU+KSB7XG5cdFx0XG5cdFx0bGV0IHVDb2wgPSBuZXcgVUlDb2xsZWN0aW9uKHN5c3RlbSwgY29sKTtcblx0XHR0aGlzLmNvbGxlY3Rpb25zLnB1c2godUNvbCk7XG5cdFx0dUNvbC5hZGRFdmVudExpc3RlbmVyKHRoaXMua2V5LCB1cGRhdGVFdmVudHMudmFsaWRDaGFuZ2UsIHRoaXMuaXNWYWxpZFVwZGF0ZS5iaW5kKHRoaXMpKTtcblx0XHR1Q29sLnBhcmVudCA9IHRoaXM7XG5cdFx0cmV0dXJuIHVDb2w7XG5cdH1cblx0cHVibGljIF9yZW1Db2xsZWN0aW9uKGNvbDogc3RyaW5nKSB7XG5cdFx0bGV0IHVDb2wgPSB0aGlzLmNvbGxlY3Rpb25zLmZpbmQocCA9PiBwLm5hbWUgPT0gY29sKTtcblx0XHR0aGlzLmNvbGxlY3Rpb25zID0gdGhpcy5jb2xsZWN0aW9ucy5maWx0ZXIocCA9PiBwLm5hbWUgIT0gY29sKTtcblx0XHR1Q29sPy5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMua2V5KTtcblx0XHR1Q29sPy5kaXNwb3NlKCk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fVxuXG5cbn0iLCJpbXBvcnQgeyBTdHJpbmdGdW5jdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvY29yZS9CYXNlRnVuY3Rpb25zL3N0cmluZ2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgdXBkYXRlRXZlbnRzLCBVcGRhdGVMaXN0ZW5lciB9IGZyb20gXCIuL1ZhcmlvdXNcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IFVJR3JvdXAgfSBmcm9tIFwiLi9VSUdyb3VwXCI7XG5pbXBvcnQgeyBHcm9iR3JvdXAsIEdyb2JOb2RlVHlwZSB9IGZyb20gXCJ0dHJwZy1zeXN0ZW0tZ3JhcGhcIjtcblxuXG5leHBvcnQgY2xhc3MgVUlTeXN0ZW0gZXh0ZW5kcyBVcGRhdGVMaXN0ZW5lciB7XG5cblx0c3lzOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nO1xuXHRncm91cHM6IFVJR3JvdXBbXSA9IFtdO1xuXHR2YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cblx0Y29uc3RydWN0b3Ioc3lzdGVtOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnN5cyA9IHN5c3RlbTtcblx0XHR0aGlzLnZhbGlkID0gdHJ1ZTtcblx0XHRsZXQgZ3JvdXBzID0gWydkZXJpdmVkJywgJ2ZpeGVkJ107IFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBncnAgPSB0aGlzLnN5cy5kYXRhW2dyb3Vwc1tpXV0gYXMgR3JvYkdyb3VwPEdyb2JOb2RlVHlwZT47O1xuXHRcdFx0Y29uc3QgdWlncnAgPSBuZXcgVUlHcm91cCh0aGlzLCBncnApO1xuICAgICAgICAgXG5cdFx0XHR0aGlzLmdyb3Vwcy5wdXNoKHVpZ3JwKTtcblx0XHRcdHRoaXMudmFsaWQgPSB0aGlzLnZhbGlkICYmIHVpZ3JwLnZhbGlkO1xuXHRcdFx0dWlncnAuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmd1aWQsIHVwZGF0ZUV2ZW50cy52YWxpZENoYW5nZSwgdGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cdFx0XHR1aWdycC5wYXJlbnQgPSB0aGlzO1xuXHRcdH1cblx0fVxuXHR1cGRhdGUoKSB7XG5cblx0XHRsZXQgb3JpZyA9IHRoaXMudmFsaWQ7XG5cblx0XHR2YXIgaXNWYWxpZCA9IHRydWU7XG5cdFx0dGhpcy5ncm91cHMuZm9yRWFjaChwID0+IHtcblx0XHRcdGlzVmFsaWQgPSBpc1ZhbGlkICYmIHAudmFsaWQ7XG5cdFx0fSlcblx0XHR0aGlzLnZhbGlkID0gaXNWYWxpZDtcblxuXHRcdGlmIChvcmlnICE9IHRoaXMudmFsaWQpIHtcblx0XHRcdHRoaXMuY2FsbFVwZGF0ZUxpc3RlbmVycyh1cGRhdGVFdmVudHMudmFsaWRDaGFuZ2UpO1xuXHRcdH1cblx0XHR0aGlzLmNhbGxVcGRhdGVMaXN0ZW5lcnModXBkYXRlRXZlbnRzLnVwZGF0ZSk7XG5cdH1cblxuXG5cdHB1YmxpYyBnZXRHcm91cChuYW1lOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gdGhpcy5ncm91cHMuZmluZChwID0+IHAubmFtZSA9PSBuYW1lKTtcblx0fVxuXHRwdWJsaWMgaGFzR3JvdXAobmFtZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRHcm91cChuYW1lKVxuXHR9XG5cblx0cHVibGljIGdldENvbGxlY3Rpb24oZ3JvdXA6IHN0cmluZywgY29sOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHcm91cChncm91cCk/Ll9nZXRDb2xsZWN0aW9uKGNvbCk7XG5cdH1cblx0cHVibGljIGhhc0NvbGxlY3Rpb24oZ3JvdXA6IHN0cmluZywgY29sOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldENvbGxlY3Rpb24oZ3JvdXAsIGNvbCk7XG5cdH1cblx0cHVibGljIGFkZENvbGxlY3Rpb24oZ3JvdXA6IHN0cmluZywgY29sPzogc3RyaW5nKSB7XG4gXG5cdFx0aWYgKCFjb2wpIHtcblx0XHRcdGNvbnN0IG5hbWVzID0gdGhpcy5zeXMuZ2V0Q29sbGVjdGlvbk5hbWVzKGdyb3VwKTtcblx0XHRcdGNvbCA9IFN0cmluZ0Z1bmN0aW9ucy5yZWN1cnNpdmVGaW5kTmV3TmFtZSgnbmV3IENvbGxlY3Rpb24nLCBuYW1lcywgKGUpID0+IGUpXG5cdFx0fSBcblxuXHRcdGNvbnN0IGdDb2wgPSB0aGlzLnN5cy5jcmVhdGVDb2xsZWN0aW9uKGdyb3VwLCBjb2wpIGFzIGFueTsgXG5cdH1cblx0cHVibGljIHJlbUNvbGxlY3Rpb24oZ3JvdXA6IHN0cmluZywgY29sOiBzdHJpbmcpIHtcblx0XHRcblx0XHR0aGlzLmdldEdyb3VwKGdyb3VwKT8uX3JlbUNvbGxlY3Rpb24oY29sKTtcblx0fVxuXHRwdWJsaWMgcmVuYW1lQ29sbGVjdGlvbihncm91cDogc3RyaW5nLCBjb2w6IHN0cmluZywgcmVuYW1lOiBzdHJpbmcpIHtcblx0XHR0aGlzLnN5cy5yZW5hbWVDb2xsZWN0aW9uKGdyb3VwLCBjb2wsIHJlbmFtZSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0Tm9kZShncm91cDogc3RyaW5nLCBjb2w6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R3JvdXAoZ3JvdXApPy5fZ2V0Q29sbGVjdGlvbihjb2wpPy5fZ2V0Tm9kZShuYW1lKTtcblx0fVxuXHRwdWJsaWMgaGFzTm9kZShncm91cDogc3RyaW5nLCBjb2w6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXROb2RlKGdyb3VwLCBjb2wsIG5hbWUpO1xuXHR9XG5cdHB1YmxpYyBhZGROb2RlKGdyb3VwOiBzdHJpbmcsIGNvbDogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSB7XG5cblx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdGNvbnN0IG5hbWVzID0gdGhpcy5zeXMuZ2V0Tm9kZU5hbWVzKGdyb3VwLCBjb2wpID8/IFtdO1xuXHRcdFx0bmFtZSA9IFN0cmluZ0Z1bmN0aW9ucy5yZWN1cnNpdmVGaW5kTmV3TmFtZSgnbmV3IG5vZGUnLCBuYW1lcywgKGUpID0+IGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3lzLmNyZWF0ZU5vZGUoZ3JvdXAsIGNvbCwgbmFtZSk7XG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMuc3lzLmdldE5vZGUoZ3JvdXAsIGNvbCwgbmFtZSk7XG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgYWRkIG5ldyBub2RlJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZ2V0R3JvdXAoZ3JvdXApPy5fZ2V0Q29sbGVjdGlvbihjb2wpPy5fYWRkTm9kZShub2RlLCB0aGlzKTtcblx0fVxuXHRwdWJsaWMgcmVtTm9kZShncm91cDogc3RyaW5nLCBjb2w6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG5cdFx0XG5cdFx0dGhpcy5zeXMuZGVsZXRlTm9kZShncm91cCwgY29sLCBuYW1lKTtcblx0XHR0aGlzLmdldEdyb3VwKGdyb3VwKT8uX2dldENvbGxlY3Rpb24oY29sKT8uX3JlbU5vZGUobmFtZSk7XG5cdH1cblx0cHVibGljIHJlbmFtZU5vZGUoZ3JvdXA6IHN0cmluZywgY29sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgcmVuYW1lKSB7XG4gICAgICAgIHRoaXMuc3lzLnJlbmFtZUl0ZW0oZ3JvdXAsIGNvbCwgbmFtZSwgcmVuYW1lKTtcblx0fVxuXG59IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0LCB3cml0YWJsZSwgdHlwZSBXcml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7IFxuXHQgXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbkRlc3Ryb3ksIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBGaXhlZEl0ZW1Db250cm9sbGVyIH0gZnJvbSAnLi9JdGVtQ29udHJvbGxlcnMnO1xuXHRpbXBvcnQgeyBHcm9iSkZpeGVkTm9kZSwgR3JvYkpOb2RlVHlwZSwgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXInO1xuXHRpbXBvcnQgU3RhdGljTWVzc2FnZUhhbmRsZXIgXHRcdFx0XHRcdFx0XHRcdFx0XHRmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL01lc3NhZ2VzL1N0YXRpY01lc3NhZ2VIYW5kbGVyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBVSU5vZGUgfVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9VSUNvbXBvc2l0aW9uL1VJTm9kZSc7XG4gICAgaW1wb3J0IHsgVUlTeXN0ZW0gfVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9VSUNvbXBvc2l0aW9uL1VJU3lzdGVtJztcbiBcblx0ZXhwb3J0IGxldCBub2RlIDogVUlOb2RlO1xuXHRleHBvcnQgbGV0IHN5c3RlbSA6IFVJU3lzdGVtOyBcblx0ZXhwb3J0IGxldCBzZWNvbmRTbGlkZUluUmVhZHkgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBnb29kVGl0bGUgPSBcIk5vIEVycm9yXCI7XG5cdGV4cG9ydCBsZXQgYmFkVGl0bGUgPSBcIkVycm9yXCJcblx0ZXhwb3J0IGxldCBtZXNzYWdlSGFuZGxlciA6IFN0YXRpY01lc3NhZ2VIYW5kbGVyO1xuXHRcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpOyBcblx0bGV0IGNvbnRyb2xsZXIgOiBGaXhlZEl0ZW1Db250cm9sbGVyID0gbmV3IEZpeGVkSXRlbUNvbnRyb2xsZXIoKTtcblx0XG5cdFxuXHQgXG5cdGxldCBjb250cm9sbGVyTmFtZVx0XHRcdDogV3JpdGFibGU8c3RyaW5nPjtcblx0bGV0IGNvbnRyb2xsZXJWYWx1ZVx0XHRcdDogV3JpdGFibGU8bnVtYmVyPjtcblx0bGV0IGNvbnRyb2xsZXJJc1ZhbGlkXHRcdDogV3JpdGFibGU8Ym9vbGVhbj47XG5cdCQ6IG9yaWdOYW1lID0gbm9kZT8ubmFtZSA/PyAnJzsgXG5cblx0ZnVuY3Rpb24gb25OYW1lSW5wdXQgKCBldmVudCA6IGFueSAgKXsgICBcblx0XHRsZXQgbmFtZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0XHRjb250cm9sbGVyLm5hbWUuc2V0KCBuYW1lKTtcblx0XHRjb250cm9sbGVyLmNoZWNrSXNWYWxpZCggKTsgIFxuXHR9XG5cdGZ1bmN0aW9uIG9uU3RhbmRhcmRWYWx1ZUlucHV0ICggZXZlbnQgOiBhbnkgICl7ICAgXG5cdFx0bGV0IG5hbWUgPSBldmVudC50YXJnZXQudmFsdWU7XG5cdFx0Y29udHJvbGxlci5uYW1lLnNldCggbmFtZSk7XG5cdFx0Y29udHJvbGxlci5jaGVja0lzVmFsaWQoICk7ICBcblx0fVxuXHQgXG5cdGZ1bmN0aW9uIG9uU2F2ZSgpeyAgXG5cdFx0aWYgKCBjb250cm9sbGVyLnNhdmVOb2RlQ2hhbmdlcygpICl7XG5cdFx0XHRjb25zdCBvbGROYW1lID0gb3JpZ05hbWU7XG5cdFx0XHRjb25zdCBuZXdOYW1lID0gZ2V0KGNvbnRyb2xsZXIubmFtZSk7XG5cdFx0XHRkaXNwYXRjaCgnc2F2ZScsIHsgb2xkTmFtZTogb2xkTmFtZSwgbmV3TmFtZSA6IG5ld05hbWUgfSk7XG5cdFx0XHRvcmlnTmFtZSA9IG5ld05hbWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRvbk1vdW50KG1vdW50KVxuXHRmdW5jdGlvbiBtb3VudCgpe1xuXHRcdGNvbnRyb2xsZXIuc2V0Q29udHJvbGxlckRlcHMoIG5vZGUgLCBzeXN0ZW0gLCAobXNnKSA9PiB7fSApOyBcblx0XHRjb250cm9sbGVyLmNoZWNrSXNWYWxpZCgpOyAgIFxuXHRcdGNvbnRyb2xsZXJOYW1lXHRcdFx0PSBjb250cm9sbGVyLm5hbWU7XG5cdFx0b3JpZ05hbWVcdFx0XHRcdD0gJGNvbnRyb2xsZXJOYW1lO1xuXHRcdGNvbnRyb2xsZXJWYWx1ZVx0XHRcdD0gY29udHJvbGxlci5zdGFuZGFyZFZhbHVlO1xuXHRcdGNvbnRyb2xsZXJJc1ZhbGlkXHRcdD0gY29udHJvbGxlci5pc1ZhbGlkOyBcblx0fVxuXG5cdGV4cG9ydCBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpe1xuXHRcdG1vdW50KCk7XG5cdH1cblxuPC9zY3JpcHQ+IFxuPGRpdiBjbGFzcz1cIml0ZW1EZXNpZ25lclwiPlxuXHQ8ZGl2PlxuXHRcdDxwPlxuXHRcdFx0RWRpdGluZyBub2RlLlxuXHRcdFx0SGVyZSB5b3UgY2FuIGVkaXQgc2V0dGluZ3MgZm9yIHRoaXMgc3BlY2lmaWMgbm9kZS4gdGhpcyBlZGl0IGlzIHVuaXF1ZSB0byB0aGlzIHNwZWNpZmljIGl0ZW0uXG5cdFx0PC9wPlxuXHQ8L2Rpdj5cblx0PGRpdiBjbGFzcz1cIkl0ZW1EZXNpZ25lckRhdGFDb2x1bW5zXCIgPlxuXG5cdFx0PGRpdj5Ob2RlIE5hbWU8L2Rpdj5cblx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cIkl0ZW1EZXNpZ25lcklucHV0XCIgb246aW5wdXQ9eyBvbk5hbWVJbnB1dCB9ICAgY29udGVudGVkaXRhYmxlIGJpbmQ6dmFsdWU9eyAkY29udHJvbGxlck5hbWUgfS8+XG5cblx0XHQ8ZGl2Pk5vZGUgTG9jYXRpb248L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiSXRlbURlc2lnbmVySW5wdXRcIiA+eyAobm9kZS5saW5rPy5wYXJlbnQ/LnBhcmVudD8ubmFtZSA/PyAndW5rbm93biBjb2xsZWN0aW9uJykgKyAnLicgKyggbm9kZS5saW5rPy5wYXJlbnQ/Lm5hbWUgPz8gJ3Vua25vd24gY29sbGVjdGlvbicpICsgJy4nICsgbm9kZT8ubmFtZX08L2Rpdj5cblxuXHRcdDxkaXY+U3RhbmRhcmQgVmFsdWU8L2Rpdj5cblx0XHQ8aW5wdXQgdHlwZT1cIm51bWJlclwiIGNsYXNzPVwiSXRlbURlc2lnbmVySW5wdXRcIiBvbjppbnB1dD17IG9uU3RhbmRhcmRWYWx1ZUlucHV0IH0gY29udGVudGVkaXRhYmxlIGJpbmQ6dmFsdWU9eyAkY29udHJvbGxlclZhbHVlIH0gLz5cblxuXHQ8L2Rpdj5cblx0PGRpdiBjbGFzcz1cIkl0ZW1EZXNpZ25lckJ1dHRvblJvd1wiPlxuXHRcdDxidXR0b24gb246Y2xpY2s9eyBvblNhdmUgfSBkaXNhYmxlZD17ISRjb250cm9sbGVySXNWYWxpZH0gPnNhdmUgY2hhbmdlczwvYnV0dG9uPiBcblx0XHQ8YnV0dG9uPmRlbGV0ZTwvYnV0dG9uPiBcblx0PC9kaXY+XG5cdDxicj48YnI+XG48L2Rpdj4gIiwiXG5pbXBvcnQgeyBjdWJpY091dCAsIFx0ZWxhc3RpY0luT3V0fSBmcm9tICdzdmVsdGUvZWFzaW5nJztcbmltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuIFxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFNsaWRlKG5vZGUgLCBwYXJhbXMgLCBpc0luVHJhbnNpdGlvbiA9IGZhbHNlICkge1xuICAgIFxuICAgIFxuICAgIHZhciBjb250YWluZXIgPSBwYXJhbXMuY29udGFpbmVyO1xuICAgIHZhciBidXR0b24gPSBwYXJhbXMuYnV0dG9uO1xuXG4gICAgLy8gaWYgdGhlIHBvc2l0aW9uIGlzIGFic29sdXRlIHRoZW4gd2UganVzdCB1c2Ugbm9ybWFsIHNsaWRlLiBmb3IgaXQgaXMgdGhlIHN0aWxlIGZvciBwaG9uZXMuXG4gICAgY29uc3QgYSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSkucG9zaXRpb24gPT0gJ2ZpeGVkJztcbiAgICBpZihhIHx8ICFjb250YWluZXIgKXtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgdXNlZCB3ZSByZXNldCB0aGUgc3R5bGVzIHdlIGFyZSBkZXBlbmRlbnQgb24uXG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgIG5vZGUuc3R5bGUubWF4SGVpZ2h0ID0gJyc7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ25vc3BlY2lhbCB0cmFuc2l0aW9uJyk7XG4gICAgICAgIHJldHVybiBzbGlkZSggbm9kZSwgcGFyYW1zICk7XG4gICAgfVxuICAgIFxuICAgIHZhciBleGlzdGluZ1RyYW5zZm9ybTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luIDtcbiAgICBpZiAoIGlzSW5UcmFuc2l0aW9uICl7XG4gICAgICAgIC8vIGdldCBib3VuZHMgb2YgdGhlIHNjcmVlblxuICAgICAgICBjb25zdCBtcmVjdCA9IGNvbnRhaW5lciAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGxyZWN0ID0gbm9kZSAgICAgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyBcbiAgICBcbiAgICAgICAgY29uc3QgbWVhc3VyZUJlbmVhdGhCb3R0b20gID0gbHJlY3QuYm90dG9tIC0gbXJlY3QuYm90dG9tO1xuICAgICAgICBjb25zdCBiZW5lYXRoQm90dG9tID0gbWVhc3VyZUJlbmVhdGhCb3R0b20gPiAwO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbWVhc3VyZUFib3ZlVG9wID0gLTEgKiAoIGxyZWN0LnRvcCAtIGxyZWN0LmhlaWdodCkgKyBtcmVjdC50b3A7XG4gICAgICAgIGNvbnN0IGFib3ZlVG9wID0gbWVhc3VyZUFib3ZlVG9wID4gMDtcblxuICAgICAgICB2YXIgZ29VcDtcbiAgICAgICAgaWYgKGJlbmVhdGhCb3R0b20gJiYgYWJvdmVUb3ApeyBcbiAgICAgICAgICAgIGlmKCBtZWFzdXJlQWJvdmVUb3AgPCAgbWVhc3VyZUJlbmVhdGhCb3R0b20pe1xuICAgICAgICAgICAgICAgIGdvVXA9dHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgZ29VcD1mYWxzZTtcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlbmVhdGhCb3R0b20peyBcbiAgICAgICAgICAgIGdvVXA9dHJ1ZTtcbiAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICBnb1VwPWZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heEhlaWdodDtcbiAgICAgICAgaWYoZ29VcCl7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBtZWFzdXJlQWJvdmVUb3AgPiAwID8gbHJlY3QuaGVpZ2h0IC0gbWVhc3VyZUFib3ZlVG9wIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gbWVhc3VyZUJlbmVhdGhCb3R0b20gPiAwID8gbHJlY3QuaGVpZ2h0IC0gbWVhc3VyZUJlbmVhdGhCb3R0b20gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1heEhlaWdodCl7XG4gICAgICAgICAgICBub2RlLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbWF4IGhlaWdodC4gdGhlbiBhcHBseSBpdC5cbiAgICAgICAgaWYobWF4SGVpZ2h0KXtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIGdvaW5nIHVwIHRoZW4gd2UgYXJlIHRyYW5zbGF0aW5nIHRoZSBpdGVtIHVwd2FyZHNcbiAgICAgICAgdmFyIGhlaWdodCA9IG1heEhlaWdodCA/PyBscmVjdC5oZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IGdvVXAgPyAoaGVpZ2h0ICogLTEpIDogMDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtICA9IGB0cmFuc2xhdGVZKCR7aGVpZ2h0fXB4KSB0cmFuc2xhdGVZKCR7KGJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpICogKGdvVXAgPyAtMSA6IDApIC0gKGdvVXAgPyAyMCA6IDAgKSB9cHgpIGA7IDtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSBidXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAncHgnO1xuICAgICAgICBub2RlLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArICdweCc7XG4gICAgICAgIFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBnb1VwID8gJ2JvdHRvbSBsZWZ0JyA6ICd0b3AgbGVmdCc7XG4gICAgICAgIGV4aXN0aW5nVHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS50cmFuc2Zvcm0ucmVwbGFjZSgnbm9uZScsICcnKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS50cmFuc2Zvcm1PcmlnaW47XG4gICAgICAgIGV4aXN0aW5nVHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS50cmFuc2Zvcm0ucmVwbGFjZSgnbm9uZScsICcnKTtcbiAgICB9XG5cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSAgICAgICA6IHBhcmFtcy5kZWxheSAgICAgIHx8IDAsXG4gICAgICAgIGR1cmF0aW9uICAgIDogcGFyYW1zLmR1cmF0aW9uICAgfHwgNDAwLFxuICAgICAgICBlYXNpbmcgICAgICA6IHBhcmFtcy5lYXNpbmcgICAgIHx8IGN1YmljT3V0LFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgdHJhbnNmb3JtLW9yaWdpbjogJHt0cmFuc2Zvcm1PcmlnaW59OyB0cmFuc2Zvcm06ICR7ZXhpc3RpbmdUcmFuc2Zvcm19ICBzY2FsZVkoJHt0fSk7IG9wYWNpdHk6ICR7dH07YCxcbiAgICB9O1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRm9jdXMoKXtcbiAgICBpc0ZvY3Vzc2VkID0gdHJ1ZTsgIFxuICAgIFxuICAgIGlmKCFjb250ZXh0KXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdhaXQgZm9yIGRyb3Bkb3duIHRvIHJlbmRlclxuICAgIGF3YWl0IHRpY2soKTtcblxuICAgIC8vIGdldCBib3VuZHMgb2YgdGhlIHNjcmVlblxuICAgIGNvbnN0IG1yZWN0ID0gY29udGV4dC5tYWluQXBwQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGxyZWN0ID0gbGFiZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZHJlY3QgPSBlbmRUcmFja2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIFxuICAgIGNvbnN0IGRyZWN0SGVpZ2h0ID0gZHJlY3QudG9wIC0gbHJlY3QuYm90dG9tO1xuICAgIFxuICAgIGNvbnN0IG1lYXN1cmVCZW5lYXRoQm90dG9tICA9IChscmVjdC5ib3R0b20gKyBkcmVjdEhlaWdodCkgLSBtcmVjdC5ib3R0b207XG4gICAgY29uc3QgYmVuZWF0aEJvdHRvbSA9IG1lYXN1cmVCZW5lYXRoQm90dG9tID4gMDtcbiAgICBcbiAgICBjb25zdCBtZWFzdXJlQWJvdmVUb3AgPSAtMSAqICgoIGxyZWN0LnRvcCAtIGRyZWN0SGVpZ2h0KSArIG1yZWN0LnRvcCk7XG4gICAgY29uc3QgYWJvdmVUb3AgPSBtZWFzdXJlQWJvdmVUb3AgPiAwO1xuXG4gICAgaWYoICEoYmVuZWF0aEJvdHRvbSB8fCBhYm92ZVRvcCkgKXtcbiAgICAgICAgcG9wVXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpcmVjdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wVXAuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpblRvcCcpO1xuICAgIGlmIChiZW5lYXRoQm90dG9tICYmIGFib3ZlVG9wKXsgXG4gICAgICAgIC8vIHdlZSBzZWxlY3QgVXB3YXJkcyBkaXJlY3Rpb24sIGJ5IGNob3NpZ24gdGhlIGxlYXN0IGFtb3VudCBvZiBzY3JvbGxpbmdcbiAgICAgICAgLy8gdXB3YXJkcyBpcyB0aGUgbGVhc3QgbWVhc3VyZVxuICAgICAgICBpZiggbWVhc3VyZUFib3ZlVG9wIDwgIG1lYXN1cmVCZW5lYXRoQm90dG9tKXtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIC8vIGRvd253YXJkcyBpcyB0aGUgbGVhc3QgbWVhc3VyZVxuICAgICAgICBlbHNle1xuXG4gICAgICAgIH0gIFxuICAgIH1cbiAgICAvLyBHbyB1cHdhcmRzIGlmIGl0IG9ubHkgZ29lcyBiZW5lYXRoIHRoZSBib3R0b21cbiAgICBlbHNlIGlmIChiZW5lYXRoQm90dG9tKXsgXG4gICAgICAgIC8vIEdvIHVwd2FyZHNcbiAgICAgICAgcG9wVXAuc2V0QXR0cmlidXRlKCdkYXRhLWRpcmVjdGlvbicsJ3VwJylcbiAgICAgICAgcG9wVXAuc3R5bGUubWFyZ2luVG9wID0gYC0ke2RyZWN0SGVpZ2h0fXB4YDtcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gZHJlY3RIZWlnaHQgLSBtZWFzdXJlQWJvdmVUb3A7XG4gICAgICAgIGlmIChtYXhIZWlnaHQgPiAwKXsgXG4gICAgICAgICAgICBwb3BVcC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnOyAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcG9wVXAuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21heEhlaWdodCcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHsgXG4gICAgICAgIC8vIEdvIGRvd253YXJkc1xuICAgICAgICBwb3BVcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZGlyZWN0aW9uJywnZG93bicpXG4gICAgICAgIHBvcFVwLnN0eWxlLm1heEhlaWdodCA9IGRyZWN0SGVpZ2h0IC0gbWVhc3VyZUJlbmVhdGhCb3R0b20gKyAncHgnOyAgXG4gICAgfVxuICAgIFxuICAgIC8vIGdldCBsb2NhdGlvbiBvZiB0aGUgYm90dG9tIFRyYWNrZXIuXG5cbiAgICAvLyBpZiB0aGUgdHJhY2tlciBpcyBiZWxvdyB0aGUgYm90dG9tIFNlZSBpZiBpdCBpcyBhYm92ZSB0aGUgdG9wXG4gICAgXG59ICIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGZhZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cdGltcG9ydCB7IGZsaXAgfSBmcm9tICdzdmVsdGUvYW5pbWF0ZSc7XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiOyBcbiAgICBpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcbiAgICBpbXBvcnQgeyBMYXlvdXQwMUNvbnRleHQgfSBmcm9tICcuLi8uLi9WaWV3cy9MYXlvdXQwMS9jb250ZXh0Jztcblx0aW1wb3J0IHsgdGljayB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgc2VsZWN0U2xpZGUgfSBmcm9tICcuL3NlbGVjdFNsaWRlJztcbiAgICBpbXBvcnQgeyBDb25zb2xlIH0gZnJvbSAnY29uc29sZSc7XG5cblxuXHRsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0ZXhwb3J0IGxldCBvcHRpb25zXHQ6IHN0cmluZ1tdO1xuXHRleHBvcnQgbGV0IHNlbGVjdGVkIDogc3RyaW5nIHwgbnVsbCA9IG51bGwgO1xuXHRleHBvcnQgbGV0IHVuU2VsZWN0ZWRwbGFjZWhvbGRlcjpzdHJpbmcgPSdOb25lIFNlbGVjdGVkJztcblx0ZXhwb3J0IGxldCBkaXNhYmxlZCA6Ym9vbGVhbiA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGlzRXJyb3IgXHQ6Ym9vbGVhbiA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGZvcmNlT3Blbjpib29sZWFuID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgbWF4SGVpZ2h0Om51bWJlciA9IDUwMDtcbiAgICBleHBvcnQgbGV0IGNvbnRleHRcdDogTGF5b3V0MDFDb250ZXh0IDtcblx0Y29uc3Qgc3ZlbHRlU3RhbmRhcmRBbmltVGltZSA9IDQwMDtcblxuXHRsZXQgbGFiZWw7XG5cdGxldCBpc0ZvY3Vzc2VkID0gZmFsc2U7IFxuXHRsZXQgZW5kVHJhY2tlcjogSFRNTERpdkVsZW1lbnQ7XG5cdGxldCBzZWxmOiBIVE1MRWxlbWVudDtcblx0bGV0IHBvcFVwOkhUTUxFbGVtZW50O1xuXHRcblx0YXN5bmMgZnVuY3Rpb24gb25Gb2N1cygpe1xuXHRcdGlzRm9jdXNzZWQgPSB0cnVlOyAgXG5cdH0gXG5cblx0ZnVuY3Rpb24gY2xpY2soIGUgKXtcblx0XHRkZWJ1Z2dlclxuXHRcdGlzRm9jdXNzZWQgPSBmYWxzZTtcblx0XHRjb25zb2xlLmxvZygnY2xpY2snKVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzVGFyZ2V0UGFyZW50KCBET006SFRNTEVsZW1lbnQgLCB0YXJnZXQ6SFRNTEVsZW1lbnQgKXtcblx0XHRcdGNvbnN0IHBhcmVudCA9IERPTT8ucGFyZW50RWxlbWVudCA/PyBudWxsIDtcblx0XHRcdGlmIChwYXJlbnQpe1xuXHRcdFx0XHRpZiAocGFyZW50ICE9IHRhcmdldCl7XG5cdFx0XHRcdFx0cmV0dXJuIGhhc1RhcmdldFBhcmVudCggcGFyZW50ICwgdGFyZ2V0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7IFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdH0gXG5cdGZ1bmN0aW9uIGJsdXIoIGUgKXsgXG5cdFx0aXNGb2N1c3NlZD1mYWxzZTtcblx0fSBcblx0ZnVuY3Rpb24gY2xpY2tPcHRpb24oIG9wdCAsIC4uLnBhcmFtcyl7IFxuXHRcdFxuXHRcdGxldCB2YWx1ZSA9IG9wdDtcblx0XHRpZiAoc2VsZWN0ZWQgIT0gdmFsdWUpe1xuXHRcdFx0c2VsZWN0ZWQgPSB2YWx1ZTtcblx0XHRcdGRpc3BhdGNoKCdvblNlbGVjdCcsc2VsZWN0ZWQpXG5cdFx0fVxuXHRcdGlzRm9jdXNzZWQgPSBmYWxzZTsgIFxuXHR9XG5cbjwvc2NyaXB0PlxuPGRpdiBjbGFzcz1cIkdyb2JTZWxlY3RcIiBiaW5kOnRoaXM9e3NlbGZ9PlxuXHR7I2tleSBzZWxlY3RlZH1cblx0XHQ8ZGl2IFxuXHRcdFx0YmluZDp0aGlzPXtsYWJlbH1cblx0XHRcdGNsYXNzPXtcIkdyb2JTZWxlY3RMYWJlbCBlZmZlY3RcIn1cblx0XHRcdGRhdGEtaXNEaXNhYmxlZFx0PXtkaXNhYmxlZFx0Pz8gZmFsc2V9XG5cdFx0XHRkYXRhLWlzRXJyb3JcdD17aXNFcnJvclx0Pz8gZmFsc2V9IFxuXHRcdFx0ZGF0YS1zZWxlY3RlZFx0PXtzZWxlY3RlZFx0Pz8gZmFsc2V9IFxuXHRcdFx0dGFiaW5kZXg9XCItMVwiICBcblx0XHRcdG9uOmZvY3VzPXtvbkZvY3VzfVxuXHRcdFx0b246Ymx1cj17IGJsdXIgfSBcblx0XHQ+XG5cdFx0XHR7IHNlbGVjdGVkID09IG51bGwgPyB1blNlbGVjdGVkcGxhY2Vob2xkZXIgOiBzZWxlY3RlZCB9IFxuXHRcdDwvZGl2PlxuXHR7L2tleX1cblx0PCEtLSBzdmVsdGUtaWdub3JlIG1pc3NpbmctZGVjbGFyYXRpb24gLS0+XG5cdDxkaXY+XG5cdFx0eyNpZiBpc0ZvY3Vzc2VkIHx8IGZvcmNlT3BlbiB9IFxuXHRcdFx0PGRpdiBcblx0XHRcdFx0Y2xhc3M9XCJTZWxlY3RQb3BVcFwiIFxuXHRcdFx0XHRkYXRhLWRpcmVjdGlvbj1cImRvd25cIlxuXHRcdFx0XHR0cmFuc2l0aW9uOnNlbGVjdFNsaWRlPXt7Y29udGFpbmVyIDogY29udGV4dD8ubWFpbkFwcENvbnRhaW5lciwgYnV0dG9uOnNlbGYgfX1cblx0XHRcdFx0YmluZDp0aGlzPXtwb3BVcH1cblx0XHRcdD4gXHRcblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsjaWYgb3B0aW9ucy5sZW5ndGggPT0gMH1cblx0XHRcdFx0XHRcdDxpICBjbGFzcz1cIkdyb2JTZWxlY3RJbmZvXCI+Tm8gT3B0aW9uczwvaT5cblx0XHRcdFx0XHR7OmVsc2V9XHRcblx0XHRcdFx0XHRcdHsjZWFjaCBvcHRpb25zIGFzIG9wdCAob3B0KX1cblx0XHRcdFx0XHRcdFx0PGJ1dHRvbiAgXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJHcm9iU2VsZWN0T3B0aW9uXCIgXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS1zZWxlY3RlZD17c2VsZWN0ZWQgPT0gb3B0fSBcblx0XHRcdFx0XHRcdFx0XHRkYXRhLXZhbHVlPXtvcHR9IFxuXHRcdFx0XHRcdFx0XHRcdG9uOmZvY3VzPXsgKCAuLi5wYXJhbXMgKSA9PiBjbGlja09wdGlvbihvcHQsIC4uLnBhcmFtcykgfSBcblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdHtvcHR9XG5cdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0PGRpdiBcblx0XHRcdFx0XHRcdGNsYXNzPVwic2VsZWN0RW5kVHJhY2tlclwiXG5cdFx0XHRcdFx0XHRiaW5kOnRoaXM9e2VuZFRyYWNrZXJ9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PiBcblx0XHR7L2lmfVxuXHQ8L2Rpdj5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+IFxuICAgICBleHBvcnQgbGV0IGNvbG9yOiBzdHJpbmcgPSBcImJsYWNrXCIgOyBcbjwvc2NyaXB0PlxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPXtjb2xvcn0gc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGNsYXNzPVwic3ZnLWljb24gbHVjaWRlLXRyYXNoLTJcIj5cbiAgICA8cGF0aCBkPVwiTTMgNmgxOFwiPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTE5IDZ2MTRjMCAxLTEgMi0yIDJIN2MtMSAwLTItMS0yLTJWNlwiPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTggNlY0YzAtMSAxLTIgMi0yaDRjMSAwIDIgMSAyIDJ2MlwiPjwvcGF0aD5cbiAgICA8bGluZSB4MT1cIjEwXCIgeTE9XCIxMVwiIHgyPVwiMTBcIiB5Mj1cIjE3XCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiMTRcIiB5MT1cIjExXCIgeDI9XCIxNFwiIHkyPVwiMTdcIj48L2xpbmU+XG48L3N2Zz4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiOyAgXG4gICAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgICBpbXBvcnQgQ3VzdG9tU2VsZWN0XHRcdFx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9DdXN0b21TZWxlY3QvQ3VzdG9tU2VsZWN0LnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFRyYXNoXHRcdFx0XHRcdFx0XHRmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL2J1dHRvbnMvdHJhc2guc3ZlbHRlJztcblx0aW1wb3J0IHsgR3JvYkpOb2RlVHlwZSwgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZyB9XHRmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyJztcdFxuICAgIGltcG9ydCB7IExheW91dDAxQ29udGV4dCB9IGZyb20gXCIuLi8uLi9jb250ZXh0XCI7XG5cblxuXHRcblx0ZXhwb3J0IGxldCBzeXN0ZW06VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZzsgXG5cdHR5cGUgb3JpZ2luUm93RGF0YSA9IHtrZXk6IHN0cmluZywgc2VnbWVudHM6KHN0cmluZ3xudWxsKVtdICwgYWN0aXZlIDpib29sZWFuICwgdGVzdFZhbHVlIDpudW1iZXIsIGluQ2FsYzpib29sZWFuLCB0YXJnZXQ6IEdyb2JKTm9kZVR5cGUgIHwgbnVsbCAsIGlzU2VsZWN0QWxsVGFyZ2V0OmJvb2xlYW4gfTtcblx0ZXhwb3J0IGxldCByb3dEYXRhIDogb3JpZ2luUm93RGF0YTtcblx0ZXhwb3J0IGxldCBhdmFpbGFibGVTeW1ib2xzIDogc3RyaW5nIFtdID0gW107IFxuXHRleHBvcnQgbGV0IGFsbG93U2VsZWN0QWxsIDogYm9vbGVhbiA9IGZhbHNlOyBcblx0ZXhwb3J0IGxldCBTZWxlY3RBbGxUZXh0ID0gJy0tU2VsZWN0IEFsbC0tJ1xuXHRleHBvcnQgbGV0IGNvbnRleHRcdDogTGF5b3V0MDFDb250ZXh0OyBcblxuXHRsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXHRvbk1vdW50KCgpPT57ICAgXG5cdFx0aWYgKG9yaWdpbiAmJiByb3dEYXRhLnNlZ21lbnRzICl7IFxuXHRcdFx0aWYoIShyb3dEYXRhLnNlZ21lbnRzWzBdKSl7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0b3B0aW9uc19sZXZlbDEgPSBzeXN0ZW0uZGF0YVtyb3dEYXRhLnNlZ21lbnRzWzBdXS5nZXRDb2xsZWN0aW9uc05hbWVzKCkgPz8gW107XG5cdFx0XHRpZighcm93RGF0YS5zZWdtZW50c1sxXSl7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0b3B0aW9uc19sZXZlbDIgPSBzeXN0ZW0uZGF0YVtyb3dEYXRhLnNlZ21lbnRzWzBdXS5nZXRDb2xsZWN0aW9uKHJvd0RhdGEuc2VnbWVudHNbMV0pLmdldE5vZGVOYW1lcygpID8/IFtdIDtcblx0XHR9XG5cdH0pXG5cblx0XG5cdGxldCBvcHRpb25zX2xldmVsMCA6c3RyaW5nW10gPSBbJ2ZpeGVkJywnZGVyaXZlZCddO1xuXHRsZXQgb3B0aW9uc19sZXZlbDEgOnN0cmluZ1tdID0gW107XG5cdGxldCBvcHRpb25zX2xldmVsMiA6c3RyaW5nW10gPSBbXTtcblxuXHRmdW5jdGlvbiBvblNlbGVjdCggbGV2ZWwgOiBudW1iZXIgLCB2YWx1ZSA6IHN0cmluZyApe1xuXHRcdHJvd0RhdGEuaXNTZWxlY3RBbGxUYXJnZXQgPSBmYWxzZTtcblx0XHQ7XG5cdFx0c3dpdGNoKGxldmVsKXtcblx0XHRcdGNhc2UgMDpcblxuXHRcdFx0XHRvcHRpb25zX2xldmVsMSA9IHN5c3RlbS5kYXRhW3ZhbHVlXS5nZXRDb2xsZWN0aW9uc05hbWVzKCk7XG5cdFx0XHRcdHJvd0RhdGEuc2VnbWVudHNbMV0gPSBudWxsO1xuXHRcdFx0XHRyb3dEYXRhLnNlZ21lbnRzWzJdID0gbnVsbDtcblx0XHRcdFx0b3B0aW9uc19sZXZlbDIgPVtdO1xuXHRcdFx0XHRpZiAob3JpZ2luKXtcblx0XHRcdFx0XHRkaXNwYXRjaCgnZGVzZWxlY3RUYXJnZXROb2RlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cm93RGF0YS50YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Ly9AdHMtaWdub3JlXG5cdFx0XHRcdG9wdGlvbnNfbGV2ZWwyID0gc3lzdGVtLmdldENvbGxlY3Rpb24ocm93RGF0YS5zZWdtZW50c1swXSx2YWx1ZSk/LmdldE5vZGVOYW1lcygpO1xuXG5cdFx0XHRcdGlmIChhbGxvd1NlbGVjdEFsbCAmJiBvcHRpb25zX2xldmVsMi5sZW5ndGggIT0gMCApe1xuXHRcdFx0XHRcdG9wdGlvbnNfbGV2ZWwyID0gWyBTZWxlY3RBbGxUZXh0ICwgLi4ub3B0aW9uc19sZXZlbDIgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvd0RhdGEuc2VnbWVudHNbMl0gPSBudWxsO1xuXHRcdFx0XHRpZiAob3JpZ2luKXtcblx0XHRcdFx0XHRkaXNwYXRjaCgnZGVzZWxlY3RUYXJnZXROb2RlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cm93RGF0YS50YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblxuXHRcdFx0XHRpZiAoYWxsb3dTZWxlY3RBbGwgJiYgdmFsdWUgPT09IFNlbGVjdEFsbFRleHQpeyAgXG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdHJvd0RhdGEuaXNTZWxlY3RBbGxUYXJnZXQgPSB0cnVlO1xuXHRcdFx0XHRcdGRpc3BhdGNoKCdmb3VuZFNlbGVjdEFsbFRhcmdldE5vZGUnICk7IFxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly9AdHMtaWdub3JlXG5cdFx0XHRcdGxldCB0YXJnZXROb2RlID0gc3lzdGVtLmdldE5vZGUocm93RGF0YS5zZWdtZW50c1swXSxyb3dEYXRhLnNlZ21lbnRzWzFdLHZhbHVlKTtcblx0XHRcdFx0cm93RGF0YS50YXJnZXQgPXRhcmdldE5vZGU7XG5cdFx0XHRcdGRpc3BhdGNoKCdmb3VuZFRhcmdldE5vZGUnLHRhcmdldE5vZGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25EZXNlbGVjdCggbGV2ZWwgOiBudW1iZXIpe1xuXHRcdGlmIChvcmlnaW4pe1xuXHRcdFx0ZGlzcGF0Y2goJ2Rlc2VsZWN0VGFyZ2V0Tm9kZScpO1xuXHRcdH1cblx0XHRzd2l0Y2ggKGxldmVsKXtcblx0XHRcdGNhc2UgMDogXG5cdFx0XHRcdG9wdGlvbnNfbGV2ZWwxID0gW107XG5cdFx0XHRcdG9wdGlvbnNfbGV2ZWwyID1bXTtcblx0XHRcdFx0cm93RGF0YS50YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRyb3dEYXRhLnNlZ21lbnRzWzFdID0gbnVsbDtcblx0XHRcdFx0cm93RGF0YS5zZWdtZW50c1syXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcblx0XHRcdFx0b3B0aW9uc19sZXZlbDIgPSBbXTtcblx0XHRcdFx0cm93RGF0YS5zZWdtZW50c1syXSA9IG51bGw7XG5cdFx0XHRcdHJvd0RhdGEudGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdC8vQHRzLWlnbm9yZVxuXHRcdFx0XHR0YXJnZXROb2RlID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25kZWxldGUoKXtcblx0XHRkaXNwYXRjaCgnb25EZWxldGUnLHJvd0RhdGEua2V5KVxuXHR9XG5cblx0ZnVuY3Rpb24gb25DaGFuZ2VTeW1ib2woIHM6YW55ICl7XG5cdFx0ZGlzcGF0Y2goJ29uU3ltYm9sU2VsZWN0ZWQnLHtvbGQ6cm93RGF0YS5rZXksIG5ldzpzIH0pXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tUHJlT3JpZ2luVG9PcmlnaW4oICAgKXsgXG5cdFx0Y29uc29sZS5sb2coXCJhc2Rhc2RcIik7XG5cdFx0cm93RGF0YS5hY3RpdmUgPSB0cnVlO1xuXHRcdHJvd0RhdGEuc2VnbWVudHMgPSAobmV3IEFycmF5KDMpLmZpbGwobnVsbCkpOyAgIFxuXHR9XG5cbjwvc2NyaXB0PlxuXG57I2lmIHJvd0RhdGEuYWN0aXZlIH1cblx0PGRpdiBjbGFzcz1cImRlcml2ZWRPcmlnaW5Sb3dcIiBkYXRhLXN0eWxlQWN0aXZlPVwidHJ1ZVwiXHR0cmFuc2l0aW9uOnNsaWRlfGxvY2FsICA+XG5cdFx0PCEtLSBUaGUgU3ltYm9sIC0tPlxuXHRcdHsjaWYgYXZhaWxhYmxlU3ltYm9scy5sZW5ndGggPT0gMH1cblx0XHRcdDxkaXYgY2xhc3M9XCJkZXJpdmVkT3JpZ2luUm93SW50ZXJhY3Rpb25GaWVsZFwiID57cm93RGF0YS5rZXl9PC9kaXY+XG5cdFx0ezplbHNlfVxuXHRcdFx0PEN1c3RvbVNlbGVjdCBjb250ZXh0PXtjb250ZXh0fSBzZWxlY3RlZD17cm93RGF0YS5rZXl9IG9wdGlvbnM9eyBbLi4uYXZhaWxhYmxlU3ltYm9scywgcm93RGF0YS5rZXldIH1cdG9uOm9uU2VsZWN0PXsoZSkgPT4ge29uQ2hhbmdlU3ltYm9sKGUuZGV0YWlsKX19IC8+XG5cdFx0ey9pZn0gXG5cblx0XHQ8IS0tIFRlc3QgVmFsdWUgLS0+XG5cdFx0PGlucHV0IHR5cGU9XCJudW1iZXJcIiBvbjpjaGFuZ2U9eygpID0+IGRpc3BhdGNoKCdjaGFuZ2UnKX0gY2xhc3M9XCJkZXJpdmVkT3JpZ2luUm93SW50ZXJhY3Rpb25GaWVsZFwiIGJpbmQ6dmFsdWU9e3Jvd0RhdGEudGVzdFZhbHVlfSAvPlxuXG5cdFx0PCEtLSBTZWxlY3RzIC0tPlxuXHRcdDxDdXN0b21TZWxlY3QgXG5cblx0XHRcdGJpbmQ6c2VsZWN0ZWQ9e3Jvd0RhdGEuc2VnbWVudHNbMF0gfVxuXHRcdFx0b3B0aW9ucz17IG9wdGlvbnNfbGV2ZWwwIH1cdFxuXHRcdFx0Y29udGV4dD17Y29udGV4dH1cdFxuXHRcdFx0XG5cdFx0XHRvbjpvblNlbGVjdD17KGUpID0+IG9uU2VsZWN0KDAsZS5kZXRhaWwpfSBcblx0XHRcdG9uOm9uRGVzZWxlY3Q9eygpPT5vbkRlc2VsZWN0KDApfSBcblx0XHRcdC8+XG5cdFx0PEN1c3RvbVNlbGVjdCBcblx0XHRcdGJpbmQ6c2VsZWN0ZWQ9e3Jvd0RhdGEuc2VnbWVudHNbMV19IFxuXHRcdFx0b3B0aW9ucz17b3B0aW9uc19sZXZlbDF9XHRcblx0XHRcdGRpc2FibGVkPXshKG9wdGlvbnNfbGV2ZWwwKX1cdFxuXHRcdFx0Y29udGV4dD17Y29udGV4dH1cblx0XHRcdFxuXHRcdFx0b246b25TZWxlY3Q9eyhlKSA9PiBvblNlbGVjdCgxLGUuZGV0YWlsKX0gXG5cdFx0XHRvbjpvbkRlc2VsZWN0PXsoKT0+b25EZXNlbGVjdCgwKX0gXG5cdFx0Lz5cblx0XHQ8Q3VzdG9tU2VsZWN0IFxuXHRcdFx0YmluZDpzZWxlY3RlZD17cm93RGF0YS5zZWdtZW50c1syXX0gXG5cdFx0XHRvcHRpb25zPXtvcHRpb25zX2xldmVsMn1cdFxuXHRcdFx0ZGlzYWJsZWQ9eyEob3B0aW9uc19sZXZlbDEpfVx0XG5cdFx0XHRjb250ZXh0PXtjb250ZXh0fVxuXHRcdFx0XHRcblx0XHRcdG9uOm9uU2VsZWN0PXsoZSkgPT4gb25TZWxlY3QoMixlLmRldGFpbCl9XG5cdFx0XHRvbjpvbkRlc2VsZWN0PXsoKT0+b25EZXNlbGVjdCgwKX1cblx0XHRcblx0XHQvPlxuXG5cdFx0PCEtLSBEZWxldGVzIC0tPlxuXHRcdDxpbWFnZWNvbnRhaW5lciBjbGFzcz1cImRlcml2ZWRPcmlnaW5Sb3dJbnRlcmFjdGlvbkZpZWxkXCIgcm9sZT1cIm5vbmVcIiBkYXRhLWNvbG9yPXsgcm93RGF0YS5pbkNhbGMgPyAndmVyYm9zZScgOiAnZXJyb3InIH0gb246Y2xpY2s9e29uZGVsZXRlfSBvbjprZXlkb3duPXtvbmRlbGV0ZX0+XG5cdFx0XHQ8VHJhc2ggY29sb3I9eyd3aGl0ZSd9Lz5cblx0XHQ8L2ltYWdlY29udGFpbmVyPlxuXHQ8L2Rpdj5cbns6ZWxzZX1cblx0PGRpdiBjbGFzcz1cImRlcml2ZWRPcmlnaW5Sb3dcIiBkYXRhLXN0eWxlQWN0aXZlPVwiZmFsc2VcIiBvbjpjbGljaz17ZnJvbVByZU9yaWdpblRvT3JpZ2lufSByb2xlPVwibm9uZVwiIG9uOmtleWRvd249eyBmcm9tUHJlT3JpZ2luVG9PcmlnaW4gfSBcdHRyYW5zaXRpb246c2xpZGV8bG9jYWwgPlxuXHRcdDxkaXY+IHtyb3dEYXRhLmtleX0gPC9kaXY+IFxuXHRcdDxkaXY+IENsaWNrIFRvIEFkZCBhIE9yaWdpbiA8L2Rpdj4gXG5cdFx0eyNpZiAhcm93RGF0YS5pbkNhbGMgfVxuXHRcdFx0PCEtLSBEZWxldGVzIC0tPlxuXHRcdFx0PGltYWdlY29udGFpbmVyIGNsYXNzPVwiZGVyaXZlZE9yaWdpblJvd0ludGVyYWN0aW9uRmllbGRcIiByb2xlPVwibm9uZVwiIGRhdGEtY29sb3I9eyByb3dEYXRhLmluQ2FsYyA/ICd2ZXJib3NlJyA6ICdlcnJvcicgfSBvbjpjbGljaz17b25kZWxldGV9IG9uOmtleWRvd249e29uZGVsZXRlfT5cblx0XHRcdFx0PFRyYXNoIGNvbG9yPXsnd2hpdGUnfS8+XG5cdFx0XHQ8L2ltYWdlY29udGFpbmVyPlxuXHRcdHsvaWZ9XG5cdDwvZGl2Plxuey9pZn0gXG4iLCJcbjxzY3JpcHQgbGFuZz1cInRzXCI+ICAgXG4gICAgaW1wb3J0IHsgd3JpdGFibGUsIHR5cGUgV3JpdGFibGUsIGdldCB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7ICBcbiAgICBpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcbiAgICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnOyAgXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyICwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBEZXJpdmVkSXRlbUNvbnRyb2xsZXIsIG9yaWdpblJvd0RhdGEgfSBmcm9tICcuL0l0ZW1Db250cm9sbGVycyc7XG4gICAgaW1wb3J0IHsgR3JvYkpEZXJpdmVkTm9kZSwgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZyB9IFx0ZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lcic7XG5cdGltcG9ydCBTdGF0aWNNZXNzYWdlSGFuZGxlciBcdFx0XHRcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvTWVzc2FnZXMvU3RhdGljTWVzc2FnZUhhbmRsZXIuc3ZlbHRlJ1xuICAgIGltcG9ydCBPcmlnaW5Sb3cgXHRcdFx0XHRcdFx0XHRcdFx0XHRmcm9tICcuLi8uLi8uLi8uLi9WaWV3cy9PcmlnaW5Sb3cvT3JpZ2luUm93LnN2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgTGF5b3V0MDFDb250ZXh0IH0gXHRcdFx0XHRcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uL2NvbnRleHQnO1xuICAgIGltcG9ydCB7IFVJU3lzdGVtIH1cdFx0XHRcdFx0XHRcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSVN5c3RlbSc7XG4gICAgaW1wb3J0IHsgVUlOb2RlIH1cdFx0XHRcdFx0XHRcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSU5vZGUnO1xuXG5cdGV4cG9ydCBsZXQgbm9kZVx0XHQ6IFVJTm9kZTtcblx0ZXhwb3J0IGxldCBzeXN0ZW1cdDogVUlTeXN0ZW07IFxuXHRleHBvcnQgbGV0IGdvb2RUaXRsZSA9IFwiTm8gRXJyb3JcIjtcblx0ZXhwb3J0IGxldCBiYWRUaXRsZSA9IFwiRXJyb3JcIlxuXHRleHBvcnQgbGV0IGNvbnRleHRcdDogTGF5b3V0MDFDb250ZXh0OyBcblxuXHRsZXQgbWVzc2FnZUhhbmRsZXI6IFN0YXRpY01lc3NhZ2VIYW5kbGVyOyBcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTsgXG5cdFxuXHRsZXQgY29udHJvbGxlciA6IERlcml2ZWRJdGVtQ29udHJvbGxlciA9IG5ldyBEZXJpdmVkSXRlbUNvbnRyb2xsZXIoKTtcblx0JDogY29udHJvbGxlci5zZXRDb250cm9sbGVyRGVwcyhub2RlLHN5c3RlbSwobXNnKSA9PiB7fSlcblx0JDogY29udHJvbGxlci5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuXHQkOiBhdmFpbGFibGVTeW1ib2xzID0gZ2V0KGNvbnRyb2xsZXIubWFwcGVkT3JpZ2lucykuZmlsdGVyKHAgPT4gIXAuYWN0aXZlICkubWFwKCBwID0+IHAua2V5ICk7XG5cdGV4cG9ydCBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpe1xuXHRcdGNvbnRyb2xsZXIudXBkYXRlTWFwcGVkT3JpZ2lucygpXG5cdH1cblx0XG5cdGxldCBmbGFzaCA9IGZhbHNlO1x0XG5cdFxuXHRcblxuXHRsZXQgY29udHJvbGxlck1hcHBlZE9yaWdpblx0OiBXcml0YWJsZTxvcmlnaW5Sb3dEYXRhW10+O1xuXHRsZXQgY29udHJvbGxlclJlc3VsdFZhbHVlXHQ6IFdyaXRhYmxlPG51bWJlcj47XG5cdGxldCBjb250cm9sbGVyUmVzdWx0U3VjY2VzXHQ6IFdyaXRhYmxlPGJvb2xlYW4+O1xuXHRsZXQgY29udHJvbGxlck5hbWVcdFx0XHQ6IFdyaXRhYmxlPHN0cmluZz47XG5cdGxldCBjb250cm9sbGVyQ2FsY1x0XHRcdDogV3JpdGFibGU8c3RyaW5nPjtcblx0bGV0IGNvbnRyb2xsZXJJc1ZhbGlkXHRcdDogV3JpdGFibGU8Ym9vbGVhbj47XG5cblx0Ly8gc2F2ZSBvcmlnaW5hbCBOYW1lXG5cdGxldCBvcmlnTmFtZSA6IHN0cmluZyA7IFxuXG5cdGZ1bmN0aW9uIG9uTmFtZUlucHV0ICggZXZlbnQgOiBhbnkgICl7ICBcblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRsZXQgbmFtZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0XHRjb250cm9sbGVyLm5hbWUuc2V0KCBuYW1lKTtcblx0XHRjb250cm9sbGVyLmNoZWNrSXNWYWxpZChmYWxzZSk7ICBcblx0fVxuXHRmdW5jdGlvbiBvbkNhbGNJbnB1dCAoIGV2ZW50IDogYW55ICApe1xuXHRcdGxldCBjYWxjID0gZXZlbnQudGFyZ2V0LnZhbHVlOyBcblx0XHRjb250cm9sbGVyLmNhbGMuc2V0KCBjYWxjKTtcblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRjb250cm9sbGVyLnJlY2FsY3VsYXRlQ2FsY0FuZE9yaWdpbnMoKTsgIFxuXHRcdGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKTsgICBcblx0fVxuXHRmdW5jdGlvbiByZWNhbGMoKXtcblx0XHRjb250cm9sbGVyLnJlY2FsY3VsYXRlQ2FsY0FuZE9yaWdpbnMoKTsgIFxuXHRcdGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKTsgICBcblx0fVxuXG5cdGZ1bmN0aW9uIG9uRGVsZXRlQ2xpY2tlZChlKXtcblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRjb250cm9sbGVyLm9uS2V5RGVsZXRlKGUpOyBcblx0XHRjb250cm9sbGVyLmNoZWNrSXNWYWxpZChmYWxzZSk7ICBcblx0fVxuXHRmdW5jdGlvbiBvbktleUV4Y2hhbmdlKGUpe1xuXHRcdG1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVFcnJvcignc2F2ZScpO1xuXHRcdGNvbnRyb2xsZXIub25LZXlFeGNoYW5nZShlKTsgXG5cdFx0Y29udHJvbGxlci5jaGVja0lzVmFsaWQoZmFsc2UpOyAgXG5cdH1cblx0ZnVuY3Rpb24gb25TYXZlKCl7XG5cblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRpZiAoY29udHJvbGxlci5zYXZlTm9kZUNoYW5nZXMoKSl7XG5cdFx0XHRjb25zdCBvbGROYW1lID0gb3JpZ05hbWU7XG5cdFx0XHRjb25zdCBuZXdOYW1lID0gZ2V0KGNvbnRyb2xsZXIubmFtZSk7IFxuXHRcdFx0ZGlzcGF0Y2goJ3NhdmUnLCB7IG9sZE5hbWU6IG9sZE5hbWUsIG5ld05hbWUgOiBuZXdOYW1lIH0pO1xuXHRcdFx0b3JpZ05hbWUgPSBuZXdOYW1lO1xuXHRcdH1cblx0XHQgXG5cdH1cblx0b25Nb3VudCgoKSA9PiB7IFxuXHRcdGNvbnRyb2xsZXIuc2V0Q29udHJvbGxlckRlcHMobm9kZSxzeXN0ZW0sKG1zZykgPT4ge30pO1xuXHRcdGNvbnRyb2xsZXIucmVjYWxjdWxhdGVDYWxjQW5kT3JpZ2lucygpXG5cdFx0Y29udHJvbGxlci5jaGVja0lzVmFsaWQoKTsgXG5cdFx0Y29udHJvbGxlck1hcHBlZE9yaWdpblx0PSBjb250cm9sbGVyLm1hcHBlZE9yaWdpbnM7XG5cdFx0Y29udHJvbGxlclJlc3VsdFZhbHVlXHQ9IGNvbnRyb2xsZXIucmVzdWx0VmFsdWU7XG5cdFx0Y29udHJvbGxlclJlc3VsdFN1Y2Nlc1x0PSBjb250cm9sbGVyLnJlc3VsdFN1Y2Nlc3M7XG5cdFx0Y29udHJvbGxlck5hbWVcdFx0XHQ9IGNvbnRyb2xsZXIubmFtZTtcblx0XHRjb250cm9sbGVyQ2FsY1x0XHRcdD0gY29udHJvbGxlci5jYWxjO1xuXHRcdGNvbnRyb2xsZXJJc1ZhbGlkXHRcdD0gY29udHJvbGxlci5pc1ZhbGlkO1xuXHRcdG9yaWdOYW1lID0gZ2V0KGNvbnRyb2xsZXIubmFtZSk7XG5cdH0pXG5cbjwvc2NyaXB0PlxuXG48ZGl2ID5cblx0PGRpdj5cblx0XHQ8U3RhdGljTWVzc2FnZUhhbmRsZXIgXG5cdFx0XHRiaW5kOnRoaXM9eyBtZXNzYWdlSGFuZGxlciB9XG5cdFx0Lz5cblx0PC9kaXY+XG5cdDxkaXY+XG5cdFx0PHA+XG5cdFx0XHRFZGl0aW5nIG5vZGUuXG5cdFx0XHRIZXJlIHlvdSBjYW4gZWRpdCBzZXR0aW5ncyBmb3IgdGhpcyBzcGVjaWZpYyBub2RlLiB0aGlzIGVkaXQgaXMgdW5pcXVlIHRvIHRoaXMgc3BlY2lmaWMgaXRlbS5cblx0XHQ8L3A+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPVwiSXRlbURlc2lnbmVyRGF0YUNvbHVtbnMzXCIgPlxuXG5cdFx0PGRpdj5Ob2RlIE5hbWU8L2Rpdj5cblx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cIkl0ZW1EZXNpZ25lcklucHV0XCIgb246aW5wdXQ9eyAoIGUgKSA9PiB7IG9uTmFtZUlucHV0KGUpIH0gfSBjb250ZW50ZWRpdGFibGUgYmluZDp2YWx1ZT17ICRjb250cm9sbGVyTmFtZSB9Lz5cbiBcblx0XHQ8ZGl2Pk5vZGUgTG9jYXRpb248L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiSXRlbURlc2lnbmVySW5wdXRcIiA+eyAobm9kZT8ucGFyZW50Py5wYXJlbnQ/Lm5hbWUgPz8gJ3Vua25vd24gY29sbGVjdGlvbicpICsgJy4nICsoIG5vZGU/LnBhcmVudD8ubmFtZSA/PyAndW5rbm93biBjb2xsZWN0aW9uJykgKyAnLicgKyAkY29udHJvbGxlck5hbWUgfTwvZGl2PlxuIFxuXHRcdDxkaXY+Q2FsYzwvZGl2PlxuXHRcdDx0ZXh0YXJlYSBjbGFzcz1cImNhbGNJbnB1dFwiIHZhbHVlPXsgJGNvbnRyb2xsZXJDYWxjIH0gXG5cdFx0XHRvbjppbnB1dD17IG9uQ2FsY0lucHV0IH1cblx0XHRcdHBsYWNlaG9sZGVyPVwiaW5zZXJ0IGNhbGNTdGF0ZW1lbnQgaGVyZVwiXG5cdFx0Lz5cblxuXHRcdDxkaXYgY2xhc3M9XCJkZXJpdmVkQ2FsY1N0YXRlbWVudFJlc3VsdFwiIGRhdGEtc3VjY2VzPXsgJGNvbnRyb2xsZXJSZXN1bHRTdWNjZXMgfSA+eyAkY29udHJvbGxlclJlc3VsdFZhbHVlIH08L2Rpdj5cblx0PC9kaXY+XG5cdDxicj5cblx0PGRpdj5cblx0XHR7I2lmIG5vZGUgJiYgc3lzdGVtIH1cblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJkZXJpdmVkT3JpZ2luUm93c0NvbnRhaW5lclwiID5cblx0XHRcdFx0XHR7I2lmICRjb250cm9sbGVyTWFwcGVkT3JpZ2luIH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0eyNlYWNoICRjb250cm9sbGVyTWFwcGVkT3JpZ2luIGFzIG9yaWdpbiAob3JpZ2luLmtleSwgb3JpZ2luLnNlZ21lbnRzKSB9XG5cdFx0XHRcdFx0XHRcdDxkaXYgYW5pbWF0ZTpmbGlwIHRyYW5zaXRpb246c2xpZGV8bG9jYWwgY2xhc3M9XCJkZXJpdmVkT3JpZ2luUm93Q29udGFpbmVyXCI+IFxuXHRcdFx0XHRcdFx0XHRcdDxPcmlnaW5Sb3dcblx0XHRcdFx0XHRcdFx0XHRcdGJpbmQ6cm93RGF0YSBcdCA9IHsgb3JpZ2luIH1cblx0XHRcdFx0XHRcdFx0XHRcdGF2YWlsYWJsZVN5bWJvbHMgPSB7IGF2YWlsYWJsZVN5bWJvbHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0c3lzdGVtIFx0XHRcdCA9IHsgc3lzdGVtLnN5cyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250ZXh0ID0ge2NvbnRleHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbjpjaGFuZ2VcdD0ge3JlY2FsY31cblx0XHRcdFx0XHRcdFx0XHRcdG9uOm9uRGVsZXRlIFx0XHQ9IHsgb25EZWxldGVDbGlja2VkIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uOm9uU3ltYm9sU2VsZWN0ZWQgPSB7IG9uS2V5RXhjaGFuZ2UgfVxuXHRcdFx0XHRcdFx0XHRcdFx0b246Zm91bmRUYXJnZXROb2RlID0geyAoZSkgPT57IGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKSB9fVxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PiBcblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvZGl2PiBcblx0PGJyPlxuXHQ8ZGl2IGNsYXNzPVwiSXRlbURlc2lnbmVyQnV0dG9uUm93XCI+XG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17IG9uU2F2ZSB9ICA+c2F2ZSBjaGFuZ2VzPC9idXR0b24+IFxuXHQ8L2Rpdj5cblx0PGJyPjxicj5cbjwvZGl2PlxuICIsIi8vaW1wb3J0IHsgR3JvYkpEZXJpdmVkTm9kZSwgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZywgdHlwZSAgR3JvYkpOb2RlVHlwZSB9IFxuaW1wb3J0IHsgVUlTeXN0ZW0gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9ncmFwaERlc2lnbmVyL1VJQ29tcG9zaXRpb24vVUlTeXN0ZW0nO1xuaW1wb3J0IHsgR3JvYkpEZXJpdmVkTm9kZSwgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZywgdHlwZSAgR3JvYkpOb2RlVHlwZSB9ICBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9ncmFwaERlc2lnbmVyJztcbmltcG9ydCB7IHdyaXRhYmxlLCB0eXBlIFdyaXRhYmxlLCBnZXQgfSBmcm9tICdzdmVsdGUvc3RvcmUnOyAgXG4gXG50eXBlIFN0YXRpY01lc3NhZ2VIYW5kbGVyID0gYW55XG5leHBvcnQgdHlwZSBvcmlnaW5Sb3dEYXRhID0ge2tleTogc3RyaW5nLCBzZWdtZW50czooc3RyaW5nfG51bGwpW10gLCBhY3RpdmUgOmJvb2xlYW4gLCB0ZXN0VmFsdWUgOm51bWJlciwgaW5DYWxjOmJvb2xlYW4sIHRhcmdldDogR3JvYkpOb2RlVHlwZSAgfCBudWxsICwgaXNTZWxlY3RBbGxUYXJnZXQ6Ym9vbGVhbiB9O1xuZXhwb3J0IGNvbnN0IHNlbEFsbEluQ29sbGVjdGlvblN0cmluZyA9ICctIC0gU2VsZWN0IGFsbCAtIC0nO1xuZXhwb3J0IGNsYXNzIERlcml2ZWRDb2xsZWN0aW9uQ29udHJvbGxlciB7XG5cdCBcblx0cHVibGljIHN5c3RlbTpVSVN5c3RlbSB8IG51bGxcdD0gbnVsbCA7XG5cdHB1YmxpYyBtZXNzYWdlSGFuZGxlcjogU3RhdGljTWVzc2FnZUhhbmRsZXIgfCBudWxsO1xuXG5cdHB1YmxpYyBuYW1lIFx0XHQ6IFdyaXRhYmxlPHN0cmluZz5cdFx0XHQ9IHdyaXRhYmxlKCcnKTsgXG5cdHB1YmxpYyBuYW1lQ2FsY1x0XHQ6IFdyaXRhYmxlPHN0cmluZz5cdFx0XHQ9IHdyaXRhYmxlKCcnKTsgXG5cdHB1YmxpYyB0ZW1wVmFsdWVcdDogV3JpdGFibGU8bnVtYmVyPlx0XHRcdD0gd3JpdGFibGUoMSk7IFxuXHRwdWJsaWMgY2FsY1x0XHRcdDogV3JpdGFibGU8c3RyaW5nPlx0XHRcdD0gd3JpdGFibGUoJycpOyBcblx0cHVibGljIHJlc3VsdFZhbHVlXHQ6IFdyaXRhYmxlPG51bWJlcj5cdFx0XHQ9IHdyaXRhYmxlKDApOyBcblx0cHVibGljIHJlc3VsdFN1Y2Nlc3M6IFdyaXRhYmxlPGJvb2xlYW4+XHRcdFx0PSB3cml0YWJsZSh0cnVlKTsgXG5cdHB1YmxpYyByZXN1bHROYW1lVmFsdWVcdDogV3JpdGFibGU8c3RyaW5nPlx0XHQ9IHdyaXRhYmxlKCcnKTsgXG5cdHB1YmxpYyByZXN1bHROYW1lU3VjY2VzczogV3JpdGFibGU8Ym9vbGVhbj5cdFx0PSB3cml0YWJsZSh0cnVlKTsgXG5cdHB1YmxpYyBpc1ZhbGlkXHRcdDogV3JpdGFibGU8Ym9vbGVhbj5cdFx0XHQ9IHdyaXRhYmxlKHRydWUpOyBcblx0cHVibGljIG1hcHBlZE9yaWdpbnM6IFdyaXRhYmxlPG9yaWdpblJvd0RhdGFbXT4gPSB3cml0YWJsZShbXSk7XG5cblx0cHVibGljIGdlbmVyYXRpdmVOYW1lTGlzdERhdGEgOiBXcml0YWJsZTxzdHJpbmdbXT5cdD0gd3JpdGFibGUoW10pOyBcblxuXHRwdWJsaWMgc2V0Q29udHJvbGxlckRlcHMoIHN5c3RlbSwgKXsgXG5cdFx0dGhpcy5zeXN0ZW0gPSBzeXN0ZW07XG5cblx0XHR0aGlzLm5hbWUgXHRcdFx0LnNldCggJycpXG5cdFx0dGhpcy5uYW1lQ2FsY1x0XHQuc2V0KCAnJylcblx0XHR0aGlzLmNhbGMgXHRcdFx0LnNldCggJycpIFxuXHRcdHRoaXMudGVtcFZhbHVlIFx0XHQuc2V0KDApXG5cdFx0dGhpcy5yZXN1bHRTdWNjZXNzIFx0LnNldCh0cnVlKVxuXHRcdHRoaXMucmVzdWx0VmFsdWUgXHQuc2V0KDApXG5cdFx0dGhpcy5yZXN1bHROYW1lU3VjY2VzcyBcdC5zZXQodHJ1ZSlcblx0XHR0aGlzLnJlc3VsdE5hbWVWYWx1ZSBcdC5zZXQoJycpIFxuXHRcdHRoaXMuaXNWYWxpZCBcdFx0LnNldCh0cnVlKVxuXHRcdCBcblx0XHR0aGlzLm1hcHBlZE9yaWdpbnMuc2V0KCBbXSk7XG5cdFx0ICBcblx0fVxuXHQgIFxuXHRwcml2YXRlIHZhbGlkYXRlTmFtZSggbmFtZSAsIG1lc3NhZ2VIYW5kbGVyOiBTdGF0aWNNZXNzYWdlSGFuZGxlciB8IG51bGwgPSBudWxsICwgb3V0cHV0OmJvb2xlYW4gKXtcblx0XHRsZXQgb3V0ID0gKGtleSxtc2csZXJyb3IpID0+IHsgaWYob3V0cHV0KXsgbWVzc2FnZUhhbmRsZXI/LmFkZE1lc3NhZ2VNYW51YWwoa2V5LG1zZyxlcnJvcikgfX1cblxuXHRcdGxldCBpc1ZhbGlkID0gdHJ1ZSA7IFxuXHRcdGNvbnNvbGUubG9nKG5hbWUpO1xuXG5cdFx0Ly8gY2hlY2sgdGhlIG5hbWVcblx0XHRpZiAobmFtZT09ICcnKXtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdG91dCgnbmFtZScsJ1RoZSBuYW1lIGNhbm5vdCBiZSBlbXB0eScsICdlcnJvcicpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSl7XG5cdFx0XHRpc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRvdXQoJ25hbWUnLCdUaGUgbmFtZSBjYW5ub3QgY29udGFpbiBcIi5cIicsICdlcnJvcicpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0aGlzLnN5c3RlbT8uaGFzQ29sbGVjdGlvbignZGVyaXZlZCcsbmFtZSApICB8fCB0aGlzLnN5c3RlbT8uaGFzQ29sbGVjdGlvbignZml4ZWQnLG5hbWUgKSAgKXtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdG91dCgnbmFtZScsJ1RoZSBDb2xsZWN0aW9uIG5hbWUgaXMgYWxyZWFkeSBpbiB1c2UgJywgJ2Vycm9yJylcblx0XHR9XG5cdFx0ZWxzZXtcblx0XHRcdG1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVFcnJvcignbmFtZScpO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNWYWxpZDtcblx0fSBcblx0cHJpdmF0ZSB2YWxpZGF0ZUl0ZW1OYW1lKCBuYW1lQ2FsYyAsIGNhbGMgLCBvcmlnaW5EYXRhIDogb3JpZ2luUm93RGF0YVtdICwgIG1lc3NhZ2VIYW5kbGVyOiBTdGF0aWNNZXNzYWdlSGFuZGxlciB8IG51bGwgPSBudWxsICwgb3V0cHV0OmJvb2xlYW4gKXtcblx0IFxuXHRcdGxldCBvdXQgPSAoa2V5LG1zZyxlcnJvcikgPT4geyBpZihvdXRwdXQpeyBtZXNzYWdlSGFuZGxlcj8uYWRkTWVzc2FnZU1hbnVhbChrZXksbXNnLGVycm9yKSB9fVxuXG5cdFx0XG5cdFx0bGV0IHN5bWJvbHNDYWxjID0gR3JvYkpEZXJpdmVkTm9kZS5zdGF0aWNQYXJzZUNhbGN1bGF0aW9uVG9PcmlnaW5zKCBjYWxjIFx0KTsgXG5cdFx0bGV0IHN5bWJvbHNOYW1lID0gR3JvYkpEZXJpdmVkTm9kZS5zdGF0aWNQYXJzZUNhbGN1bGF0aW9uVG9PcmlnaW5zKCBuYW1lQ2FsYyApIFxuXHRcdHN5bWJvbHNOYW1lID0gc3ltYm9sc05hbWUuZmlsdGVyKCBwID0+IHN5bWJvbHNDYWxjLmluY2x1ZGVzKHApICk7XG5cblx0XHRsZXQgc3ltYm9sc01pc3NpbmcgPSBzeW1ib2xzQ2FsYy5maWx0ZXIoIHAgPT4gIW5hbWVDYWxjLmluY2x1ZGVzKHApKVxuXHRcdGxldCBpc1ZhbGlkID0gdHJ1ZTtcblxuXHRcdGlmIChzeW1ib2xzTWlzc2luZy5sZW5ndGggIT0gMCl7XG5cdFx0XHRzeW1ib2xzTWlzc2luZy5mb3JFYWNoKHMgPT4ge1xuXG5cdFx0XHRcdGxldCBpc0FsbFNldHRpbmcgPSBvcmlnaW5EYXRhLmZpbmRJbmRleCggcCA9PiBwLmlzU2VsZWN0QWxsVGFyZ2V0ICYmIHAua2V5ID09IHMgKSAhPSAtMTtcblx0XHRcdFx0aWYgKGlzQWxsU2V0dGluZyl7XG5cdFx0XHRcdFx0b3V0KCdOb1N5bWJvbE5hbWUnICsgcywgcyArIFwiIHdhcyBtaXNzaW5nIGZyb20gbmFtZSBjYWxjdWxhdGlvbiBcXG5BbGwgU2VsZWN0IEFsbCBTZXR0aW5ncyBtdXN0IGJlIGluIHRoZSBuYW1lIFwiLCdlcnJvcicpIFxuXHRcdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0XG5cdFx0bGV0IG5hbWVSRVMgPSBuYW1lQ2FsYztcblx0XHRzeW1ib2xzTmFtZS5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0bmFtZVJFUyA9IG5hbWVSRVMucmVwbGFjZSggcyAsICdbJytzKyddJyk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlc3VsdE5hbWVTdWNjZXNzLnNldChpc1ZhbGlkKTtcblx0XHR0aGlzLnJlc3VsdE5hbWVWYWx1ZS5zZXQobmFtZVJFUyk7XG5cdFx0IFxuXHRcdHJldHVybiBpc1ZhbGlkO1xuXHR9IFxuXHRwcml2YXRlIHZhbGlkYXRlT3JpZ2lucyggIG1hcHBlZE9yaWdpbnM6b3JpZ2luUm93RGF0YVtdLCBjYWxjOnN0cmluZyAsICBzeXN0ZW06VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZyAsIG1lc3NhZ2VIYW5kbGVyOiBTdGF0aWNNZXNzYWdlSGFuZGxlciB8IG51bGwgPSBudWxsICwgb3V0cHV0OmJvb2xlYW4gICAgKXtcblx0XHRsZXQgb3V0ID0gKGtleSxtc2csZXJyb3IpID0+IHsgaWYob3V0cHV0KXsgbWVzc2FnZUhhbmRsZXI/LmFkZE1lc3NhZ2VNYW51YWwoa2V5LG1zZyxlcnJvcikgfX1cblxuXHRcdC8vIHZhbGlkYXRlIHRoYXQgYWxsIGluQ2FsYyBhcmUgZmluaXNoZWRcblx0XHRsZXQgaXNWYWxpZCA9IHRydWUgOyAgXG5cdFx0bWFwcGVkT3JpZ2lucy5mb3JFYWNoKCBvYmogPT4ge1xuXHRcdFx0aWYgKG9iai5pbkNhbGMgJiYgIShvYmoudGFyZ2V0KSAmJiAhb2JqLmlzU2VsZWN0QWxsVGFyZ2V0ICl7XG5cdFx0XHRcdG91dChvYmoua2V5ICsgXCIxXCIsIGBDYW5ub3Qgc2F2ZSB1bnRpbCBhbGwgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIGNhbGMgaXMgZGVmaW5lZCBcXG4gJHtvYmoua2V5fSBIYWQgbm8gdGFyZ2V0YCAsICdlcnJvcicpO1xuXHRcdFx0XHRpc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0bWVzc2FnZUhhbmRsZXI/LnJlbW92ZUVycm9yKG9iai5rZXkgKyBcIjFcIik7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRpZiAoIWlzVmFsaWQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQgIFxuXHRcdC8vIFNldCBDYWxjIGFuZCBkZXBlbmRlbmNpZXMgXG5cdFx0bGV0IE5NYXAgPSBtYXBwZWRPcmlnaW5zLmZpbHRlciggcCA9PiBjYWxjLmluY2x1ZGVzKHAua2V5KSApOyBcblx0XHROTWFwLmZvckVhY2goIG8gPT4ge1x0XG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGlmIGl0IGhhcyBzZWdtZW50c1xuXHRcdFx0aWYgKCFvLnNlZ21lbnRzKXsgXG5cdFx0XHRcdG91dCggby5rZXksIGBDb250ZW50cyBvZiAke28ua2V5fSdzIHNlZ21lbnRzIHdhcyBOdWxsISdgLCAnZXJyb3InKTtcblx0XHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIHRoYXQgaXQgY2FuIGNyZWF0ZSB0aGUgcHJvcHBlciB0YXJnZXQuIEFLQSB0YXJnZXQgZXhpc3RzIGluIHRoZSBzeXN0ZW0uIG5vdCBqdXN0IGVtcHR5IG9iai1cblx0XHRcdGlmKCAhby5pc1NlbGVjdEFsbFRhcmdldCApe1xuXHRcdFx0XHRsZXQgZGVwID0gc3lzdGVtLmdldE5vZGUoby5zZWdtZW50c1swXSBhcyBhbnksby5zZWdtZW50c1sxXSBhcyBhbnkgLG8uc2VnbWVudHNbMl0gYXMgYW55KSA7XG5cdFx0XHRcdGlmICghZGVwICl7XG5cdFx0XHRcdFx0b3V0KCBvLmtleSwgYFRhcmdldCBvZiAke28ua2V5fSBsb2NhdGlvbiAke28uc2VnbWVudHNbMF0gKycuJysgby5zZWdtZW50c1sxXSArJy4nKyBvLnNlZ21lbnRzWzJdIH0gd2FzIGludmFsaWQhJ2AsICdlcnJvcicpO1xuXHRcdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcblx0XHRcblx0XHRcdG1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVFcnJvciggby5rZXkgKTtcblx0XHR9KTsgXG5cblx0XHRyZXR1cm4gaXNWYWxpZDtcblx0fVxuXHRwcml2YXRlIHZhbGlkYXRlQ2FsY3VsYXRpb24oIGNhbGM6c3RyaW5nICwgbWFwcGVkT3JpZ2luczpvcmlnaW5Sb3dEYXRhW10gLCBtZXNzYWdlSGFuZGxlcjogU3RhdGljTWVzc2FnZUhhbmRsZXIgfCBudWxsID0gbnVsbCAsIG91dHB1dCA6Ym9vbGVhbiAgKXtcblx0XHRsZXQgb3V0ID0gKGtleSxtc2csZXJyb3IpID0+IHsgaWYob3V0cHV0KXsgbWVzc2FnZUhhbmRsZXI/LmFkZE1lc3NhZ2VNYW51YWwoa2V5LG1zZyxlcnJvcikgfX1cblxuXHRcdGlmKGNhbGMudHJpbSgpID09ICcnKXtcblx0XHRcdG91dCggJ2NhbGMnICwgYENhbGN1bGF0aW9uIGNhbm5vdCBiZSBlbXB0eWAsICdlcnJvcicgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblxuXG5cdFx0aWYoY2FsYy50cmltKCkgPT0gJycpe1xuXHRcdFx0b3V0KCAnY2FsYycgLCBgQ2FsY3VsYXRpb24gY2Fubm90IGJlIGVtcHR5YCwgJ2Vycm9yJyApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXG5cblx0XHQvLyBmaXJzdCB0ZXN0IHRoZSBjYWxjdWxhdGlvbi5cblx0XHRsZXQgbyA9IHt9O1xuXHRcdGxldCBtYXBwZWRLZXlzIDogc3RyaW5nW10gPSBbXTtcblx0XHRtYXBwZWRPcmlnaW5zLmZvckVhY2goIHAgPT4geyBvW3Aua2V5XT0gcC50ZXN0VmFsdWUgOyBtYXBwZWRLZXlzLnB1c2gocC5rZXkpIH0gKTtcblx0XHRsZXQgY2FsY3JlcyA9IEdyb2JKRGVyaXZlZE5vZGUudGVzdENhbGN1bGF0ZSggY2FsYyAsIG8gKTtcblx0XHRcblx0XHRsZXQgc3VjY2VzPSBjYWxjcmVzLnN1Y2Nlc3M7XG5cdFx0bGV0IHZhbHVlID0gY2FsY3Jlcy52YWx1ZTtcblx0XHRcblxuXHRcdC8vIGlmIHRoZXJlIGlzIGFuIGNhbGMgZXJyb3Igc2hvd24gcmVtb3ZlIGl0LiAuIEFsc28gbWVzc2FnZWhhbmRsZXIgaGFzIHRvIGJlIGluaXRpYWxpemVkXG5cdFx0aWYgKCAhc3VjY2VzICl7IFxuXHRcdFx0b3V0KCAnY2FsYycgLCBgQ2FsY3VsYXRpb24gaXMgaW52YWxpZCwgbWVhbmluZyBpdCBjb3VsZCBub3QgcGFyc2VgLCAnZXJyb3InICk7XG5cdFx0fSBlbHNle1xuXHRcdFx0bWVzc2FnZUhhbmRsZXI/LnJlbW92ZUVycm9yKCdjYWxjJyk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLnJlc3VsdFZhbHVlIFx0LnNldCh2YWx1ZSk7XG5cdFx0dGhpcy5yZXN1bHRTdWNjZXNzIFx0LnNldChzdWNjZXMpO1xuXHRcdHJldHVybiBzdWNjZXMgYXMgYm9vbGVhbjtcblx0fVxuXHRwcml2YXRlIHZhbGlkYXRlQ2FsY3VsYXRpb25PcmlnaW5zKCBjYWxjOnN0cmluZyAsIG1hcHBlZE9yaWdpbnM6b3JpZ2luUm93RGF0YVtdLCAgbWVzc2FnZUhhbmRsZXI6IFN0YXRpY01lc3NhZ2VIYW5kbGVyIHwgbnVsbCA9IG51bGwgLCBvdXRwdXQgOmJvb2xlYW4gKXtcblx0XHRsZXQgb3V0ID0gKGtleSxtc2csZXJyb3IpID0+IHsgaWYob3V0cHV0KXsgbWVzc2FnZUhhbmRsZXI/LmFkZE1lc3NhZ2VNYW51YWwoa2V5LG1zZyxlcnJvcikgfX1cblxuXHRcdGxldCBzeW1ib2xzID0gR3JvYkpEZXJpdmVkTm9kZS5zdGF0aWNQYXJzZUNhbGN1bGF0aW9uVG9PcmlnaW5zKGNhbGMpO1xuXHRcdG1hcHBlZE9yaWdpbnMuZm9yRWFjaCggbyAgPT4geyAgXG5cdFx0XHRjb25zdCBpbmRleCA9IHN5bWJvbHMuaW5kZXhPZiggby5rZXkgKTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0c3ltYm9scy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fSBcblx0XHRcdG1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVFcnJvciggby5rZXkgKyAnbWlzc2luZycgKVxuXHRcdH0pO1xuXG5cdFx0bGV0IGlzVmFsaWQgPSB0cnVlO1xuXHRcdHN5bWJvbHMuZm9yRWFjaCggcyAgPT4ge1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0b3V0KCBzICsgJ21pc3NpbmcnICwgYHN5bWJvbCAke3N9IHdhcyBtaXNzaW5nIGZyb20gb3JpZ2lucyBgICwgJ2Vycm9yJyApXG5cdFx0fSk7IFxuXHRcdHJldHVybiBpc1ZhbGlkOyBcblx0fVxuXHQgXG5cdHByaXZhdGUgX2NoZWNrSXNWYWxpZCggIG91dHB1dCA9IHRydWUgICl7IFxuXHRcdGlmKCAhdGhpcy5zeXN0ZW0peyBcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRsZXQgaXNWYWxpZCA9IHRydWU7IFxuXG5cdFx0Ly8gQ2hlY2sgbmFtZSBpcyB2YWxpZCBcblx0XHRpc1ZhbGlkID0gaXNWYWxpZCAmJiB0aGlzLnZhbGlkYXRlTmFtZVx0XHQoIGdldCh0aGlzLm5hbWUpID8/ICcnICwgdGhpcy5tZXNzYWdlSGFuZGxlciAsIG91dHB1dCApO1xuXG5cdFx0Ly8gY2hlY2sgdGhhdCBub3RoaW5nIGlzIGluZGl2aWR1YWxseSB3cm9uZyB3aXRoIHRoZSBvcmlnaW5zLiBcblx0XHRpc1ZhbGlkID0gaXNWYWxpZCAmJiB0aGlzLnZhbGlkYXRlT3JpZ2luc1x0KCBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKSAsIGdldCh0aGlzLmNhbGMpICwgdGhpcy5zeXN0ZW0gLnN5cywgIHRoaXMubWVzc2FnZUhhbmRsZXIgLG91dHB1dCAgKTtcblxuXHRcdGlzVmFsaWQgPSBpc1ZhbGlkICYmIHRoaXMudmFsaWRhdGVDYWxjdWxhdGlvbk9yaWdpbnMoIGdldCh0aGlzLmNhbGMpICwgZ2V0KHRoaXMubWFwcGVkT3JpZ2lucykgLCB0aGlzLm1lc3NhZ2VIYW5kbGVyICwgb3V0cHV0ICk7XG5cblx0XHQvLyBDaGVjayB0aGF0IGFsbCBjYWxjIG9yaWdpbnMgYXJlIHByZXNlbnQuXG5cdFx0bGV0IGQgPSB0aGlzLnZhbGlkYXRlSXRlbU5hbWUoIGdldCh0aGlzLm5hbWVDYWxjKSwgZ2V0KHRoaXMuY2FsYykgICwgZ2V0KHRoaXMubWFwcGVkT3JpZ2lucykgICwgdGhpcy5tZXNzYWdlSGFuZGxlciAsb3V0cHV0ICk7XG5cdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgZDtcblxuXHRcdC8vIGNoZWNrIHRoYXQgY2FsY3VsYXRpb24gY2FuIGJlIGNhbGN1bGF0ZWQgXG5cdFx0aXNWYWxpZCA9IGlzVmFsaWQgJiYgdGhpcy52YWxpZGF0ZUNhbGN1bGF0aW9uKCBnZXQodGhpcy5jYWxjICksIGdldCh0aGlzLm1hcHBlZE9yaWdpbnMpICwgIHRoaXMubWVzc2FnZUhhbmRsZXIgLG91dHB1dCApO1xuXG5cdFx0cmV0dXJuIGlzVmFsaWQ7XG5cblx0fVxuXHRwdWJsaWMgY2hlY2tJc1ZhbGlkKCBvdXRwdXQgPSB0cnVlICl7ICBcblx0XHRcblx0XHR0aGlzLm1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVBbGxNZXNzYWdlcygpO1xuXHRcdFxuXHRcdGxldCB2YWxpZCA9IHRoaXMuX2NoZWNrSXNWYWxpZCggb3V0cHV0ICk7IFxuXHRcdHRoaXMuaXNWYWxpZC5zZXQoIHZhbGlkICk7IFxuXHRcdHJldHVybiB2YWxpZDtcblx0fSAgXG5cblx0cHVibGljIHNhdmVDb2xsZWN0aW9uKCApe1xuXHRcdCBcblx0XHRsZXQgc3VjY2VzcyA9IHRoaXMuY2hlY2tJc1ZhbGlkKCB0cnVlICk7XG5cdFx0aWYgKCFzdWNjZXNzKXtcblx0XHRcdHRoaXMubWVzc2FnZUhhbmRsZXI/LmFkZE1lc3NhZ2VNYW51YWwoJ3NhdmUnLCdXYXMgTm90IHZhbGlkLCBzbyBjb3VsZCBub3Qgc2F2ZScsICdlcnJvcicpO1xuXHRcdFx0cmV0dXJuIGZhbHNlIDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlYnVnZ2VyXG5cdFx0XHRcdC8vIHR5cGUgZGVjbGFyYXRpb25cblx0XHRcdFx0dHlwZSByZXNEYXRhUG9pbnQgPSB7bmFtZTpzdHJpbmcsIGRlcHM6UmVjb3JkPHN0cmluZyxHcm9iSk5vZGVUeXBlPiB9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCBTYXZlXG5cdFx0XHRcdGxldCBjb2xOYW1lID0gZ2V0KHRoaXMubmFtZSk7XG5cdFx0XHRcdHRoaXMuc3lzdGVtPy5hZGRDb2xsZWN0aW9uKCdkZXJpdmVkJyxjb2xOYW1lKTtcblx0XHRcdFxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBOb2RlcyBUbyBTYXZlIGFuZCBTYXZlIHRoZW0uXG5cdFx0XHRcdGxldCBub2Rlc1RvQ3JlYXRlIDogcmVzRGF0YVBvaW50W10gPSB0aGlzLmdlbmVyYXRlTmFtZVByZXZpZXcoKSA/PyBbXTtcblx0XHRcdFx0bm9kZXNUb0NyZWF0ZS5mb3JFYWNoKCBub2RlID0+IHtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0XHRcdHRoaXMuc3lzdGVtPy5hZGROb2RlKCdkZXJpdmVkJyxjb2xOYW1lLG5vZGUubmFtZSk7XG5cdFx0XHRcdFx0bGV0IGNyZWF0ZWROb2RlID0gdGhpcy5zeXN0ZW0/LnN5cz8uZ2V0Tm9kZSgnZGVyaXZlZCcsY29sTmFtZSxub2RlLm5hbWUpIGFzIEdyb2JKRGVyaXZlZE5vZGU7XG5cdFx0XHRcdFx0bGV0IGNhbGMgPSBnZXQodGhpcy5jYWxjKTtcblx0XHRcdFx0XHRjcmVhdGVkTm9kZT8uc2V0Q2FsYyhjYWxjKTtcblxuXHRcdFx0XHRcdC8vIEFkZCBEZXBlbmRlbmN5XG5cdFx0XHRcdFx0aWYgKGNyZWF0ZWROb2RlKSB7XG5cdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhub2RlLmRlcHMpLmZvckVhY2goIGtleSA9PiB7IFxuXHRcdFx0XHRcdFx0XHRsZXQgZGVwID0gbm9kZS5kZXBzW2tleV07XG5cdFx0XHRcdFx0XHRcdGNyZWF0ZWROb2RlLnNldE9yaWdpbihrZXksZGVwLDApXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnN5c3RlbT8uZ2V0R3JvdXAoJ2Rlcml2ZWQnKT8udXBkYXRlKCk7XG5cdFx0XHRcdHRoaXMuc3lzdGVtPy5nZXRDb2xsZWN0aW9uKCdkZXJpdmVkJyxjb2xOYW1lKT8udXBkYXRlKCk7XG5cblx0XHRcdH0gY2F0Y2ggKGUpeyBcblx0XHRcdFx0c3VjY2VzcyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVzZXIgaW5mb3JtYXRpb25cblx0XHRpZiAoc3VjY2Vzcyl7XG5cdFx0XHR0aGlzLm1lc3NhZ2VIYW5kbGVyPy5hZGRNZXNzYWdlTWFudWFsKCdzYXZlJywnU2F2ZWQgTm9kZScsICdnb29kJyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tZXNzYWdlSGFuZGxlcj8uYWRkTWVzc2FnZU1hbnVhbCgnc2F2ZScsJ0V4Y2VwdGlvbiB3aGlsZSB0cnlpbmcgdG8gc2F2ZSBOb2RlIGluIFVJJywgJ2Vycm9yJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSAgXG5cdH0gIFxuXG5cdHB1YmxpYyBvbktleUV4Y2hhbmdlKCBlICl7IFxuXG5cdFx0dGhpcy5tYXBwZWRPcmlnaW5zLnVwZGF0ZSggbWFwcGVkT3JpZ2lucyA9PiB7XG5cdFx0XHRjb25zdCBzMCA9IGUuZGV0YWlsLm9sZDtcblx0XHRcdGNvbnN0IHMxID0gZS5kZXRhaWwubmV3OyBcblx0XHRcdGxldCB0MCA6IG9yaWdpblJvd0RhdGEgfCB1bmRlZmluZWQgPSBtYXBwZWRPcmlnaW5zLmZpbmQoIHAgPT4gcC5rZXkgPT0gczAgKTtcblx0XHRcdGlmICghdDApXG5cdFx0XHRcdHJldHVybiBtYXBwZWRPcmlnaW5zO1xuXG5cdFx0XHRsZXQgdDEgOiBvcmlnaW5Sb3dEYXRhIHwgdW5kZWZpbmVkID0gbWFwcGVkT3JpZ2lucy5maW5kKCBwID0+IHAua2V5ID09IHMxICk7XG5cdFx0XHRpZiAoIXQxKVxuXHRcdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblxuXHRcdFx0Ly8gd2UgZXZhbCBpZiBzMCBpcyBpbiB0aGUgY2FsYy4gdGhlbiB3ZSBuZWVkIHRvIGV4Y2hhbmdlIHRoZW4gZGVsZXRlLiBcblx0XHRcdHQwLmtleSA9IHMxO1xuXHRcdFx0dDAuaW5DYWxjID0gZ2V0KHRoaXMuY2FsYykuaW5jbHVkZXMoczEpO1xuXHRcdFx0dDEua2V5ID0gczA7XG5cdFx0XHR0MS5pbkNhbGMgPSBnZXQodGhpcy5jYWxjKS5pbmNsdWRlcyhzMCk7XG5cdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblx0XHR9KVxuXHRcdHJldHVybiBcblx0fVxuXHRwdWJsaWMgb25LZXlEZWxldGUoIGUgKXsgXG5cdFx0dGhpcy5tYXBwZWRPcmlnaW5zLnVwZGF0ZSggbWFwcGVkT3JpZ2lucyA9PiB7XG5cdFx0XHRjb25zdCBrZXkgPSBlLmRldGFpbDtcblx0XHRcdGxldCBvbGQgOiBvcmlnaW5Sb3dEYXRhIHwgdW5kZWZpbmVkID0gbWFwcGVkT3JpZ2lucy5maW5kKCBwID0+IHAua2V5ID09IGtleSApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIW9sZClcblx0XHRcdFx0cmV0dXJuIG1hcHBlZE9yaWdpbnM7XG5cblx0XHRcdGlmICghb2xkLmFjdGl2ZSB8fCAhb2xkLmluQ2FsYyl7XG5cdFx0XHRcdG1hcHBlZE9yaWdpbnMuZmlsdGVyKCBwID0+IHAua2V5ICE9IG9sZC5rZXkgKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRvbGQuc2VnbWVudHMgPSBuZXcgQXJyYXkoMykuZmlsbChudWxsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPcmlnaW5zO1xuXHRcdH0pXG5cdH1cblx0cHVibGljIHJlY2FsY3VsYXRlQ2FsY0FuZE9yaWdpbnMoKXsgXG5cdFx0Ly8vIEhhbmRsZSBDYWxjdWxhdGlvblxuXHRcdGxldCBvID0ge307IFxuXHRcdGdldCh0aGlzLm1hcHBlZE9yaWdpbnMpLmZvckVhY2goIHAgPT4geyBvW3Aua2V5XT0gcC50ZXN0VmFsdWU7IH0gKTtcblx0XHRsZXQgY2FsYyA9IGdldCh0aGlzLmNhbGMpIDsgXG5cdFx0bGV0IHJlcyA9IEdyb2JKRGVyaXZlZE5vZGUudGVzdENhbGN1bGF0ZSggY2FsYyAsIG8gKTtcblxuXHRcdC8vIHNhdmUgYW5kIHByb2NjZXNzIHZhbHVlcyBcblx0XHR0aGlzLnJlc3VsdFZhbHVlXHQuc2V0KHJlcy52YWx1ZSk7XG5cdFx0dGhpcy5yZXN1bHRTdWNjZXNzXHQuc2V0KHJlcy5zdWNjZXNzKTtcblxuXHRcdC8vLyBIYW5kbGUgQWRkIE9yaWdpbnMuIFxuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgc3ltYm9sc1xuXHRcdGxldCBzeW1ib2xzID0gR3JvYkpEZXJpdmVkTm9kZS5zdGF0aWNQYXJzZUNhbGN1bGF0aW9uVG9PcmlnaW5zKCBjYWxjICk7XG5cblx0XHQvL3JlbW92ZSBrZXlzIHRoYXQgYWxyZWFkeSBleGlzdHMgZnJvbSB0aGUgYXJyYXkuIGFuZCBsZWF2ZSBhIHB1cmUgdG9BZGQgbGlzdC5cblx0XHR0aGlzLm1hcHBlZE9yaWdpbnMudXBkYXRlKCBtYXBwZWRPcmlnaW5zID0+e1xuXG5cdFx0XHRtYXBwZWRPcmlnaW5zLmZvckVhY2goIGQgPT4ge1xuXHRcdFx0XHRsZXQgaW5DYWxjID0gc3ltYm9scy5pbmNsdWRlcyhkLmtleSk7XG5cdFx0XHRcdGlmICggaW5DYWxjICl7XG5cdFx0XHRcdFx0c3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKCBwID0+IHAgIT0gZC5rZXkpO1xuXHRcdFx0XHRcdGQuaW5DYWxjID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBpbiBjYXNlIGFuIGl0ZW0gaXMgbm8gbG9uZ2VyIGluIHRoZSBjYWxjLCBtYXJrIGl0IGFzIHN1Y2guIFxuXHRcdFx0XHRcdGQuaW5DYWxjID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRcblxuXHRcdFx0Ly8gZm9yIGVhY2ggcmVtYWluaW5nLCBhZGQgaXQuIFxuXHRcdFx0c3ltYm9scy5mb3JFYWNoKCBzID0+IHsgXG5cdFx0XHRcdG1hcHBlZE9yaWdpbnMucHVzaCh7a2V5OnMgLCBzZWdtZW50czpuZXcgQXJyYXkoMykuZmlsbChudWxsKSAsIGFjdGl2ZTpmYWxzZSAsIHRlc3RWYWx1ZTogMSwgaW5DYWxjOnRydWUsIHRhcmdldCA6IG51bGwgLCBpc1NlbGVjdEFsbFRhcmdldCA6IGZhbHNlIH0pXG5cdFx0XHR9KSAgXG5cdFx0XHRyZXR1cm4gbWFwcGVkT3JpZ2lucztcblx0XHR9KVxuXHR9XG5cblx0cHVibGljIGdlbmVyYXRlTmFtZVByZXZpZXcoKXtcblx0XHQgICBcblx0XHRpZiAoICF0aGlzLnN5c3RlbSApe1xuXHRcdFx0dGhpcy5nZW5lcmF0aXZlTmFtZUxpc3REYXRhLnNldChbXSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblxuXHRcdFx0bGV0IG9yaWdpbnMgPSBnZXQodGhpcy5tYXBwZWRPcmlnaW5zKTtcblx0XHRcdGxldCBuYW1lQ2FsYyA9IGdldCh0aGlzLm5hbWVDYWxjKTtcdFx0XHRcblxuXHRcdFx0dHlwZSByZXNEYXRhUG9pbnQgPSB7bmFtZTpzdHJpbmcsIGRlcHM6IFJlY29yZDxzdHJpbmcsR3JvYkpOb2RlVHlwZT4gIH1cblx0XHRcdHR5cGUgcmVzdWx0ID0geyBkYXRhIDogcmVzRGF0YVBvaW50W10gfVxuXHRcdFx0bGV0IHJlcyA6IHJlc3VsdCA9IHsgZGF0YSA6IFtdIH07XG5cdFx0XHRmdW5jdGlvbiByZWN1cnNpdmVOYW1lRmluZGVyKCBzZWxmLCBuYW1lQ2FsYyA6IHN0cmluZywgaW5kZXggOiBudW1iZXIgPSAwICxhcnIgOiBvcmlnaW5Sb3dEYXRhW10gLCByZXMgOiByZXN1bHQgLCBkZXBzIDogUmVjb3JkPHN0cmluZyxHcm9iSk5vZGVUeXBlPiApe1xuXHRcdFx0XHQgXG5cdFx0XHRcdC8vIGdlIHZhbHVlcywgYW5kIGNvcHkgbmFtZUNhbGMgYnkgdmFsdWUgKG5vdCByZWZlcmVuY2UpLiBcblx0XHRcdFx0bGV0IGN1cnJlbnROYW1lID0gbmFtZUNhbGM7XG5cdFx0XHRcdGxldCBub2RlczpHcm9iSk5vZGVUeXBlW107XG5cdFx0XHRcdGxldCBjdXJyID0gYXJyW2luZGV4XTtcblxuXHRcdFx0XHQvLyBpZiB3ZSBhcmUgZG9uZSwgcmV0dXJuIHJlc3VsdFxuXHRcdFx0XHRpZiAoIWN1cnIpeyBcblx0XHRcdFx0XHRpZiAoIHJlcy5kYXRhLmZpbmRJbmRleCggcCA9PiBwLm5hbWUgPT0gY3VycmVudE5hbWUgKSAhPSAtMSApeyBcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRG91YmxlIE5hbWUsIGluIG5hbWVzIGdlbmVyYXRlZCBEZXRlY3RlZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXMuZGF0YS5wdXNoKCB7bmFtZTpjdXJyZW50TmFtZSwgZGVwczpkZXBzIH0gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgU2VsZWN0IEFsbCBTZWdtZW50IHRoZW4gZ2V0XG5cdFx0XHRcdGlmIChjdXJyLnNlZ21lbnRzWzJdID09IHNlbEFsbEluQ29sbGVjdGlvblN0cmluZyl7XG5cdFx0XHRcdFx0Y29uc3Qgc3lzID0gKHNlbGYuc3lzdGVtLnN5cyBhcyBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nKTsgIFxuXHRcdFx0XHRcdGxldCBjb2xsZWN0aW9uID0gc3lzLmdldENvbGxlY3Rpb24oKGN1cnIuc2VnbWVudHNbMF0gYXMgYW55KSwoY3Vyci5zZWdtZW50c1sxXSBhcyBhbnkpKTtcblx0XHRcdFx0XHRsZXQgbiA6IEdyb2JKTm9kZVR5cGVbXSA9IGNvbGxlY3Rpb24/LmdldE5vZGVzKCkgPz8gW107XG5cdFx0XHRcdFx0bm9kZXMgPSBuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZWxzZSBqdXN0IGFkZCB0aGlzIG5hbWUgdG8gdGhlIGFyclxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBzeXMgPSAoc2VsZi5zeXN0ZW0uc3lzIGFzIFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcpOyAgXG5cdFx0XHRcdFx0bGV0IGNvbGxlY3Rpb24gPSBzeXMuZ2V0Q29sbGVjdGlvbigoY3Vyci5zZWdtZW50c1swXSBhcyBhbnkpLChjdXJyLnNlZ21lbnRzWzFdIGFzIGFueSkpO1xuXHRcdFx0XHRcdGxldCBuIDogR3JvYkpOb2RlVHlwZSB8IHVuZGVmaW5lZCA9IGNvbGxlY3Rpb24/LmdldE5vZGUoY3Vyci5zZWdtZW50c1syXSk7XG5cdFx0XHRcdFx0bm9kZXMgPSBuID8gWyBuIF0gOiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8vIHJlcGxhY2UgaW5zdHJpbmcgUGFydC4gXG5cdFx0XHRcdG5vZGVzLmZvckVhY2goIG5vZGUgID0+IHtcblx0XHRcdFx0XHRsZXQgY3Vyck5hbWVDYWxjID0gY3VycmVudE5hbWUucmVwbGFjZSggY3Vyci5rZXkgLCBub2RlLmdldE5hbWUoKSApOyBcblx0XHRcdFx0XHRsZXQgX2RlcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZXBzICk7XG5cdFx0XHRcdFx0X2RlcHNbIGN1cnIua2V5IF0gPSBub2RlO1xuXHRcdFx0XHRcdHJlY3Vyc2l2ZU5hbWVGaW5kZXIoc2VsZixjdXJyTmFtZUNhbGMsIGluZGV4ICsgMSAsYXJyLHJlcywgX2RlcHMpXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdH1cblxuXHRcdFx0cmVjdXJzaXZlTmFtZUZpbmRlciggdGhpcyAsIG5hbWVDYWxjICwwLCBvcmlnaW5zLCByZXMgLCB7fSApOyAgXG5cdFx0XHR0aGlzLmdlbmVyYXRpdmVOYW1lTGlzdERhdGEuc2V0KCByZXMuZGF0YS5tYXAoIHAgPT4gcC5uYW1lICkgKTtcdFxuXHRcdFx0cmV0dXJuIHJlcy5kYXRhO1xuXHRcdH1cblx0XHRjYXRjaChlKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxufSAgXG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGltcG9ydCB7IHNsaWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7IFxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcblxuXHRleHBvcnQgbGV0IHRpdGxlIDogc3RyaW5nIDtcblx0bGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cdGxldCB0b29nbGVkID0gZmFsc2U7XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHRvb2dsZSggZm9yY2VTdGF0ZSA6IGJvb2xlYW4gfCBudWxsID0gbnVsbCApe1xuXHRcdGxldCBvcmlnU3RhdGUgPSB0b29nbGVkO1xuXHRcdGlmICggZm9yY2VTdGF0ZSA9PSBudWxsICl7XG5cdFx0XHR0b29nbGVkID0gIXRvb2dsZWQ7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dG9vZ2xlZCA9IGZvcmNlU3RhdGU7XG5cdFx0fVxuXG5cdFx0Ly8gYXZvaWQgdXBkYXRpbmcgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZFxuXHRcdGlmKHRvb2dsZWQgPT0gb3JpZ1N0YXRlKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYodG9vZ2xlZCl7XG5cdFx0XHRkaXNwYXRjaCgnY2xvc2UnKVxuXHRcdH1lbHNle1xuXHRcdFx0ZGlzcGF0Y2goJ29wZW4nKVxuXHRcdH1cblx0XG5cdH1cblxuXHRcblxuPC9zY3JpcHQ+XG48ZGl2PlxuXHQ8ZGl2IGNsYXNzPVwidG9vZ2xlU2VjdGlvbkhlYWRlclwiIG9uOmNsaWNrPXsgKCkgPT4gdG9vZ2xlKCkgfSBkYXRhLXRvb2dsZWQ9e3Rvb2dsZWR9ID5cblx0XHQ8cFx0XHRcdHN0eWxlPVwiZ3JpZC1hcmVhOm5hbWU7XCIgPnt0aXRsZX08L3A+XG5cdFx0PHNlY3Rpb25cdHN0eWxlPVwiZ3JpZC1hcmVhOmljb247XCIgY2xhc3M9XCJ0b29nbGVTZWN0aW9uSWNvblwiID4mbmJzcDs8L3NlY3Rpb24+XG5cdFx0PGRpdlx0XHRzdHlsZT1cImdyaWQtYXJlYTpsaW5lO1wiIGNsYXNzPVwidG9vZ2xlU2VjdGluTGluZVwiID48L2Rpdj5cblx0PC9kaXY+XG5cdDxkaXYgY2xhc3M9XCJ0b29nbGVTZWN0aW9uQm9keVwiID4gXG5cdFx0eyNpZiB0b29nbGVkfVxuXHRcdFx0PGRpdiB0cmFuc2l0aW9uOnNsaWRlID5cblx0XHRcdFx0PHNsb3QgLz5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9IFxuXHQ8L2Rpdj5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+ICBcblx0XG4gICAgaW1wb3J0IHsgd3JpdGFibGUsIHR5cGUgV3JpdGFibGUsIGdldCB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7ICBcbiAgICBpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcbiAgICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnOyAgIFxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjsgXG5cbiAgICBpbXBvcnQgeyBEZXJpdmVkQ29sbGVjdGlvbkNvbnRyb2xsZXIsIG9yaWdpblJvd0RhdGEsIHNlbEFsbEluQ29sbGVjdGlvblN0cmluZyB9IGZyb20gJy4vRGVyaXZlZENvbGxlY3Rpb25EZXNpZ25lckNvbnRyb2xsZXInO1xuXHRpbXBvcnQgU3RhdGljTWVzc2FnZUhhbmRsZXJcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL0NvbXBvbmVudHMvTWVzc2FnZXMvU3RhdGljTWVzc2FnZUhhbmRsZXIuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBMYXlvdXQwMUNvbnRleHQgfVx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vY29udGV4dCc7XG4gICAgaW1wb3J0IHsgVUlTeXN0ZW0gfVx0XHRcdFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSVN5c3RlbSc7XG5cdGltcG9ydCBPcmlnaW5Sb3cgXHRcdFx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vVmlld3MvT3JpZ2luUm93L09yaWdpblJvdy5zdmVsdGUnO1xuXHRpbXBvcnQgeyBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nIH0gXHRmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyJztcbiAgICBpbXBvcnQgVG9vZ2xlU2VjdGlvbiBcdFx0XHRcdFx0ZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy90b29nbGVTZWN0aW9uL3Rvb2dsZVNlY3Rpb24uc3ZlbHRlJztcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpOyAgXG5cblx0ZXhwb3J0IGxldCBzeXN0ZW0gOiBVSVN5c3RlbTsgXG5cdGV4cG9ydCBsZXQgc2Vjb25kU2xpZGVJblJlYWR5ID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgZ29vZFRpdGxlID0gXCJObyBFcnJvclwiO1xuXHRleHBvcnQgbGV0IGJhZFRpdGxlICA9IFwiRXJyb3JcIlxuXHRleHBvcnQgbGV0IGNvbnRleHRcdDogTGF5b3V0MDFDb250ZXh0OyBcblx0ZXhwb3J0IGxldCBtZXNzYWdlSGFuZGxlcjogU3RhdGljTWVzc2FnZUhhbmRsZXI7IFxuXG5cdGxldCBjb250cm9sbGVyIDogRGVyaXZlZENvbGxlY3Rpb25Db250cm9sbGVyID0gbmV3IERlcml2ZWRDb2xsZWN0aW9uQ29udHJvbGxlcigpOyBcblx0JDogY29udHJvbGxlci5zZXRDb250cm9sbGVyRGVwcyggc3lzdGVtIClcblx0JDogY29udHJvbGxlci5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuXHQkOiBhdmFpbGFibGVTeW1ib2xzID0gZ2V0KGNvbnRyb2xsZXIubWFwcGVkT3JpZ2lucykuZmlsdGVyKHAgPT4gIXAuYWN0aXZlICkubWFwKCBwID0+IHAua2V5ICk7ICBcblx0IFxuXHRsZXQgY29udHJvbGxlck1hcHBlZE9yaWdpblx0OiBXcml0YWJsZTxvcmlnaW5Sb3dEYXRhW10+O1xuXHRsZXQgY29udHJvbGxlclJlc3VsdFZhbHVlXHQ6IFdyaXRhYmxlPG51bWJlcj47XG5cdGxldCBjb250cm9sbGVyUmVzdWx0U3VjY2VzXHQ6IFdyaXRhYmxlPGJvb2xlYW4+O1xuXHRsZXQgY29udHJvbGxlck5hbWVSZXN1bHRTdWNjZXNcdDogV3JpdGFibGU8Ym9vbGVhbj47XG5cdGxldCBjb250cm9sbGVyTmFtZVJlc3VsdFZhbHVlXHQ6IFdyaXRhYmxlPHN0cmluZz4gOyAgXG5cdGxldCBjb250cm9sbGVyTmFtZVx0XHRcdDogV3JpdGFibGU8c3RyaW5nPjtcblx0bGV0IGNvbnRyb2xsZXJDYWxjXHRcdFx0OiBXcml0YWJsZTxzdHJpbmc+O1xuXHRsZXQgY29udHJvbGxlcklzVmFsaWRcdFx0OiBXcml0YWJsZTxib29sZWFuPjsgXG5cdGxldCBnZW5lcmF0aXZlTmFtZUxpc3REYXRhIFx0OiBXcml0YWJsZTxzdHJpbmdbXT5cdDtcblxuXHRmdW5jdGlvbiBvbk5hbWVJbnB1dCAoIGV2ZW50IDogYW55ICApeyAgXG5cdFx0bWVzc2FnZUhhbmRsZXI/LnJlbW92ZUVycm9yKCdzYXZlJyk7XG5cdFx0bGV0IG5hbWUgPSBldmVudC50YXJnZXQudmFsdWU7XG5cdFx0Y29udHJvbGxlci5uYW1lLnNldCggbmFtZSk7XG5cdFx0Y29udHJvbGxlci5jaGVja0lzVmFsaWQoZmFsc2UpOyAgXG5cdH1cblx0ZnVuY3Rpb24gb25DYWxjTmFtZUlucHV0ICggZXZlbnQgOiBhbnkgICl7ICBcblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRsZXQgbmFtZUNhbGMgPSBldmVudC50YXJnZXQudmFsdWU7XG5cdFx0Y29udHJvbGxlci5uYW1lQ2FsYy5zZXQoIG5hbWVDYWxjICk7XG5cdFx0Y29udHJvbGxlci5jaGVja0lzVmFsaWQoZmFsc2UpOyAgXG5cdH0gXG5cdGZ1bmN0aW9uIG9uQ2FsY0lucHV0ICggZXZlbnQgOiBhbnkgICl7IFxuXHRcdGxldCBjYWxjID0gZXZlbnQudGFyZ2V0LnZhbHVlOyBcblx0XHRjb250cm9sbGVyLmNhbGMuc2V0KCBjYWxjKTtcblx0XHRtZXNzYWdlSGFuZGxlcj8ucmVtb3ZlRXJyb3IoJ3NhdmUnKTtcblx0XHRjb250cm9sbGVyLnJlY2FsY3VsYXRlQ2FsY0FuZE9yaWdpbnMoKTsgIFxuXHRcdGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKTsgICAgXG5cdH1cblx0ZnVuY3Rpb24gb25EZWxldGVDbGlja2VkKGUpe1xuXHRcdG1lc3NhZ2VIYW5kbGVyPy5yZW1vdmVFcnJvcignc2F2ZScpO1xuXHRcdGNvbnRyb2xsZXIub25LZXlEZWxldGUoZSk7IFxuXHRcdGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKTsgIFxuXHR9XG5cdGZ1bmN0aW9uIG9uS2V5RXhjaGFuZ2UoZSl7XG5cdFx0bWVzc2FnZUhhbmRsZXI/LnJlbW92ZUVycm9yKCdzYXZlJyk7XG5cdFx0Y29udHJvbGxlci5vbktleUV4Y2hhbmdlKGUpOyBcblx0XHRjb250cm9sbGVyLmNoZWNrSXNWYWxpZChmYWxzZSk7ICBcblx0fVxuXHRmdW5jdGlvbiBvblNhdmUoKXsgXG5cdFx0bWVzc2FnZUhhbmRsZXI/LnJlbW92ZUVycm9yKCdzYXZlJyk7XG5cdFx0Y29udHJvbGxlci5zYXZlQ29sbGVjdGlvbigpOyAgICAgXG5cdFx0ZGlzcGF0Y2goJ3NhdmUnKTtcblx0fVxuXHRmdW5jdGlvbiBvbkdlblByZXZpZXdUb29nbGUoKXsgXG5cdFx0Y29udHJvbGxlci5nZW5lcmF0ZU5hbWVQcmV2aWV3KCk7XHRcdFxuXHR9XG5cdCBcblx0b25Nb3VudCgoKSA9PiB7IFxuXHRcdGNvbnRyb2xsZXIuc2V0Q29udHJvbGxlckRlcHMoIHN5c3RlbSApOyBcblx0XHRjb250cm9sbGVyLnJlY2FsY3VsYXRlQ2FsY0FuZE9yaWdpbnMoKVxuXHRcdGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKCk7IFxuXHRcdGNvbnRyb2xsZXJNYXBwZWRPcmlnaW5cdD0gY29udHJvbGxlci5tYXBwZWRPcmlnaW5zO1xuXHRcdGNvbnRyb2xsZXJSZXN1bHRWYWx1ZVx0PSBjb250cm9sbGVyLnJlc3VsdFZhbHVlO1xuXHRcdGNvbnRyb2xsZXJSZXN1bHRTdWNjZXNcdD0gY29udHJvbGxlci5yZXN1bHRTdWNjZXNzO1xuXHRcdGNvbnRyb2xsZXJOYW1lUmVzdWx0U3VjY2VzXHQ9IGNvbnRyb2xsZXIucmVzdWx0TmFtZVN1Y2Nlc3M7XG5cdFx0Y29udHJvbGxlck5hbWVSZXN1bHRWYWx1ZVx0PSBjb250cm9sbGVyLnJlc3VsdE5hbWVWYWx1ZTtcblx0XHRjb250cm9sbGVyTmFtZVx0XHRcdD0gY29udHJvbGxlci5uYW1lO1xuXHRcdGNvbnRyb2xsZXJDYWxjXHRcdFx0PSBjb250cm9sbGVyLmNhbGM7XG5cdFx0Y29udHJvbGxlcklzVmFsaWRcdFx0PSBjb250cm9sbGVyLmlzVmFsaWQ7IFxuXHRcdGdlbmVyYXRpdmVOYW1lTGlzdERhdGEgXHQ9IGNvbnRyb2xsZXIuZ2VuZXJhdGl2ZU5hbWVMaXN0RGF0YSA7XG5cdH0pXG5cbjwvc2NyaXB0PiBcbjxkaXYgY2xhc3M9XCJEZXJpdmVkQ29sbGVjdGlvbkRlc2lnbmVyXCIgZGF0YS1zdGF0ZT17ICAkY29udHJvbGxlcklzVmFsaWQgPyAnZ29vZCcgOiAnZXJyb3InIH0gZGF0YS1zdGF0ZS10ZXh0PXsgJGNvbnRyb2xsZXJJc1ZhbGlkID8gZ29vZFRpdGxlOiBiYWRUaXRsZX0+XG5cdDxkaXYgY2xhc3M9XCJEZXJpdmVkQ29sbGVjdGlvbkRlc2lnbmVyQ2xvc2VCdG5cIiBvbjpjbGljaz17KCk9PmRpc3BhdGNoKCdjbG9zZScpfSBvbjprZXlwcmVzcyA+WDwvZGl2PlxuXHRcblx0PGRpdj5cblx0XHQ8cD5cblx0XHRcdEVkaXRpbmcgbm9kZS5cblx0XHRcdEhlcmUgeW91IGNhbiBlZGl0IHNldHRpbmdzIGZvciB0aGlzIHNwZWNpZmljIG5vZGUuIHRoaXMgZWRpdCBpcyB1bmlxdWUgdG8gdGhpcyBzcGVjaWZpYyBpdGVtLlxuXHRcdDwvcD5cblx0PC9kaXY+XG5cdDxkaXYgY2xhc3M9XCJJdGVtRGVzaWduZXJfVHdvQ29sdW1uRGF0YVwiID5cblxuXHQ8L2Rpdj5cblx0PGRpdj4gIFxuXHRcdDxkaXYgY2xhc3M9XCJPcmlnaW5FZGl0b3JcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJkZXJpdmVkQ29sbGVjdGlvbkNhbGNTdGF0ZW1lbnRNYXRyaXhcIiA+XG5cdFx0XHRcdFxuXHRcdFx0XHQ8ZGl2Pm5ldyBDb2xsZWN0aW9uIE5hbWU8L2Rpdj5cblx0XHRcdFx0PHRleHRhcmVhICBjbGFzcz1cImNhbGNJbnB1dCBJdGVtRGVzaWduZXJJbnB1dFwiIG9uOmlucHV0PXsgKCBlICkgPT4geyBvbk5hbWVJbnB1dChlKSB9IH0gY29udGVudGVkaXRhYmxlIGJpbmQ6dmFsdWU9eyAkY29udHJvbGxlck5hbWUgfS8+ICBcblxuXG5cdFx0XHRcdDxkaXYgZGF0YS1zdWNjZXM9eyAkY29udHJvbGxlck5hbWVSZXN1bHRTdWNjZXMgfSA+TmFtZTwvZGl2PlxuXHRcdFx0XHQ8dGV4dGFyZWEgY2xhc3M9XCJjYWxjSW5wdXRcIlxuXHRcdFx0XHRcdG9uOmlucHV0PXsgb25DYWxjTmFtZUlucHV0IH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cImluc2VydCBOYW1lIENhbGMgU3RhdGVtZW50IGhlcmVcIlxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZGVyaXZlZENhbGNTdGF0ZW1lbnRSZXN1bHRcIiBkYXRhLXN1Y2Nlcz17ICRjb250cm9sbGVyTmFtZVJlc3VsdFN1Y2NlcyB9ID57ICRjb250cm9sbGVyTmFtZVJlc3VsdFZhbHVlIH08L2Rpdj5cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQ8ZGl2ICBkYXRhLXN1Y2Nlcz17ICRjb250cm9sbGVyUmVzdWx0U3VjY2VzIH0gPkNhbGM8L2Rpdj5cblx0XHRcdFx0PHRleHRhcmVhIGNsYXNzPVwiY2FsY0lucHV0XCIgdmFsdWU9eyAkY29udHJvbGxlckNhbGMgfSBcblx0XHRcdFx0XHRvbjppbnB1dD17IG9uQ2FsY0lucHV0IH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cImluc2VydCBjYWxjU3RhdGVtZW50IGhlcmVcIlxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZGVyaXZlZENhbGNTdGF0ZW1lbnRSZXN1bHRcIiBkYXRhLXN1Y2Nlcz17ICRjb250cm9sbGVyUmVzdWx0U3VjY2VzIH0gPnsgJGNvbnRyb2xsZXJSZXN1bHRWYWx1ZSB9PC9kaXY+XG5cdFx0XHRcdFxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZGVyaXZlZE9yaWdpblJvd3NDb250YWluZXJcIj5cblx0XHRcdFx0eyNpZiAkY29udHJvbGxlck1hcHBlZE9yaWdpbiAmJiBzZWNvbmRTbGlkZUluUmVhZHkgfVxuXHRcdFx0XHRcdHsjZWFjaCAkY29udHJvbGxlck1hcHBlZE9yaWdpbiBhcyBvcmlnaW4gKG9yaWdpbi5rZXkpIH1cblx0XHRcdFx0XHRcdDxkaXYgdHJhbnNpdGlvbjpzbGlkZXxsb2NhbCBjbGFzcz1cImRlcml2ZWRPcmlnaW5Sb3dDb250YWluZXJcIj4gXG5cdFx0XHRcdFx0XHRcdDxPcmlnaW5Sb3cgXG5cdFx0XHRcdFx0XHRcdFx0YmluZDpyb3dEYXRhIFx0ID0geyBvcmlnaW4gfVxuXHRcdFx0XHRcdFx0XHRcdGF2YWlsYWJsZVN5bWJvbHMgPSB7IGF2YWlsYWJsZVN5bWJvbHMgfVxuXHRcdFx0XHRcdFx0XHRcdHN5c3RlbSBcdFx0XHQgPSB7IHN5c3RlbS5zeXMgfVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRleHQgPSB7Y29udGV4dH1cblx0XHRcdFx0XHRcdFx0XHRvbjpvbkRlbGV0ZSBcdFx0PSB7IG9uRGVsZXRlQ2xpY2tlZCB9XG5cdFx0XHRcdFx0XHRcdFx0b246b25TeW1ib2xTZWxlY3RlZCA9IHsgb25LZXlFeGNoYW5nZSB9XG5cdFx0XHRcdFx0XHRcdFx0b246Zm91bmRUYXJnZXROb2RlID0geyAoZSkgPT57IGNvbnRyb2xsZXIuY2hlY2tJc1ZhbGlkKGZhbHNlKSB9fVxuXHRcdFx0XHRcdFx0XHRcdGFsbG93U2VsZWN0QWxsID0geyB0cnVlIH1cblx0XHRcdFx0XHRcdFx0XHRTZWxlY3RBbGxUZXh0ID0geyBzZWxBbGxJbkNvbGxlY3Rpb25TdHJpbmcgfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9kaXY+IFxuXHRcdDwvZGl2PiBcblx0PC9kaXY+IFxuXHQ8YnI+XG5cdDxkaXYgY2xhc3M9XCJJdGVtRGVzaWduZXJCdXR0b25Sb3dcIj5cblx0XHQ8YnV0dG9uIG9uOmNsaWNrPXsgb25TYXZlIH0gID5zYXZlIGNoYW5nZXM8L2J1dHRvbj4gXG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17IG9uR2VuUHJldmlld1Rvb2dsZSB9ICA+R2VuZXJhdGUgTmFtZSBQcmV2aWV3PC9idXR0b24+IFxuXHQ8L2Rpdj5cblx0PGRpdj5cblx0XHQ8VG9vZ2xlU2VjdGlvbiB0aXRsZT1cInByZXZpZXcgTmFtZXNcIj5cblx0XHRcdHsjZWFjaCAkZ2VuZXJhdGl2ZU5hbWVMaXN0RGF0YSBhcyBuYW1lIChuYW1lKSB9XG5cdFx0XHRcdDxkaXYgYW5pbWF0ZTpmbGlwIHRyYW5zaXRpb246c2xpZGV8bG9jYWwgY2xhc3M9XCJkZXJpdmVkT3JpZ2luUm93Q29udGFpbmVyXCI+IFxuXHRcdFx0XHRcdFx0e25hbWV9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9lYWNofVxuXHRcdDwvVG9vZ2xlU2VjdGlvbj5cblx0PC9kaXY+XG5cdFxuPC9kaXY+IFxuXHQgIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgIGV4cG9ydCBsZXQgY29sb3I6IHN0cmluZyA9IFwiYmxhY2tcIiA7IFxuPC9zY3JpcHQ+XG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9e2NvbG9yfSBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgY2xhc3M9XCJzdmctaWNvbiBsdWNpZGUtcGx1cy1jaXJjbGVcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMFwiPlxuICAgICAgICA8L2NpcmNsZT5cbiAgICAgICAgPGxpbmUgeDE9XCI4XCIgeTE9XCIxMlwiIHgyPVwiMTZcIiB5Mj1cIjEyXCI+XG4gICAgICA8L2xpbmU+XG4gICAgPC9zdmc+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj4gXG4gICAgIGV4cG9ydCBsZXQgY29sb3I6IHN0cmluZyA9IFwiYmxhY2tcIiA7IFxuPC9zY3JpcHQ+XG5cblxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMTAwJVwiIHdpZHRoPVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT17Y29sb3J9IHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBjbGFzcz1cInN2Zy1pY29uIGx1Y2lkZS1wbHVzLWNpcmNsZVwiPlxuICAgIDxwYXRoIGQ9XCJNMTIgMjBoOVwiPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTE2LjUgMy41YTIuMTIxIDIuMTIxIDAgMCAxIDMgM0w3IDE5bC00IDEgMS00TDE2LjUgMy41elwiPjwvcGF0aD5cbjwvc3ZnPiAiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgICBleHBvcnQgbGV0IGNvbG9yOiBzdHJpbmcgPSBcImJsYWNrXCIgOyAgXG48L3NjcmlwdD5cbiA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPXtjb2xvcn0gc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGNsYXNzPVwic3ZnLWljb24gbHVjaWRlLXBsdXMtY2lyY2xlXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFwiPjwvcGF0aD5cbiAgICAgICAgPHBvbHlsaW5lIHBvaW50cz1cIjcgMTAgMTIgMTUgMTcgMTBcIj48L3BvbHlsaW5lPlxuICAgICAgICA8bGluZSB4MT1cIjEyXCIgeTE9XCIxNVwiIHgyPVwiMTJcIiB5Mj1cIjNcIj48L2xpbmU+XG4gICAgPC9zdmc+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyAgZmx5IH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG5cdGltcG9ydCAnLi90b29sVGlwLnNjc3MnXG5cblxuXHRleHBvcnQgbGV0IHRleHQgOiBzdHJpbmcgO1xuXHRleHBvcnQgbGV0IGFuaW1YID0gMjA7XG5cdGV4cG9ydCBsZXQgYW5pbVkgPSAwO1xuXHRleHBvcnQgbGV0IHR5cGUgOiBcImVycm9yXCIgfCBcInZlcmJvc2VcIiB8IFwiZ29vZFwiIHwgXCJub25lXCI7XG5cblx0bGV0IG1vdW50ZWQgPSBmYWxzZTtcblx0b25Nb3VudCgoKT0+e1xuXHRcdHNldFRpbWVvdXQoKCkgPT4geyBtb3VudGVkID0gdHJ1ZSB9LCAxMDAgKSBcblx0fSlcbjwvc2NyaXB0PlxuIFxuPGRpdj5cblx0eyNpZiBtb3VudGVkfVxuXHRcdDxkaXYgY2xhc3M9XCJ0b29sdGlwSW5uZXJCb3hcIiBkYXRhLXR5cGU9e3R5cGV9IHRyYW5zaXRpb246Zmx5PXt7eDphbmltWCwgeTphbmltWSB9fSA+XG5cdFx0XHR7dGV4dH1cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PiIsIlxuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi90b29sVGlwLnN2ZWx0ZSc7XG5leHBvcnQgZnVuY3Rpb24gdG9vbHRpcChub2RlLCB7IHRleHQ6dGV4dCAsIHR5cGUgPSBcIm5vbmVcIiwgYW5pbVggPSAyMCwgYW5pbVkgPSAwLCBYb2Zmc2V0ID0gMCwgWW9mZnNldCA9IDAgfSkge1xuICAgIFxuXHRsZXQgdG9vbHRpcEVsZW1lbnQ7XG5cdGxldCB0b29sdGlwQ29tcG9uZW50O1xuXG4gICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoKSB7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IFxuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IFxuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS56SW5kZXggPSAnMjAwMCc7XG4gIFxuXHRcdHRvb2x0aXBDb21wb25lbnQgPSBuZXcgVG9vbHRpcCh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRvb2x0aXBFbGVtZW50LFxuICAgICAgICAgICAgcHJvcHM6IHsgdGV4dDp0ZXh0ICwgdHlwZTp0eXBlICwgYW5pbVg6YW5pbVggLCBhbmltWTphbmltWSB9XG4gICAgICAgIH0pO1xuXHRcdFxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBFbGVtZW50KTtcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIGhlaWdodCArIHdpbmRvdy5zY3JvbGxZICsgWW9mZnNldH1weGA7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnN0eWxlLmxlZnQgPSBgJHsobGVmdCArIHdpZHRoIC8gMiAtIHRvb2x0aXBFbGVtZW50Lm9mZnNldFdpZHRoIC8gMiArIHdpbmRvdy5zY3JvbGxYICkrIFhvZmZzZXR9cHhgO1xuIFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xuXG5cdFx0aWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRvb2x0aXBDb21wb25lbnQuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRvb2x0aXBDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgICAgICB0b29sdGlwRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHNob3dUb29sdGlwKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoaWRlVG9vbHRpcCk7XG5cbiAgICByZXR1cm4ge1xuXHRcdHVwZGF0ZSggeyB0ZXh0OnRleHQgLCB0eXBlID0gXCJub25lXCIsIGFuaW1YID0gMjAsIGFuaW1ZID0gMCwgWG9mZnNldCA9IDAsIFlvZmZzZXQgPSAwIH0pIHtcbiAgICAgICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50LiRzZXQoeyB0ZXh0OnRleHQgLCB0eXBlOnR5cGUgLCBhbmltWDphbmltWCAsIGFuaW1ZOmFuaW1ZICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHNob3dUb29sdGlwKTtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhpZGVUb29sdGlwKTtcbiAgICAgICAgICAgIGlmICh0b29sdGlwQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSBcbiAgICB9O1xufVxuXG5cblxuLypcblxuZXhwb3J0IGZ1bmN0aW9uIHRvb2x0aXAobm9kZSwgeyB0ZXh0IH0pIHtcbiAgICBsZXQgdG9vbHRpcENvbXBvbmVudDtcblxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICAgICB0b29sdGlwQ29tcG9uZW50ID0gbmV3IFRvb2x0aXAoe1xuICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgcHJvcHM6IHsgdGV4dCB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0b29sdGlwQ29tcG9uZW50LiRzZXQoe1xuICAgICAgICAgICAgc3R5bGU6IGB0b3A6ICR7dG9wICsgaGVpZ2h0ICsgd2luZG93LnNjcm9sbFl9cHg7IGxlZnQ6ICR7bGVmdCArIHdpZHRoIC8gMiArIHdpbmRvdy5zY3JvbGxYfXB4O2BcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIGlmICh0b29sdGlwQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHNob3dUb29sdGlwKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoaWRlVG9vbHRpcCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUoeyB0ZXh0OiBuZXdUZXh0IH0pIHtcbiAgICAgICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50LiRzZXQoeyB0ZXh0OiBuZXdUZXh0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1Rvb2x0aXApO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRvb2x0aXApO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSovICIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgICBpbXBvcnQgeyB0b29sdGlwIH0gZnJvbSBcIi4uL01lc3NhZ2VzL3Rvb2xUaXBcIjtcblx0aW1wb3J0IEltYWdlX3RyYXNoIGZyb20gXCIuLi9idXR0b25zL3RyYXNoLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgSW1hZ2VfbWludXMgZnJvbSBcIi4uL2J1dHRvbnMvbWludXMuc3ZlbHRlXCI7XG5cdGltcG9ydCBJbWFnZV9wbHVzIGZyb20gXCIuLi9idXR0b25zL3BsdXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEltYWdlX2VkaXQgZnJvbSBcIi4uL2J1dHRvbnMvZWRpdC5zdmVsdGVcIjsgXG5cdGltcG9ydCBJbWFnZV9zYXZlIGZyb20gXCIuLi9idXR0b25zL2Rvd25sb2FkLnN2ZWx0ZVwiOyBcbiAgICBpbXBvcnQgeyBvbkRlc3Ryb3ksIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgU3RyaW5nRnVuY3Rpb25zIH0gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2NvcmUvQmFzZUZ1bmN0aW9ucy9zdHJpbmdmdW5jdGlvbnNcIjtcbiAgICBpbXBvcnQgeyBJVmlld0VsZW1lbnRVcGRhdGVhYmxlIH0gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9WYXJpb3VzXCI7XG5cblxuXHRleHBvcnQgbGV0IGVkaXRJc0FjdGl2ZSBcdFx0XHQ6IGJvb2xlYW47XG5cdGV4cG9ydCBsZXQgZWxlbWVudCBcdFx0XHRcdFx0OiBJVmlld0VsZW1lbnRVcGRhdGVhYmxlO1xuXHRleHBvcnQgbGV0IHNlbGVjdGVkXHRcdFx0XHRcdDogSVZpZXdFbGVtZW50VXBkYXRlYWJsZSB8IG51bGwgOyBcblx0ZXhwb3J0IGxldCBkZWxldGVJc0FsbG93ZWRcdFx0XHQ6IGJvb2xlYW47XG5cdGV4cG9ydCBsZXQgZGlzYWJsZWQgXHRcdFx0XHQ6IGJvb2xlYW47XG5cdGV4cG9ydCBsZXQgb25EZWxldGVcdFx0XHRcdFx0OiAoIGl0ZW0gOiBJVmlld0VsZW1lbnRVcGRhdGVhYmxlICkgPT4gYW55IDtcblx0ZXhwb3J0IGxldCBvblNlbGVjdFx0XHRcdFx0XHQ6ICggaXRlbSA6IElWaWV3RWxlbWVudFVwZGF0ZWFibGUgKSA9PiB2b2lkIDtcblx0ZXhwb3J0IGxldCBvbkVkaXRDYW5jZWxTaW5nbGVcdFx0OiAoIGl0ZW0gOiBJVmlld0VsZW1lbnRVcGRhdGVhYmxlICkgPT4gYW55IDtcblx0ZXhwb3J0IGxldCBvbkVkaXRGb2N1c1x0XHRcdFx0OiAoIGFueSA6IGFueSApID0+IGFueSA7XG5cblx0bGV0IGsgPSAwO1xuXHRsZXQga2V5ID0gXCJlZGl0QWJsZVJvd1wiICsgU3RyaW5nRnVuY3Rpb25zLnV1aWR2NCgpO1xuXG5cdG9uTW91bnRcdFx0KCgpPT57XG5cdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGtleSwndXBkYXRlJywgdXBkYXRlICk7XG5cdH0pXG5cblx0b25EZXN0cm95XHQoKCk9PnsgXG5cdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGtleSk7XG5cdH0pXG5cblx0ZnVuY3Rpb24gdXBkYXRlKCl7XG5cdFx0aysrO1xuXHR9XG5cblxuPC9zY3JpcHQ+XG57I2tleSBrfVxuXHQ8ZGl2XG5cdFx0Y2xhc3M9XCJFZGl0YWJsZV9yb3dcIiBcblx0XHRkYXRhLXNlbGVjdGVkPXsgIWVkaXRJc0FjdGl2ZSAmJiAoZWxlbWVudC5rZXkgPT0gc2VsZWN0ZWQ/LmtleSkgfVxuXHRcdGRhdGEtY2FuLWhvdmVyPXt0cnVlfVxuXHRcdGRhdGEtaXNFZGl0PXsgZWRpdElzQWN0aXZlICYmIChlbGVtZW50Lm5hbWUgIT0gZWxlbWVudC5uYW1lRWRpdCkgfSBcblx0PlxuXHRcdHsjaWYgIWVkaXRJc0FjdGl2ZSB9IFxuXHRcdFx0PGRpdlxuXHRcdFx0XHR0YWJpbmRleD1cIi0xXCIgXG5cdFx0XHRcdGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIgXG5cdFx0XHRcdG9uOmNsaWNrPXsgKCkgPT4geyBpZiggZGlzYWJsZWQgKXsgcmV0dXJuIH0gIG9uU2VsZWN0KGVsZW1lbnQpfSB9XG5cdFx0XHRcdG9uOmtleXVwIFxuXHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHQ+ICBcblx0XHRcdFx0eyBlbGVtZW50Lm5hbWUgfSBcblx0XHRcdDwvZGl2PlxuXHRcdHs6ZWxzZX1cblx0XHRcdDxkaXZcblx0XHRcdFx0dGFiaW5kZXg9XCIxXCIgXG5cdFx0XHRcdHJvbGU9XCJjZWxsXCJcblx0XHRcdFx0Y29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXG5cdFx0XHRcdG9uOmZvY3VzPXsgb25FZGl0Rm9jdXMgfVxuXHRcdFx0XHRiaW5kOnRleHRDb250ZW50PXsgZWxlbWVudC5uYW1lRWRpdCB9IFxuXHRcdFx0XHRhdXRvZm9jdXM9e3RydWV9XG5cdFx0XHQ+IFxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZiB9XG5cdFx0XG5cdFx0PGRpdj4gXG5cdFx0XHR7I2lmIGRlbGV0ZUlzQWxsb3dlZCB9IFxuXHRcdFx0XHQ8aW1hZ2VDb250YWluZXIgIFxuXHRcdFx0XHRcdG9uOmNsaWNrPXsgKCkgPT4gb25EZWxldGUoIGVsZW1lbnQgKSB9XG5cdFx0XHRcdFx0b246a2V5dXAgXG5cdFx0XHRcdFx0cm9sZT1cIm5vbmVcIlxuXHRcdFx0XHRcdHRyYW5zaXRpb246c2xpZGV8bG9jYWxcblx0XHRcdFx0XHR1c2U6dG9vbHRpcD17eyB0ZXh0OiAnRGVsZXRlIGl0ZW0nLCB0eXBlOid2ZXJib3NlJyAsIH19XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8SW1hZ2VfdHJhc2ggY29sb3I9eyAnd2hpdGUnfS8+XG5cdFx0XHRcdDwvaW1hZ2VDb250YWluZXI+ICAgXG5cdFx0XHR7OmVsc2UgaWYgZWRpdElzQWN0aXZlICYmIGVsZW1lbnQubmFtZSAhPSBlbGVtZW50Lm5hbWVFZGl0IH1cblx0XHRcdFx0PGltYWdlQ29udGFpbmVyICBcblx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+IG9uRWRpdENhbmNlbFNpbmdsZShlbGVtZW50KSB9XG5cdFx0XHRcdFx0b246a2V5dXAgXG5cdFx0XHRcdFx0cm9sZT1cIm5vbmVcIlxuXHRcdFx0XHRcdHRyYW5zaXRpb246c2xpZGV8bG9jYWxcblx0XHRcdFx0XHR1c2U6dG9vbHRpcD17eyB0ZXh0OiAnRGVsZXRlIGl0ZW0nLCB0eXBlOid2ZXJib3NlJyAsIH19XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8SW1hZ2VfbWludXMgY29sb3I9eyAnd2hpdGUnfS8+XG5cdFx0XHRcdDwvaW1hZ2VDb250YWluZXI+ICAgXG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxpbWFnZUNvbnRhaW5lciA+IDwvaW1hZ2VDb250YWluZXI+IFxuXHRcdFx0ey9pZn0gXG5cdFx0PC9kaXY+IFxuXHQ8L2Rpdj5cbnsva2V5fSIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cblx0aW1wb3J0IEltYWdlX3RyYXNoIGZyb20gXCIuLi9idXR0b25zL3RyYXNoLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgSW1hZ2VfbWludXMgZnJvbSBcIi4uL2J1dHRvbnMvbWludXMuc3ZlbHRlXCI7XG5cdGltcG9ydCBJbWFnZV9wbHVzIGZyb20gXCIuLi9idXR0b25zL3BsdXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEltYWdlX2VkaXQgZnJvbSBcIi4uL2J1dHRvbnMvZWRpdC5zdmVsdGVcIjsgXG5cdGltcG9ydCBJbWFnZV9zYXZlIGZyb20gXCIuLi9idXR0b25zL2Rvd25sb2FkLnN2ZWx0ZVwiOyBcbiAgICBpbXBvcnQgeyBzbGlkZSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25EZXN0cm95LCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiOyAgXG5cdFxuXHRpbXBvcnQgeyB0b29sdGlwIH0gZnJvbSAnLi4vTWVzc2FnZXMvdG9vbFRpcC5qcyc7IFxuICAgIFxuICAgIGltcG9ydCB7IFN0cmluZ0Z1bmN0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9jb3JlL0Jhc2VGdW5jdGlvbnMvc3RyaW5nZnVuY3Rpb25zXCI7XG4gICAgaW1wb3J0IEVkaXRBYmxlTGlzdCBmcm9tIFwiLi9FZGl0QWJsZUxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEVkaXRBYmxlTGlzdFJvdyBmcm9tIFwiLi9FZGl0QWJsZUxpc3RSb3cuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgZmxpcCB9IGZyb20gXCJzdmVsdGUvYW5pbWF0ZVwiO1xuICAgIGltcG9ydCB7IElWaWV3RWxlbWVudFVwZGF0ZWFibGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9VSUNvbXBvc2l0aW9uL1ZhcmlvdXNcIjtcblxuXG5cdGV4cG9ydCBsZXQgaXNFZGl0YWJsZUNvbnRhaW5lcjpib29sZWFuID0gdHJ1ZTtcbiAgICBleHBvcnQgbGV0IGNvbGxlY3Rpb246IElWaWV3RWxlbWVudFVwZGF0ZWFibGVbXSA9IFtdO1xuXHRleHBvcnQgbGV0IG9uU2VsZWN0XHRcdDogKCBkOiBJVmlld0VsZW1lbnRVcGRhdGVhYmxlICkgPT4gYm9vbGVhbjtcblx0ZXhwb3J0IGxldCBvbkFkZFx0XHQ6KCgpID0+IGFueSkgfCBudWxsID0gbnVsbDsgXG5cdGV4cG9ydCBsZXQgb25TcGVjaWFsQWRkXHQ6KCgpID0+IGFueSkgfCBudWxsID0gbnVsbDsgIFxuXHRleHBvcnQgbGV0IG9uVXBkYXRlSXRlbVx0OiggKGl0ZW06SVZpZXdFbGVtZW50VXBkYXRlYWJsZVtdKT0+YW55KSB8IG51bGw7XG5cdGV4cG9ydCBsZXQgb25EZWxldGVJdGVtXHQ6KCAoaXRlbTpJVmlld0VsZW1lbnRVcGRhdGVhYmxlKT0+YW55KSB8IG51bGw7XG5cdGV4cG9ydCBsZXQgZGlzYWJsZWQgOiBib29sZWFuID0gZmFsc2U7XG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0bGV0IHNlbGVjdGVkIDogSVZpZXdFbGVtZW50VXBkYXRlYWJsZSB8IG51bGwgPSBudWxsOyBcblx0bGV0IGVkaXRJc0FjdGl2ZSA9IGZhbHNlOyAgXG5cblx0b25Nb3VudCgoKT0+eyBcblx0IFxuXHR9KVxuXHRcblx0b25EZXN0cm95KCgpPT57XG5cdFx0XG5cdH0pXG4gXG5cdGV4cG9ydCBmdW5jdGlvbiBkZXNlbGVjdCgpe1xuXHRcdGlmKCFzZWxlY3RlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHNlbGVjdGVkID0gbnVsbDtcblx0XHRkaXNwYXRjaCgnb25EZVNlbGVjdCcpXG5cdH1cblx0ZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdCgga2V5IDogc3RyaW5nICl7XG5cdFx0XG5cdFx0bGV0IGl0ZW0gPSBjb2xsZWN0aW9uLmZpbmQoIHAgPT4gcC5rZXkgPT0ga2V5ICk7XG5cdFx0aWYgKCBpdGVtPy5rZXkgPT0gc2VsZWN0ZWQ/LmtleSl7XG5cdFx0XHRkZXNlbGVjdCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRcblx0XHRlbHNlIGlmICggaXRlbSApe1xuXHRcdFx0X29uU2VsZWN0KCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIF9vblNlbGVjdChpdGVtIDogSVZpZXdFbGVtZW50VXBkYXRlYWJsZSl7IFxuXG5cdFx0Ly8gZW5zdXJlIHRoYXQgYSBDbGljayBvbiB0aGUgc2FtZSBpdGVtIGlzIGEgZGVzZWxlY3Rcblx0XHRpZiAoIGl0ZW0ua2V5ID09IHNlbGVjdGVkPy5rZXkgKXtcblx0XHRcdGRlc2VsZWN0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBvblNlbGVjdChpdGVtKTsgXG5cdFx0aWYgKGlzU2VsZWN0ZWQpe1xuXHRcdFx0c2VsZWN0ZWQgPSBpdGVtO1xuXHRcdH0gZWxzZXtcblx0XHRcdHNlbGVjdGVkID0gbnVsbDtcblx0XHR9XG4gXG5cdH1cblx0ZnVuY3Rpb24gX29uQWRkKCl7XG5cdFx0aWYoIW9uQWRkKVxuXHRcdFx0cmV0dXJuO1x0XG5cdFx0b25BZGQoKTtcblx0fVxuXG5cblx0Ly8gRURJVCBGVU5DVElPTkFMSVRJRVMgXG5cdGZ1bmN0aW9uIG9uRWRpdENsaWNrZWQoICl7XG5cblx0XHRjb2xsZWN0aW9uLmZvckVhY2goIGl0ZW0gPT4ge1xuXHRcdFx0aXRlbS5uYW1lRWRpdCA9IGl0ZW0ubmFtZTtcblx0XHR9KTtcblx0XHRlZGl0SXNBY3RpdmUgPSAhZWRpdElzQWN0aXZlO1xuXHR9XG5cdGZ1bmN0aW9uIG9uRWRpdFNhdmVkKCApe1xuXHQgXHQgIFxuXHRcdGlmICghb25VcGRhdGVJdGVtKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0b25VcGRhdGVJdGVtKCBjb2xsZWN0aW9uICk7ICBcblx0XHRlZGl0SXNBY3RpdmUgPSAhZWRpdElzQWN0aXZlOyBcblx0fSBcblx0ZnVuY3Rpb24gb25FZGl0Q2FuY2VsU2luZ2xlKCBpdGVtIDogSVZpZXdFbGVtZW50VXBkYXRlYWJsZSApeyBcblx0XHRpdGVtLm5hbWVFZGl0ID0gaXRlbS5uYW1lOyBcblx0fVxuXHRmdW5jdGlvbiBvbkRlbGV0ZSggaXRlbSA6IElWaWV3RWxlbWVudFVwZGF0ZWFibGUgKXsgXG5cdFx0aWYgKCAhb25EZWxldGVJdGVtKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdG9uRGVsZXRlSXRlbSggaXRlbSApO1xuXHR9IFxuXHRmdW5jdGlvbiBvbkVkaXRGb2N1cyggcm93IDogYW55ICl7XG5cdFx0Y29uc3QgZWxlbWVudCA9IHJvdy50YXJnZXQ7XG5cdFx0Y29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgXG5cdFx0aWYgKCFyYW5nZSB8fCAhc2VsZWN0aW9uKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG4gXG5cdFx0cmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsZW1lbnQpO1xuXHRcdHJhbmdlLmNvbGxhcHNlKGZhbHNlKTsgLy8gQ29sbGFwc2UgdGhlIHJhbmdlIHRvIHRoZSBlbmRcblx0XHRzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdFx0c2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcblx0fVxuXG4gXG5cbjwvc2NyaXB0PlxuXG5cbjxkaXYgY2xhc3M9eyBpc0VkaXRhYmxlQ29udGFpbmVyID8gXCJHcm9ic0ludGVyYWN0aXZlQ29udGFpbmVyIGVkaXRhYmxlVGFibGVcIiA6IFwiZWRpdGFibGVUYWJsZVwifT5cblx0XHR7I2lmICghZGlzYWJsZWQpIH1cblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3M9XCJFZGl0YWJsZV9yb3dIZWFkZXJcIiAgXG5cdFx0XHRcdGRhdGEtY2FuLWhvdmVyPXt0cnVlfSBcblx0XHRcdD4gXG5cdFx0XHRcdDwhLS0gZWRpdCAtLT5cblx0XHRcdFx0eyNpZiBvblVwZGF0ZUl0ZW0gIT0gbnVsbCB9XG5cdFx0XHRcdFx0eyNpZiAhZWRpdElzQWN0aXZlIH1cblx0XHRcdFx0XHRcdDxpbWFnZUNvbnRhaW5lciBcblx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eyBvbkVkaXRDbGlja2VkIH1cblx0XHRcdFx0XHRcdFx0b246a2V5dXA9eyBvbkVkaXRDbGlja2VkIH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHRcdFx0XHRcdHVzZTp0b29sdGlwPXt7IHRleHQ6ICdUdXJuIG9uIEVkaXQgbW9kZScsIHR5cGU6J3ZlcmJvc2UnIH19IFxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8SW1hZ2VfZWRpdCBjb2xvcj17ICd3aGl0ZSd9IC8+XG5cdFx0XHRcdFx0XHQ8L2ltYWdlQ29udGFpbmVyID5cblx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdDxpbWFnZUNvbnRhaW5lciBcblx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eyBvbkVkaXRDbGlja2VkIH1cblx0XHRcdFx0XHRcdFx0b246a2V5dXA9eyBvbkVkaXRDbGlja2VkIH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHRcdFx0XHRcdHVzZTp0b29sdGlwPXt7IHRleHQ6ICdUdXJuIG9mZiBFZGl0IG1vZGUnLCB0eXBlOid2ZXJib3NlJyB9fSBcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PEltYWdlX2VkaXQgY29sb3I9eyAnd2hpdGUnfSAvPlxuXHRcdFx0XHRcdFx0PC9pbWFnZUNvbnRhaW5lciA+XG5cdFx0XHRcdFx0XHQ8aW1hZ2VDb250YWluZXIgXG5cdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsgb25FZGl0U2F2ZWQgfVxuXHRcdFx0XHRcdFx0XHRvbjprZXl1cD17IG9uRWRpdFNhdmVkIH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHRcdFx0XHRcdHVzZTp0b29sdGlwPXt7IHRleHQ6ICdTYXZlIGNoYW5nZXMgbWFkZScsIHR5cGU6J3ZlcmJvc2UnIH19IFxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8SW1hZ2Vfc2F2ZSBjb2xvcj17ICd3aGl0ZSd9IC8+XG5cdFx0XHRcdFx0XHQ8L2ltYWdlQ29udGFpbmVyID5cblxuXHRcdFx0XHRcdFx0PGltYWdlQ29udGFpbmVyIFxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17IG9uRWRpdENsaWNrZWQgfVxuXHRcdFx0XHRcdFx0XHRvbjprZXl1cD17IG9uRWRpdENsaWNrZWQgfVxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uOnNsaWRlfGxvY2FsXG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJub25lXCJcblx0XHRcdFx0XHRcdFx0dXNlOnRvb2x0aXA9e3sgdGV4dDogJ0Rpc2NhcmQgQ2hhbmdlcycsIHR5cGU6J3ZlcmJvc2UnIH19IFxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8SW1hZ2VfbWludXMgY29sb3I9eyAnd2hpdGUnfSAvPlxuXHRcdFx0XHRcdFx0PC9pbWFnZUNvbnRhaW5lciA+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0ey9pZn1cblxuXHRcdFx0XHQ8IS0tIEFkZCAtLT5cblx0XHRcdFx0eyNpZiBvbkFkZCAhPSBudWxsIH1cblx0XHRcdFx0XHQ8aW1hZ2VDb250YWluZXIgXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+e2lmKF9vbkFkZCl7IF9vbkFkZCgpfX0gfVxuXHRcdFx0XHRcdFx0b246a2V5dXAgXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uOnNsaWRlfGxvY2FsXG5cdFx0XHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHRcdFx0XHR1c2U6dG9vbHRpcD17eyB0ZXh0OiAnQWRkIFRvIExpc3QnLCB0eXBlOid2ZXJib3NlJyB9fSBcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8SW1hZ2VfcGx1cyBjb2xvcj17ICd3aGl0ZSd9IC8+XG5cdFx0XHRcdFx0PC9pbWFnZUNvbnRhaW5lciA+XG5cdFx0XHRcdHsvaWZ9XG5cblx0XHRcdFx0PCEtLSBBZGQgU3BlY2lhbCAtLT5cblx0XHRcdFx0eyNpZiBvblNwZWNpYWxBZGQgIT0gbnVsbCB9XG5cdFx0XHRcdFx0PGltYWdlQ29udGFpbmVyIFxuXHRcdFx0XHRcdFx0b246Y2xpY2s9eyAoKSA9PiB7aWYob25TcGVjaWFsQWRkKXtvblNwZWNpYWxBZGQoKX19IH1cblx0XHRcdFx0XHRcdG9uOmtleXVwIFxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRcdFx0cm9sZT1cIm5vbmVcIlxuXHRcdFx0XHRcdFx0dXNlOnRvb2x0aXA9e3sgdGV4dDogJ0FkZCBFbnRpcmUgY29sbGVjdGlvbicsIHR5cGU6J3ZlcmJvc2UnIH19IFxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxJbWFnZV9wbHVzIGNvbG9yPXsgJ3llbGxvdyd9IC8+XG5cdFx0XHRcdFx0PC9pbWFnZUNvbnRhaW5lciA+XG5cdFx0XHRcdHsvaWZ9XG5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdFx0eyNlYWNoIGNvbGxlY3Rpb24gYXMgZWxlbWVudCAsIGkgICggZWxlbWVudC5rZXkgKSB9IFxuXHRcdHtAY29uc3QgZGVsZXRlSXNBbGxvd2VkPSggIWRpc2FibGVkICYmIChvbkRlbGV0ZUl0ZW0gIT0gbnVsbCkgICkgICYmICFlZGl0SXNBY3RpdmUgIH1cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdHRyYW5zaXRpb246c2xpZGV8bG9jYWxcblx0XHRcdFx0XHRhbmltYXRlOmZsaXBcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxFZGl0QWJsZUxpc3RSb3dcblx0XHRcdFx0XHRcdGVkaXRJc0FjdGl2ZVx0XHQ9IHtlZGl0SXNBY3RpdmV9XG5cdFx0XHRcdFx0XHRiaW5kOmVsZW1lbnRcdFx0PSB7ZWxlbWVudH1cblx0XHRcdFx0XHRcdHNlbGVjdGVkXHRcdFx0PSB7c2VsZWN0ZWR9XG5cdFx0XHRcdFx0XHRkaXNhYmxlZFx0XHRcdD0ge2Rpc2FibGVkfVxuXHRcdFx0XHRcdFx0ZGVsZXRlSXNBbGxvd2VkXHRcdD0ge2RlbGV0ZUlzQWxsb3dlZH1cblx0XHRcdFx0XHRcdG9uRGVsZXRlXHRcdFx0PSB7b25EZWxldGV9XG5cdFx0XHRcdFx0XHRvblNlbGVjdFx0XHRcdD0ge19vblNlbGVjdH1cblx0XHRcdFx0XHRcdG9uRWRpdENhbmNlbFNpbmdsZVx0PSB7b25FZGl0Q2FuY2VsU2luZ2xlfVxuXHRcdFx0XHRcdFx0b25FZGl0Rm9jdXNcdFx0XHQ9IHtvbkVkaXRGb2N1c31cblx0XHRcdFx0XHQvPiBcblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8IS0tXG5cdFx0XHR7QGNvbnN0IGRlbGV0ZUlzQWxsb3dlZD0oICFkaXNhYmxlZCAmJiAob25EZWxldGVJdGVtICE9IG51bGwpICApICAmJiAhZWRpdElzQWN0aXZlICB9XG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzPVwiRWRpdGFibGVfcm93XCIgXG5cdFx0XHRcdGRhdGEtc2VsZWN0ZWQ9eyAhZWRpdElzQWN0aXZlICYmIChlbGVtZW50LmtleSA9PSBzZWxlY3RlZD8ua2V5KSB9XG5cdFx0XHRcdHRyYW5zaXRpb246c2xpZGV8bG9jYWxcblx0XHRcdFx0ZGF0YS1jYW4taG92ZXI9e3RydWV9XG5cdFx0XHRcdGRhdGEtaXNFZGl0PXsgZWRpdElzQWN0aXZlICYmIChlbGVtZW50Lm5hbWUgIT0gZWxlbWVudC5uYW1lRWRpdCkgfSBcblx0XHRcdD5cblx0XHRcdFx0eyNpZiAhZWRpdElzQWN0aXZlIH0gXG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0dGFiaW5kZXg9XCItMVwiIFxuXHRcdFx0XHRcdFx0Y29udGVudGVkaXRhYmxlPVwiZmFsc2VcIiBcblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsgKCkgPT4geyBpZiggZGlzYWJsZWQgKXsgcmV0dXJuIH0gIF9vblNlbGVjdChlbGVtZW50KX0gfVxuXHRcdFx0XHRcdFx0b246a2V5dXAgXG5cdFx0XHRcdFx0XHRyb2xlPVwibm9uZVwiXG5cdFx0XHRcdFx0PiAgXG5cdFx0XHRcdFx0XHR7IGVsZW1lbnQubmFtZSB9IFxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0dGFiaW5kZXg9XCIxXCIgXG5cdFx0XHRcdFx0XHRyb2xlPVwiY2VsbFwiXG5cdFx0XHRcdFx0XHRjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJcblx0XHRcdFx0XHRcdG9uOmZvY3VzPXsgb25FZGl0Rm9jdXMgfVxuXHRcdFx0XHRcdFx0YmluZDp0ZXh0Q29udGVudD17IGVsZW1lbnQubmFtZUVkaXQgfSBcblx0XHRcdFx0XHRcdGF1dG9mb2N1cz17dHJ1ZX1cblx0XHRcdFx0XHQ+IFxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7L2lmIH1cblx0XHRcdFx0XG5cdFx0XHRcdDxkaXY+IFxuXHRcdFx0XHRcdHsjaWYgZGVsZXRlSXNBbGxvd2VkIH0gXG5cdFx0XHRcdFx0XHQ8aW1hZ2VDb250YWluZXIgIFxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+IG9uRGVsZXRlKCBlbGVtZW50ICkgfVxuXHRcdFx0XHRcdFx0XHRvbjprZXl1cCBcblx0XHRcdFx0XHRcdFx0cm9sZT1cIm5vbmVcIlxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uOnNsaWRlfGxvY2FsXG5cdFx0XHRcdFx0XHRcdHVzZTp0b29sdGlwPXt7IHRleHQ6ICdEZWxldGUgaXRlbScsIHR5cGU6J3ZlcmJvc2UnICwgfX1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PEltYWdlX3RyYXNoIGNvbG9yPXsgJ3doaXRlJ30vPlxuXHRcdFx0XHRcdFx0PC9pbWFnZUNvbnRhaW5lcj4gICBcblx0XHRcdFx0XHR7OmVsc2UgaWYgZWRpdElzQWN0aXZlICYmIGVsZW1lbnQubmFtZSAhPSBlbGVtZW50Lm5hbWVFZGl0IH1cblx0XHRcdFx0XHRcdDxpbWFnZUNvbnRhaW5lciAgXG5cdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsgKCkgPT4gb25FZGl0Q2FuY2VsU2luZ2xlKGVsZW1lbnQpIH1cblx0XHRcdFx0XHRcdFx0b246a2V5dXAgXG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJub25lXCJcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpzbGlkZXxsb2NhbFxuXHRcdFx0XHRcdFx0XHR1c2U6dG9vbHRpcD17eyB0ZXh0OiAnRGVsZXRlIGl0ZW0nLCB0eXBlOid2ZXJib3NlJyAsIH19XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxJbWFnZV9taW51cyBjb2xvcj17ICd3aGl0ZSd9Lz5cblx0XHRcdFx0XHRcdDwvaW1hZ2VDb250YWluZXI+ICAgXG5cdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0PGltYWdlQ29udGFpbmVyID4gPC9pbWFnZUNvbnRhaW5lcj4gXG5cdFx0XHRcdFx0ey9pZn0gXG5cdFx0XHRcdDwvZGl2PiBcblx0XHRcdDwvZGl2PlxuXHRcdFx0LS0+XG5cdFx0ey9lYWNofVxuXHRcdFxuPC9kaXY+XG5cbiAiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGltcG9ydCB7IHNsaWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gICAgaW1wb3J0IEZpeGVkSXRlbURlc2lnbmVyIGZyb20gXCIuL0ZpeGVkSXRlbURlc2lnbmVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBEZXJpdmVkSXRlbURlc2lnbmVyIGZyb20gXCIuL0Rlcml2ZWRJdGVtRGVzaWduZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IERlcml2ZWRDb2xsZWN0aW9uRGVzaWduZXIgZnJvbSBcIi4vRGVyaXZlZENvbGxlY3Rpb25EZXNpZ25lci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBvbkRlc3Ryb3ksIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IExheW91dDAxQ29udGV4dCB9IGZyb20gXCIuLi8uLi8uLi8uLi9jb250ZXh0XCI7XG5cblx0aW1wb3J0IHsgVFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZyB9IFx0ZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXJcIjtcbiAgICBpbXBvcnQgRWRpdEFibGVMaXN0MiBcdFx0XHRcdFx0ZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvZWRpdEFibGVMaXN0L0VkaXRBYmxlTGlzdDIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFRvb2dsZVNlY3Rpb24gXHRcdFx0XHRcdGZyb20gXCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL3Rvb2dsZVNlY3Rpb24vdG9vZ2xlU2VjdGlvbi5zdmVsdGVcIjtcblx0aW1wb3J0IFN0YXRpY01lc3NhZ2VIYW5kbGVyIFx0XHRcdGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL3VpL0NvbXBvbmVudHMvTWVzc2FnZXMvU3RhdGljTWVzc2FnZUhhbmRsZXIuc3ZlbHRlJ1xuICAgIGltcG9ydCB7IFN0cmluZ0Z1bmN0aW9ucyB9IFx0XHRcdFx0ZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2NvcmUvQmFzZUZ1bmN0aW9ucy9zdHJpbmdmdW5jdGlvbnNcIjtcblx0aW1wb3J0IHsgVUlTeXN0ZW0gfSBcdFx0XHRcdFx0ZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSVN5c3RlbVwiO1xuICAgIGltcG9ydCB7IFVJQ29sbGVjdGlvbiB9IFx0XHRcdFx0ZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2dyYXBoRGVzaWduZXIvVUlDb21wb3NpdGlvbi9VSUNvbGxlY3Rpb25cIjtcbiAgICBpbXBvcnQgeyBVSU5vZGUgfSBcdFx0XHRcdFx0XHRmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvZ3JhcGhEZXNpZ25lci9VSUNvbXBvc2l0aW9uL1VJTm9kZVwiO1xuXG4gICAgZXhwb3J0IGxldCBjb250ZXh0XHQ6IExheW91dDAxQ29udGV4dDsgXG4gICAgZXhwb3J0IGxldCBzeXN0ZW0gOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nO1xuICAgIGxldCB1aVN5c3RlbSA6IFVJU3lzdGVtIHwgbnVsbCA9IGNvbnRleHQudWlTeXN0ZW0gPz8gbmV3IFVJU3lzdGVtKHN5c3RlbSk7XG5cdGxldCBndWlkS2V5XHQ6IHN0cmluZyA9ICBjb250ZXh0LnVpR3VpZCA/PyAnZGVzaWduZXInK1N0cmluZ0Z1bmN0aW9ucy51dWlkdjQoKTtcblx0Y29udGV4dC51aVN5c3RlbSA9IHVpU3lzdGVtO1xuXHRjb250ZXh0LnVpR3VpZCA9IGd1aWRLZXk7XG5cblxuXHQvLyBEZXJpdmVkIEZpeGVkIExvZ2ljXG5cdGxldCBkZXJpdmVkR3JwXHQ9IHVpU3lzdGVtLmdyb3Vwcy5maW5kKCBwID0+IHAubmFtZSA9PSAnZGVyaXZlZCcpO1xuXHRsZXQgZml4ZWRHcnBcdD0gdWlTeXN0ZW0uZ3JvdXBzLmZpbmQoIHAgPT4gcC5uYW1lID09ICdmaXhlZCcpO1xuXG5cdGxldCBkZXJpdmVkQ29sXHQ6IFVJQ29sbGVjdGlvbiB8IG51bGwgPSBudWxsO1xuXHRsZXQgZml4ZWRDb2xcdDogVUlDb2xsZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cblx0bGV0IGRlcml2ZWROb2RcdDogVUlOb2RlIHwgbnVsbCA9IG51bGw7XG5cdGxldCBmaXhlZE5vZFx0OiBVSU5vZGUgfCBudWxsID0gbnVsbDtcblxuXHQvLyBTcGVjaWFsIFxuXHRsZXQgc3BlY2lhbE9uID0gZmFsc2U7IFxuXG5cdGxldCBkZXNpZ25lckZpeGVkIDogRml4ZWRJdGVtRGVzaWduZXI7XG5cdGxldCBkZXNpZ25lckRlcml2ZWQgOiBEZXJpdmVkSXRlbURlc2lnbmVyO1xuXHRmdW5jdGlvbiBkZXNpZ25lclVJVXBkYXRlKCl7XG5cdFx0ZGVzaWduZXJEZXJpdmVkPy5mb3JjZVVwZGF0ZSgpO1xuXHRcdGRlc2lnbmVyRml4ZWQ/LmZvcmNlVXBkYXRlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBfY29sU2VsZWN0KCBncnA6J2Rlcml2ZWQnfCdmaXhlZCcgLCBjb2wgOiAgVUlDb2xsZWN0aW9uXHR8bnVsbHxhbnkpe1xuXHRcdF9ub2RTZWxlY3QoZ3JwLG51bGwpO1xuXG5cdFx0XG5cdFx0aWYgKGdycCA9PSAnZGVyaXZlZCcpIHtcblx0XHRcdC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lciBmb3Igb2xkIFxuXHRcdFx0aWYgKGRlcml2ZWRDb2wpe1xuXHRcdFx0XHRkZXJpdmVkQ29sPy5yZW1vdmVFdmVudExpc3RlbmVyKGd1aWRLZXkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBzZXQgdmFyaWFibGUgYW5kIGV2ZW50IGxpc3RlbmVyXG5cdFx0XHRkZXJpdmVkQ29sID0gY29sOyBcblx0XHRcdGRlcml2ZWRDb2w/LmFkZEV2ZW50TGlzdGVuZXIoZ3VpZEtleSwgJ3VwZGF0ZScgLCgpID0+IHtcblx0XHRcdFx0ZGVyaXZlZENvbCA9IGRlcml2ZWRDb2w7XG5cdFx0XHR9KVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lciBmb3Igb2xkIFxuXHRcdFx0aWYgKGZpeGVkQ29sKXtcblx0XHRcdFx0Zml4ZWRDb2w/LnJlbW92ZUV2ZW50TGlzdGVuZXIoZ3VpZEtleSk7XG5cdFx0XHR9IFxuXG5cdFx0XHQvLyBzZXQgdmFyaWFibGUgYW5kIGV2ZW50IGxpc3RlbmVyXG5cdFx0XHRmaXhlZENvbCA9IGNvbDsgXG5cdFx0XHRmaXhlZENvbD8uYWRkRXZlbnRMaXN0ZW5lcihndWlkS2V5LCAndXBkYXRlJyAsKCkgPT4ge1xuXHRcdFx0XHRmaXhlZENvbCA9IGZpeGVkQ29sO1xuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gX25vZFNlbGVjdCggZ3JwOidkZXJpdmVkJ3wnZml4ZWQnICwgbm9kIDogVUlOb2RlIHxudWxsfGFueSl7XHRcdFxuXHRcdFxuXHRcdFxuXHRcdGlmIChncnAgPT0gJ2Rlcml2ZWQnKSB7XG5cdFx0XHRcblx0XHRcdGRlcml2ZWROb2Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoZ3VpZEtleSlcblx0XHRcdGRlcml2ZWROb2QgPSBub2Q7XG5cdFx0XHRkZXJpdmVkTm9kPy5hZGRFdmVudExpc3RlbmVyKGd1aWRLZXksJ3VwZGF0ZScsKCkgPT4ge1xuXHRcdFx0XHRkZXNpZ25lclVJVXBkYXRlKCk7XG5cdFx0XHR9KVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZpeGVkTm9kPy5yZW1vdmVFdmVudExpc3RlbmVyKGd1aWRLZXkpXG5cdFx0XHRmaXhlZE5vZCA9IG5vZDtcblx0XHRcdGZpeGVkTm9kPy5hZGRFdmVudExpc3RlbmVyKGd1aWRLZXksJ3VwZGF0ZScsKCkgPT4ge1xuXHRcdFx0XHRkZXNpZ25lclVJVXBkYXRlKCk7XG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9jb2xVcGRhdGVcdCggZ3JwOidkZXJpdmVkJ3wnZml4ZWQnICwgY29sQXJyIDogIFVJQ29sbGVjdGlvblx0W10pe1xuXHRcdGNvbEFyci5mb3JFYWNoKCBuICA9PiB7XG5cdFx0XHRpZiggbi5uYW1lICE9IG4ubmFtZUVkaXQpe1xuXHRcdFx0XHR1aVN5c3RlbS5yZW5hbWVDb2xsZWN0aW9uKCBncnAgLCBuLm5hbWUsIG4ubmFtZUVkaXQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiBfbm9kVXBkYXRlXHQoIGdycDonZGVyaXZlZCd8J2ZpeGVkJyAsIG5vZEFyciA6ICBVSU5vZGVcdFx0XHRbXSl7XG5cdFx0XG5cdFx0XG5cdFx0bGV0IGNvbCA9IGdycCA9PSAnZGVyaXZlZCcgPyBkZXJpdmVkQ29sIDogZml4ZWRDb2w7XG5cdFx0aWYgKCFjb2wpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRub2RBcnIuZm9yRWFjaCggbiAgPT4ge1xuXHRcdFx0aWYobi5uYW1lICE9IG4ubmFtZUVkaXQpe1xuXHRcdFx0XHR1aVN5c3RlbS5yZW5hbWVOb2RlKCBncnAgLCBjb2wubmFtZSAsIG4ubmFtZSwgbi5uYW1lRWRpdCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y29uc3QgZGVzaWduZXJLZXkgPSAnc3lzRGVzaWduZXInXG5cdG9uTW91bnRcdFx0KCgpPT57XG5cdFx0ZGVyaXZlZEdycD8uYWRkRXZlbnRMaXN0ZW5lcihkZXNpZ25lcktleSwndXBkYXRlJywoKT0+e1xuXHRcdFx0X2NvbFNlbGVjdCgnZGVyaXZlZCcsbnVsbCk7XG5cdFx0XHRcblx0XHR9KVxuXHR9KVxuXHRvbkRlc3Ryb3lcdCgoKT0+e1xuXHRcdGRlcml2ZWRHcnA/LnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVzaWduZXJLZXkpO1xuXHR9KVxuXG5cdGxldCBtZXNzYWdlSGFuZGxlciA6IFN0YXRpY01lc3NhZ2VIYW5kbGVyO1xuXG48L3NjcmlwdD5cbjxkaXY+XG5cdDxTdGF0aWNNZXNzYWdlSGFuZGxlciBcblx0XHRiaW5kOnRoaXM9e21lc3NhZ2VIYW5kbGVyfVxuXHQvPlxuXHRcblx0eyNpZiBzcGVjaWFsT259XG5cdFx0PGRpdiA+XG5cdFx0XHQ8RGVyaXZlZENvbGxlY3Rpb25EZXNpZ25lciBcblx0XHRcdFx0Y29udGV4dD17Y29udGV4dH1cblx0XHRcdFx0c3lzdGVtPXt1aVN5c3RlbX1cblx0XHRcdFx0c2Vjb25kU2xpZGVJblJlYWR5PXt0cnVlfVxuXHRcdFx0XHRtZXNzYWdlSGFuZGxlciA9IHttZXNzYWdlSGFuZGxlcn1cblx0XHRcdFx0b246Y2xvc2U9eyAoKSA9PiB7c3BlY2lhbE9uID0gZmFsc2V9IH1cblx0XHRcdC8+XG5cdFx0PC9kaXY+XG5cdHs6ZWxzZX1cblx0XHQ8ZGl2IHRyYW5zaXRpb246c2xpZGV8bG9jYWw+XG5cdFx0XHQ8VG9vZ2xlU2VjdGlvbiBcblx0XHRcdFx0dGl0bGU9XCJmaXhlZFwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGgxPkZpeGVkIEl0ZW0gRGVzaWduPC9oMT5cblx0XHRcdFx0XHQ8cD5cblx0XHRcdFx0XHRcdEZpeGVkIHByb3BlcnRpZXMgYXJlIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmllbmQgb24gZWFjaCBhcnRpY2xlJ3MgbWV0YSBkYXRhLlxuXHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXYgc3R5bGU9XCJkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjFmciAxZnI7Z2FwOjEwcHg7YWxpZ24taXRlbXM6IHN0YXJ0O1wiID5cblx0XHRcdFx0XHQ8RWRpdEFibGVMaXN0MiBcblx0XHRcdFx0XHRcdGNvbGxlY3Rpb249eyBmaXhlZEdycD8uY29sbGVjdGlvbnMgPz8gW10gfVxuXHRcdFx0XHRcdFx0b25TZWxlY3QgICAgXHQ9eyAoZSkgPT4geyBfY29sU2VsZWN0KCdmaXhlZCcsZSk7IHJldHVybiB0cnVlIH19XG5cdFx0XHRcdFx0XHRvbkFkZCAgICAgICBcdD17ICggKSA9PiB7IHVpU3lzdGVtLmFkZENvbGxlY3Rpb24oJ2ZpeGVkJykgfX1cblx0XHRcdFx0XHRcdG9uVXBkYXRlSXRlbVx0PXsgKGFycik9PnsgX2NvbFVwZGF0ZSgnZml4ZWQnLCBhcnIgKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdFx0XHRcdG9uRGVsZXRlSXRlbVx0PXsgKGUpID0+IHsgdWlTeXN0ZW0ucmVtQ29sbGVjdGlvbignZml4ZWQnLGUubmFtZSk7IGlmKGUua2V5ID09IGRlcml2ZWRDb2w/LmtleSl7IF9jb2xTZWxlY3QoJ2ZpeGVkJyxudWxsKX19fSBcblx0XHRcdFx0XHRcdG9uOm9uRGVTZWxlY3RcdD17ICggKSA9PiB7IF9jb2xTZWxlY3QoJ2ZpeGVkJyxudWxsKTsgfX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxFZGl0QWJsZUxpc3QyIFxuXHRcdFx0XHRcdFx0ZGlzYWJsZWQgPSB7IGZpeGVkQ29sID09IG51bGwgfVxuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbj17IGZpeGVkQ29sPy5ub2RlcyA/PyBbXSB9XG5cdFx0XHRcdFx0XHRvblNlbGVjdCAgICBcdD17IChlKSA9PiB7IF9ub2RTZWxlY3QoJ2ZpeGVkJyxlKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdFx0XHRcdG9uQWRkICAgICAgIFx0PXsgKCApID0+IHsgdWlTeXN0ZW0uYWRkTm9kZSgnZml4ZWQnICwgZml4ZWRDb2w/Lm5hbWUgKSAgfX1cblx0XHRcdFx0XHRcdG9uVXBkYXRlSXRlbVx0PXsgKGFycik9PnsgX25vZFVwZGF0ZSgnZml4ZWQnLCBhcnIgKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdFx0XHRcdG9uRGVsZXRlSXRlbVx0PXsgKGUpID0+IHsgdWlTeXN0ZW0ucmVtTm9kZSgnZml4ZWQnLGZpeGVkQ29sPy5uYW1lID8/ICcnLCBlLm5hbWUgKTsgaWYoZS5rZXkgPT0gZml4ZWROb2Q/LmtleSl7IF9ub2RTZWxlY3QoJ2ZpeGVkJyxudWxsKX0gfX0gXG5cdFx0XHRcdFx0XHRvbjpvbkRlU2VsZWN0XHQ9eyAoICkgPT4geyBfbm9kU2VsZWN0KCdmaXhlZCcsbnVsbCk7fX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0eyNpZiBmaXhlZE5vZCB9XG5cdFx0XHRcdFx0eyNrZXkgZml4ZWROb2Q/LmtleX1cblx0XHRcdFx0XG5cdFx0XHRcdFx0XHQ8ZGl2IHRyYW5zaXRpb246c2xpZGUgPlxuXHRcdFx0XHRcdFx0XHQ8Rml4ZWRJdGVtRGVzaWduZXIgXG5cdFx0XHRcdFx0XHRcdFx0YmluZDp0aGlzPXtkZXNpZ25lckZpeGVkfVxuXHRcdFx0XHRcdFx0XHRcdG5vZGVcdD0ge2ZpeGVkTm9kfVxuXHRcdFx0XHRcdFx0XHRcdHN5c3RlbVx0PSB7dWlTeXN0ZW19XG5cdFx0XHRcdFx0XHRcdFx0bWVzc2FnZUhhbmRsZXIgPSB7bWVzc2FnZUhhbmRsZXJ9XG5cdFx0XHRcdFx0XHRcdFx0b246c2F2ZT17KGUpPT57IFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGUuZGV0YWlsOyAgXG5cdFx0XHRcdFx0XHRcdFx0XHQvL3N5c3RlbS5yZW5hbWVJdGVtKCdmaXhlZCcsZml4ZWRDb2w/Lm5hbWU/PyAnJyxkYXRhLm9sZE5hbWUsIGRhdGEubmV3TmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHsva2V5fVxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9Ub29nbGVTZWN0aW9uPlxuXG5cdFx0XHQ8VG9vZ2xlU2VjdGlvbiBcblx0XHRcdFx0dGl0bGU9XCJkZXJpdmVkXCJcblx0XHRcdD5cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHQ8aDE+RGVyaXZlZCBJdGVtIERlc2lnbjwvaDE+XG5cdFx0XHRcdFx0PHA+XG5cdFx0XHRcdFx0XHREZXJpdmVkIHByb3BlcnRpZXMgYXJlIHRoZSBkYXRhLCB0aGF0IGFyZSBkZXJpdmVkIGZyb20gZml4ZWREYXRhXG5cdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBzdHlsZT1cImRpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6MWZyIDFmcjtnYXA6MTBweDthbGlnbi1pdGVtczogc3RhcnQ7XCIgPlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0PEVkaXRBYmxlTGlzdDIgXG5cdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb249eyBkZXJpdmVkR3JwPy5jb2xsZWN0aW9ucyA/PyBbXSB9XG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0ICAgIFx0PXsgKGUpID0+IHsgX2NvbFNlbGVjdCgnZGVyaXZlZCcsZSk7IHJldHVybiB0cnVlIH19XG5cdFx0XHRcdFx0XHRcdG9uQWRkICAgICAgIFx0PXsgKCApID0+IHsgIHVpU3lzdGVtLmFkZENvbGxlY3Rpb24oJ2Rlcml2ZWQnKSB9fVxuXHRcdFx0XHRcdFx0XHRvblVwZGF0ZUl0ZW1cdD17IChhcnIpPT57IF9jb2xVcGRhdGUoJ2Rlcml2ZWQnLCBhcnIgKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdFx0XHRcdFx0b25EZWxldGVJdGVtXHQ9eyAoZSkgPT4geyB1aVN5c3RlbS5yZW1Db2xsZWN0aW9uKCdkZXJpdmVkJyxlLm5hbWUpIDsgaWYoZS5rZXkgPT0gZGVyaXZlZENvbD8ua2V5KXsgX2NvbFNlbGVjdCgnZGVyaXZlZCcsbnVsbCl9IH19IFxuXHRcdFx0XHRcdFx0XHRvblNwZWNpYWxBZGRcdD17ICggKSA9PiB7IHNwZWNpYWxPbiA9ICFzcGVjaWFsT247IH19XG5cdFx0XHRcdFx0XHRcdG9uOm9uRGVTZWxlY3RcdD17ICggKSA9PiB7IF9jb2xTZWxlY3QoJ2Rlcml2ZWQnLG51bGwpO319XG5cdFx0XHRcdFx0XHQvPiBcblx0XHRcdFx0XHRcdDxFZGl0QWJsZUxpc3QyIFxuXHRcdFx0XHRcdFx0XHRkaXNhYmxlZCA9IHsgZGVyaXZlZENvbCA9PSBudWxsIH1cblx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbj17IGRlcml2ZWRDb2w/Lm5vZGVzID8/IFtdIH1cblx0XHRcdFx0XHRcdFx0b25TZWxlY3QgICAgXHQ9eyAoZSkgPT4geyBcblx0XHRcdFx0XHRcdFx0XHRfbm9kU2VsZWN0KCdkZXJpdmVkJyxlKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0XHRvbkFkZCAgICAgICBcdD17ICggKSA9PiB7IHVpU3lzdGVtLmFkZE5vZGUoJ2Rlcml2ZWQnICwgZGVyaXZlZENvbD8ubmFtZSApICB9fVxuXHRcdFx0XHRcdFx0XHRvblVwZGF0ZUl0ZW1cdD17IChhcnIpPT57IF9ub2RVcGRhdGUoJ2Rlcml2ZWQnLCBhcnIgKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdFx0XHRcdFx0b25EZWxldGVJdGVtXHQ9eyAoZSkgPT4geyB1aVN5c3RlbS5yZW1Ob2RlKCdkZXJpdmVkJyxkZXJpdmVkQ29sPy5uYW1lID8/ICcnLCBlLm5hbWUgKTsgaWYoZS5rZXkgPT0gZGVyaXZlZE5vZD8ua2V5KXsgX25vZFNlbGVjdCgnZGVyaXZlZCcsbnVsbCl9IH19IFxuXHRcdFx0XHRcdFx0XHRvbjpvbkRlU2VsZWN0XHQ9eyAoICkgPT4geyB9fVxuXHRcdFx0XHRcdFx0Lz4gXG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7I2lmIGRlcml2ZWROb2QgfVxuXHRcdFx0XHRcdHsja2V5IGRlcml2ZWROb2Q/LmtleX1cblx0XHRcdFx0XG5cdFx0XHRcdFx0XHQ8ZGl2IHRyYW5zaXRpb246c2xpZGUgPlxuXHRcdFx0XHRcdFx0XHQ8RGVyaXZlZEl0ZW1EZXNpZ25lciBcblx0XHRcdFx0XHRcdFx0XHRiaW5kOnRoaXM9e2Rlc2lnbmVyRGVyaXZlZH1cblx0XHRcdFx0XHRcdFx0XHRub2RlXHQ9IHtkZXJpdmVkTm9kfVxuXHRcdFx0XHRcdFx0XHRcdHN5c3RlbVx0PSB7dWlTeXN0ZW19XG5cdFx0XHRcdFx0XHRcdFx0Y29udGV4dCA9IHtjb250ZXh0fVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0ey9rZXl9XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L1Rvb2dsZVNlY3Rpb24+XG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG5cdDwhLS1cblx0PGRpdiBzdHlsZT1cImRpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6MWZyIDFmciAxZnI7Z2FwOjEwcHg7XCIgPlxuXHRcdDxFZGl0QWJsZUxpc3QyIFxuXHRcdFx0Y29sbGVjdGlvbj17IHVpU3lzdGVtLmdyb3VwcyB9XG5cdFx0XHRvblNlbGVjdCAgICBcdD17IChlKSA9PiB7IGdycFNlbGVjdChlKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uQWRkICAgICAgIFx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uVXBkYXRlSXRlbVx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uRGVsZXRlSXRlbVx0PXsgKGUpID0+IHsgcmV0dXJuIHRydWUgfX0gXG5cdFx0XHRvbjpvbkRlU2VsZWN0XHQ9eyAoICkgPT4geyB9fVxuXHRcdC8+XG5cdFx0PEVkaXRBYmxlTGlzdDIgXG5cdFx0XHRjb2xsZWN0aW9uPXsgZ3JwU2VsPy5jb2xsZWN0aW9ucyA/PyBbXSB9XG5cdFx0XHRvblNlbGVjdCAgICBcdD17IChlKSA9PiB7IGNvbFNlbGVjdChlKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uQWRkICAgICAgIFx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uVXBkYXRlSXRlbVx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uRGVsZXRlSXRlbVx0PXsgKGUpID0+IHsgcmV0dXJuIHRydWUgfX0gXG5cdFx0XHRvbjpvbkRlU2VsZWN0XHQ9eyAoICkgPT4geyB9fVxuXHRcdC8+XG5cdFx0PEVkaXRBYmxlTGlzdDIgXG5cdFx0XHRjb2xsZWN0aW9uPXsgY29sU2VsPy5ub2RlcyA/PyBbXSB9XG5cdFx0XHRvblNlbGVjdCAgICBcdD17IChlKSA9PiB7IG5vZFNlbGVjdChlKTsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uQWRkICAgICAgIFx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uVXBkYXRlSXRlbVx0PXsgKCApID0+IHsgcmV0dXJuIHRydWUgfX1cblx0XHRcdG9uRGVsZXRlSXRlbVx0PXsgKGUpID0+IHsgcmV0dXJuIHRydWUgfX0gXG5cdFx0XHRvbjpvbkRlU2VsZWN0XHQ9eyAoICkgPT4geyB9fVxuXHRcdC8+XG5cblxuXHQ8L2Rpdj5cblx0LS0+XG5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0aW1wb3J0IEVkaXRBYmxlTGlzdCBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9lZGl0QWJsZUxpc3QvRWRpdEFibGVMaXN0LnN2ZWx0ZVwiO1xuXG5cdGNsYXNzIHN1YnBhZ2VzIHtcblx0XHRwdWJsaWMgc3RhdGljIGltcG9ydGVyID0gJ2ltcG9ydGVyJztcblx0XHRwdWJsaWMgc3RhdGljIGV4cG9ydGVyID0gJ2V4cG9ydGVyJztcblx0fVxuXG5cdGxldCBzdWJwYWdlIDogc3RyaW5nID0gJyc7XG5cdGZ1bmN0aW9uIGVuYWJsZVN1YlBhZ2UoIF9zdWJwYWdlIDogc3RyaW5nICl7IFxuXHRcdHN1YnBhZ2UgPSBfc3VicGFnZTtcblx0fVxuPC9zY3JpcHQ+XG48ZGl2PlxuXHR7I2lmIHN1YnBhZ2UgPT0gXCJcIn1cblx0XHQ8ZGl2IHRyYW5zaXRpb246c2xpZGV8bG9jYWwgPlxuXHRcdFx0PHNlY3Rpb24+XG5cdFx0XHRcdDxicj5cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHQ8Yj5VSS10aGVtZSdzPC9iPlxuXHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHQ8cD4gYXV0aG9yIDogPC9wPlxuXHRcdFx0XHRcdFx0PHA+IHZlcnNpb24gOiA8L3A+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdDxFZGl0QWJsZUxpc3Rcblx0XHRcdFx0XHRcdGlzRWRpdGFibGVDb250YWluZXI9e2ZhbHNlfVxuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbj0geyBbJ3RoZW1lIC0gQScsJ3RoZW1lIC0gQicsJ3RoZW1lIC0gQyddIH1cblx0XHRcdFx0XHRcdG9uU2VsZWN0PXsgKGUpID0+IHsgcmV0dXJuIHRydWU7IH0gfSBcblx0XHRcdFx0XHRcdG9uOm9uRGVTZWxlY3Q9eyAoKT0+e30gfVxuXHRcdFx0XHRcdC8+IFxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvc2VjdGlvbj4gIFxuXHRcdFx0PGJyPlxuXHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJTeXN0ZW1FeHBvcnRlck9wdGlvbnNcIj5cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHQ8YnV0dG9uIFxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJTeXN0ZW1FeHBvcnRlckJ1dHRvblwiXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+e2VuYWJsZVN1YlBhZ2Uoc3VicGFnZXMuZXhwb3J0ZXIpfSB9XG5cdFx0XHRcdFx0XHRvbjprZXlwcmVzc1xuXHRcdFx0XHRcdD4gXG5cdFx0XHRcdFx0XHRFeHBvcnQgTmV3IFVJIFByb2plY3Rcblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0dXNlIHRoaXMgYXMgYSBiYXNlIGZvciBhIHVpIHRoZW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGNoYXJhY3RlciBzaGVldHMuIFxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHQ8YnV0dG9uIFxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJTeXN0ZW1FeHBvcnRlckJ1dHRvblwiXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17ICgpID0+ZW5hYmxlU3ViUGFnZShzdWJwYWdlcy5pbXBvcnRlcikgfVxuXHRcdFx0XHRcdFx0b246a2V5cHJlc3Ncblx0XHRcdFx0XHQ+IFxuXHRcdFx0XHRcdFx0SW1wb3J0IGEgVUkgcHJvamVjdFxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRjbGljayBoZXIsIHRvIE9wZW4gSW1wb3J0ZXIuIFxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFxuXHRcdFx0PC9zZWN0aW9uPiAgXG5cdFx0XHQ8c2VjdGlvbj5cblx0XHRcdFx0PGJyPlxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdGNsaWNrIGhlciwgdG8gT3BlbiBJbXBvcnRlci4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gPGJyPjxicj5cblx0XHRcdFx0XHRkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLiBkZXRhaWxzIC4uLi4gZGV0YWlscyAuLi4uIGRldGFpbHMgLi4uLlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvc2VjdGlvbj5cblx0XHQ8L2Rpdj5cblx0ezplbHNlIGlmIHN1YnBhZ2UgPT0gc3VicGFnZXMuZXhwb3J0ZXIgfVxuXHRcdDxkaXYgdHJhbnNpdGlvbjpzbGlkZXxsb2NhbCA+XG5cdFx0XHQ8c2VjdGlvbj5cblx0XHRcdFx0PGRpdiBcblx0XHRcdFx0XHRjbGFzcz1cIlN5c3RlbUV4cG9ydGVyT3B0aW9uc0Nsb3NlQnRuXCJcblx0XHRcdFx0XHRvbjpjbGljaz17KCk9PmVuYWJsZVN1YlBhZ2UoJycpfSBcblx0XHRcdFx0XHRvbjprZXlwcmVzcyBcblx0XHRcdFx0PlxuXHRcdFx0XHRcdFhcblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdHVzZSB0aGlzIGFzIGEgYmFzZSBmb3IgYSB1aSB0aGVtZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBjaGFyYWN0ZXIgc2hlZXRzLiBcblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFxuXHRcdFx0PC9zZWN0aW9uPiAgXG5cdFx0PC9kaXY+XG5cdHs6ZWxzZSBpZiBzdWJwYWdlID09IHN1YnBhZ2VzLmltcG9ydGVyIH1cblx0XHQ8ZGl2IHRyYW5zaXRpb246c2xpZGV8bG9jYWwgPlxuXHRcdFx0PHNlY3Rpb24+XG5cdFx0XHRcdDxkaXYgXG5cdFx0XHRcdFx0Y2xhc3M9XCJTeXN0ZW1FeHBvcnRlck9wdGlvbnNDbG9zZUJ0blwiXG5cdFx0XHRcdFx0b246Y2xpY2s9eygpPT5lbmFibGVTdWJQYWdlKCcnKX1cblx0XHRcdFx0XHRvbjprZXlwcmVzc1xuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0WFxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0dXNlIHRoaXMgYXMgYSBiYXNlIGZvciBhIHVpIHRoZW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGNoYXJhY3RlciBzaGVldHMuIFxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XG5cdFx0XHQ8L3NlY3Rpb24+ICBcblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuXG5cdGltcG9ydCBFZGl0QWJsZUxpc3QgZnJvbSBcdFx0XHRcdFx0XCIuLi8uLi8uLi8uLi9Db21wb25lbnRzL2VkaXRBYmxlTGlzdC9FZGl0QWJsZUxpc3Quc3ZlbHRlXCI7IFxuICAgIGltcG9ydCBTdGF0aWNNZXNzYWdlSGFuZGxlciBmcm9tIFx0XHRcdFwiLi4vLi4vLi4vLi4vQ29tcG9uZW50cy9NZXNzYWdlcy9TdGF0aWNNZXNzYWdlSGFuZGxlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBXcml0YWJsZSwgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG4gICAgaW1wb3J0IHsgZmFkZSwgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgICBpbXBvcnQgeyBMYXlvdXQwMUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vY29udGV4dFwiO1xuICAgIGltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFx0XCIuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy9ncmFwaERlc2lnbmVyL2luZGV4XCI7XG4gICAgaW1wb3J0IHsgU3lzdGVtUHJldmlldyB9IGZyb20gXHRcdFx0XHRcIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9Nb2R1bGVzL2NvcmUvbW9kZWwvc3lzdGVtUHJldmlld1wiO1xuICAgIFxuICAgIGltcG9ydCBNZW51IGZyb20gXCIuLi9NZW51L01lbnUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgcGFnZVNsaWRlIH0gZnJvbSBcdFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvdWkvQ29tcG9uZW50cy9UcmFuc2l0aW9ucy9wYWdlU2xpZGVcIjtcbiAgICBpbXBvcnQgU3lzdGVtRGVzaWduZXIzUGFydHMgZnJvbSBcIi4vU3lzdGVtUGFnZS9TeXN0ZW1EZXNpZ25lci9TeXN0ZW1EZXNpZ25lcjNQYXJ0cy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgU3lzdGVtRXhwb3J0ZXIgZnJvbSBcIi4vU3lzdGVtUGFnZS9TeXN0ZW1FeHBvcnRlci9TeXN0ZW1FeHBvcnRlci5zdmVsdGVcIjtcbiAgICBcblx0ZXhwb3J0IGxldCBjb250ZXh0XHQ6IExheW91dDAxQ29udGV4dDsgXG5cdGxldCBhY3RpdmVTeXN0ZW0gOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nID0gY29udGV4dC5hY3RpdmVTeXN0ZW07XG5cdGxldCBhdmFpbFN5c3RlbXMgOiBTeXN0ZW1QcmV2aWV3W10gPSBbXTtcblx0XG5cdGNvbnN0IG51bGxwcmV2aWV3ID0gbmV3IFN5c3RlbVByZXZpZXcoKTtcblx0bGV0IGFjdGl2ZVByZXZpZXc6IFN5c3RlbVByZXZpZXcgPSBudWxscHJldmlldztcblx0bGV0IHVua25vd25TdHJpbmcgPSAndW5rbm93bic7XG5cblx0bGV0IGZhY3RvcnkgOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cdFxuXG4gXG5cdG9uTW91bnQoICgpID0+IHtcblx0XHRhdmFpbFN5c3RlbXMgPSBjb250ZXh0LmF2YWlsYWJsZVByZXZpZXdzID8/IFtdO1xuXHRcdGxvYWRBbGxTeXN0ZW1zKCk7XG5cdH0pXG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZEFsbFN5c3RlbXMoKXtcblx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBjb250ZXh0LkFQSS5nZXRBbGxTeXN0ZW1zKCk7XG5cdFx0Y29udGV4dC5hdmFpbGFibGVQcmV2aWV3cyA9IHJlc3BvbnNlLnJlc3BvbnNlO1xuXHRcdGF2YWlsU3lzdGVtcyA9IHJlc3BvbnNlLnJlc3BvbnNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gdW5sb2FkUHJldmlldygpe1xuXHRcdGFjdGl2ZVByZXZpZXcgPSBudWxscHJldmlld1xuXHRcdGZhY3RvcnkgPSBudWxsO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIG9uU2VsZWN0U3lzdGVtKCBkICl7XG5cdFx0Y29uc3QgcHJlID0gYXZhaWxTeXN0ZW1zLmZpbmQoIHAgPT4gcC5jb2RlID09IGQpOyBcblxuXHRcdC8vIGlmIG5vIHByZXZpZXcuLi4gdGhlbiBuby4gb3IgaWYgdGhlIHByZXZpZXcgaXMgdGhlIHNhbWUgYXMgYmVmb3JlIGRlc2VsY3QgaXRcblx0XHRpZiAoIGFjdGl2ZVByZXZpZXcgPT0gcHJlIHx8ICFwcmUpe1xuXHRcdFx0YWN0aXZlUHJldmlldyA9IG51bGxwcmV2aWV3O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBpdFxuXHRcdGFjdGl2ZVByZXZpZXcgPSBwcmU7XG5cblx0XHQvLyByZXF1ZXN0IHRoZSBmYWN0b3J5O1xuXHRcdGxldCByZXNwb25zZSA9IGF3YWl0IGNvbnRleHQuQVBJLmdldEZhY3RvcnkoIGFjdGl2ZVByZXZpZXcgKTtcblx0XHRmYWN0b3J5ID0gcmVzcG9uc2UucmVzcG9uc2U7XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRsZXQgcGFnZXNDb250YWluZXI7XG5cdGxldCBlZGl0UGFnZXMgPSBbJ2Rlc2lnbmVyJywnVUktZGVzaWduZXInXVxuXHRsZXQgYWN0aXZlU3ViUGFnZSA9ICdkZXNpZ25lcic7XG5cdGZ1bmN0aW9uIGNoYW5nZVBhZ2UoIGV2ZW50ICl7XG5cdFx0YWN0aXZlU3ViUGFnZSA9IGV2ZW50LmRldGFpbDtcblx0fVxuXHQvL0B0cy1pZ25vcmUgVGhpcyBpcyBmb3IgcmVuZGVyaW5nIHRoZSB1bmtub3duIHN0cm5pZ1xuXHRudWxscHJldmlldy5pc0VkaXRhYmxlID0gbnVsbDtcblxuXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIk1haW5BcHBDb250YWluZXJQYWdlIE1haW5BcHBDb250YWluZXJQYWdlU3lzdGVtXCI+XG5cdCBcblx0PHNlY3Rpb24+XG5cdFx0PGRpdiBjbGFzcz1cInRhYmxlIFN5c3RlbVByZXZpZXdlclwiIGRhdGEtaXMtZWRpdD17IGZhbHNlIH0gdHJhbnNpdGlvbjpmYWRlPlxuXHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiPkF1dGhvcjwvZGl2PiBcblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgPnthY3RpdmVQcmV2aWV3Py5hdXRob3IgPz8gdW5rbm93blN0cmluZ308L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiPlZlcnNpb248L2Rpdj4gXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiID57YWN0aXZlUHJldmlldz8udmVyc2lvbiA/PyB1bmtub3duU3RyaW5nfTwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCI+U3lzdGVtQ29kZU5hbWU8L2Rpdj4gXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiID57YWN0aXZlUHJldmlldz8uY29kZSA/PyB1bmtub3duU3RyaW5nfTwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCI+ZWRpdGFibGU8L2Rpdj4gXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd0NvbHVtblwiID57YWN0aXZlUHJldmlldz8uaXNFZGl0YWJsZSA/PyB1bmtub3duU3RyaW5nfTwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCI+U3lzdGVtTmFtZTwvZGl2PiBcblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgPnthY3RpdmVQcmV2aWV3Py5uYW1lID8/IHVua25vd25TdHJpbmd9PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZVJvd1wiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGVSb3dDb2x1bW5cIj5mb2xkZXIgbmFtZTwvZGl2PiBcblx0XHRcdFx0PGRpdiBjbGFzcz1cInRhYmxlUm93Q29sdW1uXCIgPnthY3RpdmVQcmV2aWV3Py5mb2xkZXJOYW1lID8/IHVua25vd25TdHJpbmd9PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblxuXHRcdDxicj5cblx0XHQ8IS0tIFN5c3RlbSBTZWxlY3RvciAtLT5cblx0XHQ8ZGl2IGNsYXNzPVwiUGFnZVN5c3RlbUxpc3RcIiA+XHRcblx0XHRcdDxFZGl0QWJsZUxpc3Rcblx0XHRcdFx0aXNFZGl0YWJsZUNvbnRhaW5lcj17ZmFsc2V9XG5cdFx0XHRcdGNvbGxlY3Rpb249IHsgYXZhaWxTeXN0ZW1zPy5tYXAoIHAgPT4ge3JldHVybiB7IGtleSA6IHAuY29kZSAsIHZhbHVlIDogcC5uYW1lfX0pID8/IFtdIH1cblx0XHRcdFx0b25TZWxlY3Q9eyAoZSkgPT4ge29uU2VsZWN0U3lzdGVtKGUpIDsgcmV0dXJuIHRydWU7IH0gfSBcblx0XHRcdFx0b246b25EZVNlbGVjdD17IHVubG9hZFByZXZpZXcgfVxuXHRcdFx0Lz4gXG5cdFx0PC9kaXY+ICBcblx0PC9zZWN0aW9uPlxuXHR7I2lmIGZhY3RvcnkgJiYgYWN0aXZlUHJldmlldyAhPSBudWxscHJldmlldyB9XG5cdFx0XG5cdFx0PHNlY3Rpb24gdHJhbnNpdGlvbjpzbGlkZSBiaW5kOnRoaXM9e3BhZ2VzQ29udGFpbmVyfSA+XG5cdFx0PE1lbnUgIFxuXHRcdFx0cmVndWxhck9wdGlvbnM9e2VkaXRQYWdlc31cblx0XHRcdG9uOmNoYW5nZVBhZ2U9e2NoYW5nZVBhZ2V9XG5cdFx0XHRzdGFydENob3Nlbj17YWN0aXZlU3ViUGFnZX1cdFxuXHRcdC8+IFxuXHRcdHsjaWYgYWN0aXZlU3ViUGFnZSA9PSAnZGVzaWduZXInfVxuXHRcdFx0PGRpdiB0cmFuc2l0aW9uOnBhZ2VTbGlkZT17e3BhcmVudDpwYWdlc0NvbnRhaW5lcn19ID5cblx0XHRcdFx0PFN5c3RlbURlc2lnbmVyM1BhcnRzIFxuXHRcdFx0XHRcdHN5c3RlbVx0PXsgZmFjdG9yeSB9XG5cdFx0XHRcdFx0Y29udGV4dCA9eyBjb250ZXh0IH1cblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXHRcdHs6ZWxzZSBpZiBhY3RpdmVTdWJQYWdlID09ICdVSS1kZXNpZ25lcid9XG5cdFx0XHQ8ZGl2IHRyYW5zaXRpb246cGFnZVNsaWRlPXt7cGFyZW50OnBhZ2VzQ29udGFpbmVyfX0gPlxuXHRcdFx0XHQ8U3lzdGVtRXhwb3J0ZXIgXG5cdFx0XHRcdFxuXHRcdFx0XHQvPlxuXHRcdFx0PC9kaXY+XG5cdFx0ezplbHNlIGlmIGFjdGl2ZVN1YlBhZ2UgPT0gJ3Rlc3QnfVxuXHRcdFx0PGRpdiB0cmFuc2l0aW9uOnBhZ2VTbGlkZT17e3BhcmVudDpwYWdlc0NvbnRhaW5lcn19ID5cblx0XHRcdFx0PGgxPmFzZGFkc2Fkc2FzZGFkc2FzZGF1dXV1aDwvaDE+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHRcdDwvc2VjdGlvbj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+IFxuXHRpbXBvcnQgeyBmbHksIHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuICAgIGltcG9ydCAnLi9EZXNpZ25lci5zY3NzJyAgXG4gICAgaW1wb3J0IEhvbWVQYWdlIGZyb20gJy4vVmlld3MvUGFnZS9Ib21lUGFnZS5zdmVsdGUnO1xuICAgIGltcG9ydCBTeXN0ZW1QYWdlIGZyb20gJy4vVmlld3MvUGFnZS9TeXN0ZW1QYWdlLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuXHRpbXBvcnQgTWVudSBmcm9tICcuL1ZpZXdzL01lbnUvTWVudS5zdmVsdGUnO1xuICAgIGltcG9ydCB7IExheW91dDAxQ29udGV4dCB9IGZyb20gJy4vY29udGV4dCc7XG5cdGltcG9ydCB7cGFnZVNsaWRlfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvTW9kdWxlcy91aS9Db21wb25lbnRzL1RyYW5zaXRpb25zL3BhZ2VTbGlkZS5qcyc7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0bGV0IHBhZ2UgPSB3cml0YWJsZSggJ3N5c3RlbScpO1xuXHRleHBvcnQgbGV0IGNvbnRleHRcdDogTGF5b3V0MDFDb250ZXh0OyBcblx0bGV0IG1haW5BcHBDb250YWluZXI7XG5cdFxuXHRmdW5jdGlvbiBjaGFuZ2VQYWdlKCBldmVudCApe1xuXHRcdHBhZ2Uuc2V0KGV2ZW50LmRldGFpbCk7ICBcblx0fVxuXG5cdG9uTW91bnQoKCk9Pntcblx0XHRjb250ZXh0Lm1haW5BcHBDb250YWluZXIgPSBtYWluQXBwQ29udGFpbmVyO1xuXHR9KVxuXG5cdGxldCBwYWdlc0NvbnRhaW5lcjtcbiA8L3NjcmlwdD5cbjxkaXYgaWQ9XCJNYWluQXBwQ29udGFpbmVyXCIgYmluZDp0aGlzPXttYWluQXBwQ29udGFpbmVyfT5cblx0XG5cdDwhLS0gTWVudSAtLT5cblx0PE1lbnUgXG5cdFx0dGl0bGU9eydUVFAtUlBHIFN5c3RlbSBEZXNpZ25lcid9XG5cdFx0cmVndWxhck9wdGlvbnM9e1snaG9tZScsJ3N5c3RlbScsJ2RhdGEgdGFibGVzJywnZXhwb3J0JywnaW1wb3J0J119XG5cdFx0b246Y2hhbmdlUGFnZT17Y2hhbmdlUGFnZX1cblx0XHRzdGFydENob3Nlbj17JHBhZ2V9XHRcblx0Lz4gXG5cdDxzZWN0aW9uIGNsYXNzPVwiTWFpbkFwcENvbnRhaW5lclBhZ2VzXCIgYmluZDp0aGlzPXtwYWdlc0NvbnRhaW5lcn0+XG5cdFx0eyNpZiBcdFx0JHBhZ2UgPT0gJ2hvbWUnfVxuXHRcdFx0PGRpdiB0cmFuc2l0aW9uOnBhZ2VTbGlkZT17e3BhcmVudDpwYWdlc0NvbnRhaW5lcn19ID5cblx0XHRcdFx0PEhvbWVQYWdlIC8+IFxuXHRcdFx0PC9kaXY+XG5cdFx0ezplbHNlIGlmXHQkcGFnZSA9PSAnc3lzdGVtJ31cblx0XHRcdDxkaXYgdHJhbnNpdGlvbjpwYWdlU2xpZGU9e3twYXJlbnQ6cGFnZXNDb250YWluZXJ9fT5cblx0XHRcdFx0PFN5c3RlbVBhZ2Vcblx0XHRcdFx0XHRjb250ZXh0ID0ge2NvbnRleHR9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7OmVsc2UgaWZcdCRwYWdlID09ICdob21lMSd9XG5cdFx0XHQ8cD4xPC9wPlxuXHRcdHs6ZWxzZSBpZlx0JHBhZ2UgPT0gJ2hvbWUyJ31cblx0XHRcdDxwPjE8L3A+XG5cdFx0ezplbHNlIGlmXHQkcGFnZSA9PSAnaG9tZTMnfVxuXHRcdFx0PHA+MTwvcD5cblx0XHR7L2lmfVxuXHQ8L3NlY3Rpb24+XG48L2Rpdj5cbjxzdHlsZT5cblx0I01haW5BcHBDb250YWluZXJ7XG5cdFx0Y29udGFpbmVyLXR5cGU6IGlubGluZS1zaXplOyAgXG5cdFx0bWluLWhlaWdodDogaW5oZXJpdDtcblx0fVxuPC9zdHlsZT4iLCJleHBvcnQgdmFyIEVfVElNRU9VVCA9IG5ldyBFcnJvcigndGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBtdXRleCB0byBiZWNvbWUgYXZhaWxhYmxlJyk7XG5leHBvcnQgdmFyIEVfQUxSRUFEWV9MT0NLRUQgPSBuZXcgRXJyb3IoJ211dGV4IGFscmVhZHkgbG9ja2VkJyk7XG5leHBvcnQgdmFyIEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoJ3JlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWQnKTtcbiIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEVfQ0FOQ0VMRUQgfSBmcm9tICcuL2Vycm9ycyc7XG52YXIgU2VtYXBob3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbWFwaG9yZShfdmFsdWUsIF9jYW5jZWxFcnJvcikge1xuICAgICAgICBpZiAoX2NhbmNlbEVycm9yID09PSB2b2lkIDApIHsgX2NhbmNlbEVycm9yID0gRV9DQU5DRUxFRDsgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsRXJyb3IgPSBfY2FuY2VsRXJyb3I7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVycyA9IFtdO1xuICAgIH1cbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAod2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHsgd2VpZ2h0ID0gMTsgfVxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IDA7IH1cbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3ZWlnaHQgXCIuY29uY2F0KHdlaWdodCwgXCI6IG11c3QgYmUgcG9zaXRpdmVcIikpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB7IHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0LCB3ZWlnaHQ6IHdlaWdodCwgcHJpb3JpdHk6IHByaW9yaXR5IH07XG4gICAgICAgICAgICB2YXIgaSA9IGZpbmRJbmRleEZyb21FbmQoX3RoaXMuX3F1ZXVlLCBmdW5jdGlvbiAob3RoZXIpIHsgcmV0dXJuIHByaW9yaXR5IDw9IG90aGVyLnByaW9yaXR5OyB9KTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSAmJiB3ZWlnaHQgPD0gX3RoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZHMgaW1tZWRpYXRlIGRpc3BhdGNoLCBza2lwIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwYXRjaEl0ZW0odGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLnJ1bkV4Y2x1c2l2ZSA9IGZ1bmN0aW9uIChjYWxsYmFja18xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChjYWxsYmFjaywgd2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICAgICAgdmFyIF9hLCB2YWx1ZSwgcmVsZWFzZTtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkgeyB3ZWlnaHQgPSAxOyB9XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIHZhbHVlID0gX2FbMF0sIHJlbGVhc2UgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCAsIDQsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNhbGxiYWNrKHZhbHVlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbWFwaG9yZS5wcm90b3R5cGUud2FpdEZvclVubG9jayA9IGZ1bmN0aW9uICh3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkgeyB3ZWlnaHQgPSAxOyB9XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gMDsgfVxuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHdlaWdodCBcIi5jb25jYXQod2VpZ2h0LCBcIjogbXVzdCBiZSBwb3NpdGl2ZVwiKSk7XG4gICAgICAgIGlmICh0aGlzLl9jb3VsZExvY2tJbW1lZGlhdGVseSh3ZWlnaHQsIHByaW9yaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICAgICAgaW5zZXJ0U29ydGVkKF90aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0sIHsgcmVzb2x2ZTogcmVzb2x2ZSwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbWFwaG9yZS5wcm90b3R5cGUuaXNMb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA8PSAwO1xuICAgIH07XG4gICAgU2VtYXBob3JlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH07XG4gICAgU2VtYXBob3JlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAod2VpZ2h0KSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkgeyB3ZWlnaHQgPSAxOyB9XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgd2VpZ2h0IFwiLmNvbmNhdCh3ZWlnaHQsIFwiOiBtdXN0IGJlIHBvc2l0aXZlXCIpKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgKz0gd2VpZ2h0O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnJlamVjdChfdGhpcy5fY2FuY2VsRXJyb3IpOyB9KTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9O1xuICAgIFNlbWFwaG9yZS5wcm90b3R5cGUuX2Rpc3BhdGNoUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9xdWV1ZVswXS53ZWlnaHQgPD0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0aGlzLl9xdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLl9kaXNwYXRjaEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZSAtPSBpdGVtLndlaWdodDtcbiAgICAgICAgaXRlbS5yZXNvbHZlKFtwcmV2aW91c1ZhbHVlLCB0aGlzLl9uZXdSZWxlYXNlcihpdGVtLndlaWdodCldKTtcbiAgICB9O1xuICAgIFNlbWFwaG9yZS5wcm90b3R5cGUuX25ld1JlbGVhc2VyID0gZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLl9kcmFpblVubG9ja1dhaXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIHZhciB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgd2FpdGVycy5mb3JFYWNoKGZ1bmN0aW9uICh3YWl0ZXIpIHsgcmV0dXJuIHdhaXRlci5yZXNvbHZlKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHF1ZXVlZFByaW9yaXR5XzEgPSB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIHZhciB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB3YWl0ZXJzLmZpbmRJbmRleChmdW5jdGlvbiAod2FpdGVyKSB7IHJldHVybiB3YWl0ZXIucHJpb3JpdHkgPD0gcXVldWVkUHJpb3JpdHlfMTsgfSk7XG4gICAgICAgICAgICAgICAgKGkgPT09IC0xID8gd2FpdGVycyA6IHdhaXRlcnMuc3BsaWNlKDAsIGkpKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZnVuY3Rpb24gKHdhaXRlcikgeyByZXR1cm4gd2FpdGVyLnJlc29sdmUoKTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZW1hcGhvcmUucHJvdG90eXBlLl9jb3VsZExvY2tJbW1lZGlhdGVseSA9IGZ1bmN0aW9uICh3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwIHx8IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5IDwgcHJpb3JpdHkpICYmXG4gICAgICAgICAgICB3ZWlnaHQgPD0gdGhpcy5fdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2VtYXBob3JlO1xufSgpKTtcbmZ1bmN0aW9uIGluc2VydFNvcnRlZChhLCB2KSB7XG4gICAgdmFyIGkgPSBmaW5kSW5kZXhGcm9tRW5kKGEsIGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gdi5wcmlvcml0eSA8PSBvdGhlci5wcmlvcml0eTsgfSk7XG4gICAgYS5zcGxpY2UoaSArIDEsIDAsIHYpO1xufVxuZnVuY3Rpb24gZmluZEluZGV4RnJvbUVuZChhLCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5leHBvcnQgZGVmYXVsdCBTZW1hcGhvcmU7XG4iLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VtYXBob3JlIGZyb20gJy4vU2VtYXBob3JlJztcbnZhciBNdXRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdXRleChjYW5jZWxFcnJvcikge1xuICAgICAgICB0aGlzLl9zZW1hcGhvcmUgPSBuZXcgU2VtYXBob3JlKDEsIGNhbmNlbEVycm9yKTtcbiAgICB9XG4gICAgTXV0ZXgucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgICAgICAgICAgdmFyIF9hLCByZWxlYXNlcjtcbiAgICAgICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9zZW1hcGhvcmUuYWNxdWlyZSgxLCBwcmlvcml0eSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgcmVsZWFzZXIgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZWxlYXNlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTXV0ZXgucHJvdG90eXBlLnJ1bkV4Y2x1c2l2ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUucnVuRXhjbHVzaXZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0sIDEsIHByaW9yaXR5KTtcbiAgICB9O1xuICAgIE11dGV4LnByb3RvdHlwZS5pc0xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICAgIH07XG4gICAgTXV0ZXgucHJvdG90eXBlLndhaXRGb3JVbmxvY2sgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUud2FpdEZvclVubG9jaygxLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgICBNdXRleC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpKVxuICAgICAgICAgICAgdGhpcy5fc2VtYXBob3JlLnJlbGVhc2UoKTtcbiAgICB9O1xuICAgIE11dGV4LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuY2FuY2VsKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTXV0ZXg7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgTXV0ZXg7XG4iLCJpbXBvcnQgUGx1Z2luSGFuZGxlciBmcm9tIFwiLi4vdWktb2JzaWRpYW4vYXBwXCI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlSGFuZGxlcntcblxuXHRwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2UgOiBGaWxlSGFuZGxlcjsgIFxuXHRwdWJsaWMgY29uc3RydWN0b3IoKXtcblx0XHRpZihGaWxlSGFuZGxlci5faW5zdGFuY2UgPT0gbnVsbCApe1xuXHRcdFx0RmlsZUhhbmRsZXIuX2luc3RhbmNlICA9IG5ldyBGaWxlSGFuZGxlcigpOyBcblx0XHR9XG5cdFx0cmV0dXJuIEZpbGVIYW5kbGVyLl9pbnN0YW5jZTtcblx0fVxuXG5cblx0Ly8gRm9sZGVyIEhhbmRsaW5nXG5cdHB1YmxpYyBzdGF0aWMgYXN5bmMgbWtkaXIgKCBwYXRoICl7XG5cdFx0cmV0dXJuIGF3YWl0IFBsdWdpbkhhbmRsZXIuQXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoIHBhdGggKTtcblx0fVxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIHJtZGlyKHBhdGg6c3RyaW5nKXsgXG5cdFx0cmV0dXJuIGF3YWl0IFBsdWdpbkhhbmRsZXIuQXBwLnZhdWx0LmFkYXB0ZXIucm1kaXIocGF0aCx0cnVlKTtcblx0fVxuXG5cblx0Ly8gUGF0aCBjb21tYW5kc1xuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGxzZGlyKCBwYXRoIDogc3RyaW5nICl7XG5cdFx0cmV0dXJuIGF3YWl0IFBsdWdpbkhhbmRsZXIuQXBwLnZhdWx0LmFkYXB0ZXIubGlzdChwYXRoKTtcblx0fVxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGV4aXN0cyggcGF0aCA6IHN0cmluZyApIDogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0cmV0dXJuIGF3YWl0IFBsdWdpbkhhbmRsZXIuQXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKCBwYXRoICwgZmFsc2UgKTtcblx0fVxuXG5cblx0Ly8gRmlsZSBDb21tYW5kcyBcblx0cHVibGljIHN0YXRpYyBhc3luYyBzYXZlRmlsZSggcGF0aCA6IHN0cmluZyAsIGZpbGVDb250ZW50OnN0cmluZyApeyBcblx0XHRyZXR1cm4gYXdhaXQgUGx1Z2luSGFuZGxlci5BcHAudmF1bHQuYWRhcHRlci53cml0ZShwYXRoLGZpbGVDb250ZW50KTtcblx0fVx0XG5cdHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVhZEZpbGUocGF0aDpzdHJpbmcpeyBcblx0XHRyZXR1cm4gYXdhaXQgUGx1Z2luSGFuZGxlci5BcHAudmF1bHQuYWRhcHRlci5yZWFkKHBhdGgpO1xuXHR9XG4gXG5cdHB1YmxpYyBzdGF0aWMgYXN5bmMgcm0ocGF0aDpzdHJpbmcpeyBcblx0XHRyZXR1cm4gYXdhaXQgUGx1Z2luSGFuZGxlci5BcHAudmF1bHQuYWRhcHRlci5yZW1vdmUocGF0aCk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGNvcHkocGF0aDpzdHJpbmcsIG5ld1BhdGg6c3RyaW5nICl7IFxuXHRcdHJldHVybiBhd2FpdCBQbHVnaW5IYW5kbGVyLkFwcC52YXVsdC5hZGFwdGVyLmNvcHkocGF0aCxuZXdQYXRoKTtcblx0fVxuXG59XG4iLCJpbXBvcnQgeyBKc29uQXJyYXlTdHJpbmcsIEpzb25Cb29sZWFuLCBKc29uUHJvcGVydHksIEpzb25TdHJpbmcgfSBmcm9tIFwiZ3JvYmF4LWpzb24taGFuZGxlclwiOyBcbmltcG9ydCB7IEZpbGVIYW5kbGVyIH0gZnJvbSBcIi4uL2ZpbGVIYW5kbGVyXCI7XG5pbXBvcnQgeyBrZXlNYW5hZ2VySW5zdGFuY2UgfSBmcm9tIFwidHRycGctc3lzdGVtLWdyYXBoXCI7XG5pbXBvcnQgUGx1Z2luSGFuZGxlciBmcm9tIFwiLi4vLi4vLi4vLi4vc3JjL01vZHVsZXMvdWktb2JzaWRpYW4vYXBwXCI7XG5pbXBvcnQgeyBCQVNFX1NDSEVNRSB9IGZyb20gXCJncm9iYXgtanNvbi1oYW5kbGVyXCI7XG4gXG5leHBvcnQgY2xhc3MgVUlMYXlvdXRNb2RlbFNjaGVtZXN7IFxuXHRzdGF0aWMgQkFTRSBcdD0gQkFTRV9TQ0hFTUUgO1xuXHRzdGF0aWMgUEFHRSBcdD0nUEFHRSc7IFxufVxuZXhwb3J0IGNsYXNzIFVJTGF5b3V0TW9kZWwge1xuXG5cdHB1YmxpYyBpZCA6IHN0cmluZyA9IGtleU1hbmFnZXJJbnN0YW5jZS5nZXROZXdLZXkoKTtcblxuXHRASnNvblN0cmluZyh7c2NoZW1lOltVSUxheW91dE1vZGVsU2NoZW1lcy5CQVNFLFVJTGF5b3V0TW9kZWxTY2hlbWVzLlBBR0VdfSlcblx0Z3VpZFx0OnN0cmluZyA9IFBsdWdpbkhhbmRsZXIudXVpZHY0KCk7XG5cblx0QEpzb25TdHJpbmcoe3NjaGVtZTpbVUlMYXlvdXRNb2RlbFNjaGVtZXMuQkFTRV19KVxuXHRhdXRob3JcdDpzdHJpbmc7XG5cdFxuXHRASnNvblN0cmluZyh7c2NoZW1lOltVSUxheW91dE1vZGVsU2NoZW1lcy5CQVNFXX0pXG5cdHZlcnNpb246c3RyaW5nO1xuXG5cdEBKc29uU3RyaW5nKHtzY2hlbWU6W1VJTGF5b3V0TW9kZWxTY2hlbWVzLkJBU0UsVUlMYXlvdXRNb2RlbFNjaGVtZXMuUEFHRV19KVxuXHRuYW1lXHQ6c3RyaW5nO1xuXHRcblx0QEpzb25TdHJpbmcoe3NjaGVtZTpbVUlMYXlvdXRNb2RlbFNjaGVtZXMuQkFTRV19KVxuXHRtYWluU3R5bGUgOiBzdHJpbmc7XG5cdFxuXHRASnNvblN0cmluZyh7c2NoZW1lOltVSUxheW91dE1vZGVsU2NoZW1lcy5CQVNFXX0pXG5cdGNvbXBvbmVudEpzXHQ6IHN0cmluZztcblxuXHRASnNvblN0cmluZyh7c2NoZW1lOltVSUxheW91dE1vZGVsU2NoZW1lcy5CQVNFXX0pXG5cdGZvbGRlclNyYzpTdHJpbmc7XG5cdHZhbGlkIDogYm9vbGVhbiA9IHRydWU7XG5cdGVycm9ycyA6IHN0cmluZ1tdID0gW107XG5cdFxuXHRwdWJsaWMgYXN5bmMgaXNWYWxpZCggICl7XG5cdFx0bGV0IGVycm9ycyA6IHN0cmluZyBbXSA9W107XG5cdFx0XG5cdFx0aWYgKCF0aGlzLmZvbGRlclNyYyl7XG5cdFx0XHRlcnJvcnMucHVzaChgVUlMYXlvdXRNb2RlbCBmb3IgJHt0aGlzLm5hbWV9IGJ5ICR7dGhpcy5hdXRob3J9LCBkaWQgbm90IGhhdmUgYSBmb2xkZXJTcmNgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXG5cdFx0Ly8gc2VlIGlmIHRoZSBKYXZhc2NyaXB0IGV4aXN0c1xuXHRcdGxldCBzcmMgPSB0aGlzLmZvbGRlclNyYyArJy8nK3RoaXMuY29tcG9uZW50SnM7XG5cdFx0bGV0IF8gPSBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMoIHNyYyApO1xuXHRcdGlmICggIV8gKXtcblx0XHRcdGVycm9ycy5wdXNoKGBVSUxheW91dE1vZGVsIGZvciAke3RoaXMubmFtZX0gYnkgJHt0aGlzLmF1dGhvcn0sIFBvaW50ZWQgdG8gYSBtaXNzaW5nIGZpbGUgJHtzcmN9YCk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHNlZSBpZiB0aGUgY3NzIGV4aXN0cyBcblx0XHRzcmMgPSB0aGlzLmZvbGRlclNyYyArJy8nK3RoaXMubWFpblN0eWxlO1xuXHRcdF8gPSBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMoIHNyYyApO1xuXHRcdGlmICggIV8gKXtcblx0XHRcdGVycm9ycy5wdXNoKGBVSUxheW91dE1vZGVsIGZvciAke3RoaXMubmFtZX0gYnkgJHt0aGlzLmF1dGhvcn0sIFBvaW50ZWQgdG8gYSBtaXNzaW5nIGZpbGUgJHtzcmN9YCk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMudmFsaWQgPSB2YWxpZDtcblx0XHRyZXR1cm4gdmFsaWQ7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgbG9hZGZpbGUoZmlsZSAsIGVycm9ycyA6IHN0cmluZyBbXSA9IFtdICl7XG5cdFx0Y29uc3Qgc3JjID0gdGhpcy5mb2xkZXJTcmMgKycvJytmaWxlO1xuXHRcdGxldCBfID0gYXdhaXQgRmlsZUhhbmRsZXIuZXhpc3RzKCBzcmMgKTtcblx0XHRpZiAoICFfICl7XG5cdFx0XHRlcnJvcnMucHVzaChgZmlsZSBhdCAke3NyY30gZGlkIG5vdCBleGlzdHNgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGxldCBmID0gYXdhaXQgRmlsZUhhbmRsZXIucmVhZEZpbGUoc3JjKTtcblx0XHRyZXR1cm4gZjtcblx0fVxufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tIFwiYXN5bmMtbXV0ZXhcIjtcbmltcG9ydCB7IEZpbGVIYW5kbGVyIH0gZnJvbSBcIi4vZmlsZUhhbmRsZXJcIjtcbmltcG9ydCB7IEpTT05IYW5kbGVyIH0gZnJvbSAnZ3JvYmF4LWpzb24taGFuZGxlcic7IFxuaW1wb3J0IHsgU3lzdGVtUHJldmlldyB9IGZyb20gXCIuL21vZGVsL3N5c3RlbVByZXZpZXdcIjtcbmltcG9ydCB7IGZvbGRlciB9IGZyb20gXCJqc3ppcFwiO1xuaW1wb3J0IHsgVUlMYXlvdXRNb2RlbCB9IGZyb20gXCIuL21vZGVsL1VJTGF5b3V0TW9kZWxcIjtcbmltcG9ydCBQbHVnaW5IYW5kbGVyIGZyb20gXCIuLi91aS1vYnNpZGlhbi9hcHBcIjtcbmltcG9ydCB7IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgfSBmcm9tIFwiLi4vZ3JhcGhEZXNpZ25lclwiO1xuXG50eXBlIGNvbW1hbmQgPSB7IGNvbW1hbmQ6J2ZpbGUnfCdmb2xkZXInICwgcGF0aDpzdHJpbmcsIGNvbnRlbnQ6c3RyaW5nIH1cbnR5cGUgbWVzc2FnZUxpc3QgPSBSZWNvcmQ8c3RyaW5nLGFueT47XG5cblxuZXhwb3J0IGNsYXNzIEZpbGVDb250ZXh0IHtcblxuXHRwcml2YXRlIHN0YXRpYyBtdXRleDpNdXRleCA9IG5ldyBNdXRleCgpO1xuXHRwcml2YXRlIHBhdGggOiBzdHJpbmcgOyBcblx0cHJpdmF0ZSBwbHVnaW5IYW5kbGVyO1xuXHQvLyBzaW5nbGV0b24gaW1wbGVtZW50YXRpb25cblx0cHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6RmlsZUNvbnRleHQ7XG5cdHByaXZhdGUgY29uc3RydWN0b3IocGx1Z2luSGFuZGxlcj8gOiBQbHVnaW5IYW5kbGVyKXtcblx0XHRcblx0XHRpZiAoIXRoaXMucGx1Z2luSGFuZGxlciAmJiAhcGx1Z2luSGFuZGxlcil7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGaXJzdCBnZXQgaW5zdGFuY2Ugb2YgRmlsZUNvbnRleHQsIG11c3QgaW5jbHVkZSBhIHBsdWdpbiBoYW5kbGVyJylcblx0XHR9IFxuXHRcdHRoaXMucGx1Z2luSGFuZGxlciA9IHBsdWdpbkhhbmRsZXI7XG5cdFxuXHRcdHRoaXMucGF0aCA9IFBsdWdpbkhhbmRsZXIuUExVR0lOX1JPT1QgKyAnLycgK1xuXHRcdFx0XHRcdFBsdWdpbkhhbmRsZXIuU1lTVEVNU19GT0xERVJfTkFNRTsgKyAnLycgO1xuXHR9XG5cdHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoIHBsdWdpbkhhbmRsZXI/IDogUGx1Z2luSGFuZGxlciApeyBcblx0XHRcblx0XHRpZighRmlsZUNvbnRleHQuaW5zdGFuY2Upe1xuXHRcdFx0RmlsZUNvbnRleHQuaW5zdGFuY2UgPSBuZXcgRmlsZUNvbnRleHQocGx1Z2luSGFuZGxlcik7XG5cdFx0fVxuXHRcdFxuXG5cdFx0cmV0dXJuIEZpbGVDb250ZXh0Lmluc3RhbmNlOyBcblx0fVxuXG5cdHB1YmxpYyBsb2FkZWRTeXN0ZW0gOiBzdHJpbmc7IFxuXHRwdWJsaWMgZm9sZGVyc1dpdGhOb0luZGV4OiBzdHJpbmdbXTtcblx0cHVibGljIGF2YWlsYWJsZVN5c3RlbXM6IFN5c3RlbVByZXZpZXdbXTsgXG5cblx0cHJpdmF0ZSBhc3luYyBpbml0U3lzdGVtc1N0cnVjdHVyZSgpeyBcblx0XHRpZiAoKCBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHModGhpcy5wYXRoKSkgKVxuXHRcdFx0cmV0dXJuOyBcblx0XHRGaWxlSGFuZGxlci5ta2Rpcih0aGlzLnBhdGgpOyBcblx0fVxuXG5cblx0cHJpdmF0ZSBhc3luYyBsb2FkUHJldmlld0FuZGZvbGRlcihmb2xkZXJQYXRoOnN0cmluZyl7XG5cdFx0Y29uc3QgaW5kZXhQYXRoID0gZm9sZGVyUGF0aCArICcvaW5kZXguanNvbic7XG5cdFx0Y29uc3QgZm9sZGVyTmFtZSA9IGZvbGRlclBhdGguc3BsaXQoJy8nKS5sYXN0KCk7XG5cdFx0bGV0IGV4aXN0cyA9IGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhpbmRleFBhdGgpXG5cdFx0aWYoIGV4aXN0cyApe1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IEZpbGVIYW5kbGVyLnJlYWRGaWxlKGluZGV4UGF0aCk7IFxuXHRcdFx0Y29uc3Qgc3lzdGVtUHJldmlldyA9IEpTT05IYW5kbGVyLmRlc2VyaWFsaXplKFN5c3RlbVByZXZpZXcsY29udGVudCk7XG5cdFx0XHRzeXN0ZW1QcmV2aWV3LmZvbGRlck5hbWVcdD0gZm9sZGVyTmFtZTtcblx0XHRcdHN5c3RlbVByZXZpZXcuZm9sZGVyUGF0aFx0PSBmb2xkZXJQYXRoO1xuXHRcdFx0c3lzdGVtUHJldmlldy5maWxlUGF0aFx0XHQ9IGluZGV4UGF0aDsgXG5cdFx0XHRyZXR1cm4gW3N5c3RlbVByZXZpZXcsZm9sZGVyTmFtZV1cblx0XHR9XG5cdFx0cmV0dXJuIFtudWxsLGZvbGRlck5hbWVdO1xuXHR9XG5cdHByaXZhdGUgYXN5bmMgbG9hZFByZXZpZXcoZm9sZGVyUGF0aDpzdHJpbmcpe1xuXHRcdHJldHVybiAoYXdhaXQgdGhpcy5sb2FkUHJldmlld0FuZGZvbGRlcihmb2xkZXJQYXRoKSlbMF07XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRBbGxBdmFpbGFibGVGaWxlcyggKXtcblx0XHRsZXQgaW5zdGFuY2UgPSBGaWxlQ29udGV4dC5nZXRJbnN0YW5jZSgpO1xuXHRcdHJldHVybiBpbnN0YW5jZS5sb2FkQWxsQXZhaWxhYmxlRmlsZXMoKTtcblx0fVxuXHRwdWJsaWMgYXN5bmMgbG9hZEFsbEF2YWlsYWJsZUZpbGVzKCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge30gKXsgXG5cdFx0bGV0IHJlbGVhc2UgPSBhd2FpdCBGaWxlQ29udGV4dC5tdXRleC5hY3F1aXJlKCk7IFxuXG5cdFx0XHQvLyBmaW5kIGFsbCBmb2xkZXJzLCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBzeXN0ZW0uIFxuXHRcdFx0bGV0IGxzRGlyID0gYXdhaXQgRmlsZUhhbmRsZXIubHNkaXIodGhpcy5wYXRoKTtcblx0XHRcdGxldCBzeXN0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoIGxzRGlyLmZvbGRlcnMubWFwKGFzeW5jICggZm9sZGVyUGF0aCApID0+IHtcblx0XHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMubG9hZFByZXZpZXdBbmRmb2xkZXIoZm9sZGVyUGF0aCk7XG5cdFx0XHR9KSkgXG5cblx0XHRcdHRoaXMuZm9sZGVyc1dpdGhOb0luZGV4ID0gW107XG5cdFx0XHR0aGlzLmF2YWlsYWJsZVN5c3RlbXMgPSBbXTtcblxuXHRcdFx0Ly8gU29ydCBpbnRvIGZvdW5kIGFuZCB1bmZvdW5kXG5cdFx0XHRzeXN0ZW1zLmZvckVhY2goIHAgPT4ge1xuXHRcdFx0XHRpZihwWzBdKXtcblx0XHRcdFx0XHR0aGlzLmF2YWlsYWJsZVN5c3RlbXNcdC5wdXNoKHBbMF0pO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0aGlzLmZvbGRlcnNXaXRoTm9JbmRleCAucHVzaChwWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkgXG5cdFx0cmVsZWFzZSgpO1xuXHR9XG4gXG5cdHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlU3lzdGVtRGVmaW5pdGlvbiggc3lzdGVtIDogU3lzdGVtUHJldmlldyAsIG1lc3NhZ2VzIDogbWVzc2FnZUxpc3QgPSB7fSApIDogUHJvbWlzZTxTeXN0ZW1QcmV2aWV3IHwgbnVsbD4ge1xuXHRcdGxldCBpbnN0YW5jZSA9IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCk7XG5cdFx0cmV0dXJuIGluc3RhbmNlLmNyZWF0ZVN5c3RlbURlZmluaXRpb24oc3lzdGVtLCBtZXNzYWdlcyApO1xuXHR9XG5cdHB1YmxpYyBhc3luYyBjcmVhdGVTeXN0ZW1EZWZpbml0aW9uKCBzeXN0ZW0gOiBTeXN0ZW1QcmV2aWV3ICwgbWVzc2FnZXMgOiBtZXNzYWdlTGlzdCA9IHt9KSA6IFByb21pc2U8U3lzdGVtUHJldmlldyB8IG51bGw+ICB7XG5cdFx0bGV0IHJlbGVhc2UgPSBhd2FpdCBGaWxlQ29udGV4dC5tdXRleC5hY3F1aXJlKCk7IFxuXG5cdFx0IFx0dGhpcy5pbml0U3lzdGVtc1N0cnVjdHVyZSgpO1xuXG5cdFx0XHQvLyBjcmVhdGUgZm9sZGVyIGlmIG5vdCBleGlzdHMuIFxuXHRcdFx0bGV0IGZvbGRlclBhdGggPSB0aGlzLnBhdGggKyAnLycgKyBzeXN0ZW0uZm9sZGVyTmFtZTtcblx0XHRcdGlmICghIGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhmb2xkZXJQYXRoKSl7XG5cdFx0XHRcdGF3YWl0IEZpbGVIYW5kbGVyLm1rZGlyKGZvbGRlclBhdGgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhmb2xkZXJQYXRoICsgJy9pbmRleC5qc29uJykpe1xuXHRcdFx0XHRcdG1lc3NhZ2VzWydjcmVhdGVTeXN0ZW0nXSA9IHttc2c6YGZvbGRlciAnJHtzeXN0ZW0uZm9sZGVyTmFtZX0nIGFscmVhZHkgZXhpc3RlZCwgYW5kIGNvbnRhaW5lZCBhIHN5c3RlbS4gXFxuRWl0aGVyIGRlbGV0ZSB0aGUgb2xkIHN5c3RlbSwgb3IgY2hvb3NlIGFub3RoZXIgZm9sZGVybmFtZWAsIHR5cGU6J2Vycm9yJ307XG5cdFx0XHRcdFx0cmVsZWFzZSgpO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vLyBjcmVhdGUgdGhlIHN5c3RlbS4nXG5cdFx0XHRsZXQgZmlsZXBhdGggPSBmb2xkZXJQYXRoKycvaW5kZXguanNvbic7XG5cdFx0XHRhd2FpdCBGaWxlSGFuZGxlci5zYXZlRmlsZSggZmlsZXBhdGggLCBKU09OSGFuZGxlci5zZXJpYWxpemUoc3lzdGVtKSApXG5cdFx0XHRpZiAoISBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMoZmlsZXBhdGgpKXtcblx0XHRcdFx0bWVzc2FnZXNbJ2NyZWF0ZVN5c3RlbSddID0ge21zZzpgdHJpZWQgdG8gc2F2ZSBpbmRleC5qc29uIGF0ICcke2ZpbGVwYXRofSBcXG4gYnV0IHNvbWV0aGluZyB3ZW50IHdyb25nLmAsIHR5cGU6J2Vycm9yJ307XG5cdFx0XHRcdHJlbGVhc2UoKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0bGV0IHN5c3RlbVJlbG9hZGVkID0gYXdhaXQgdGhpcy5sb2FkUHJldmlldyhmb2xkZXJQYXRoKTtcblx0XHRyZWxlYXNlKCk7XG5cdFx0cmV0dXJuIHN5c3RlbVJlbG9hZGVkO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBhc3luYyBjb3B5U3lzdGVtRGVmaW5pdGlvbiggc3lzdGVtIDogU3lzdGVtUHJldmlldyAsIHN5c3RlbU5ldyA6IFN5c3RlbVByZXZpZXcgLCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge30gKSA6IFByb21pc2U8U3lzdGVtUHJldmlldyB8IG51bGw+ICAge1xuXHRcdGxldCBpbnN0YW5jZSA9IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCk7XG5cdFx0cmV0dXJuIGluc3RhbmNlLmNvcHlTeXN0ZW1EZWZpbml0aW9uKHN5c3RlbSxzeXN0ZW1OZXcsbWVzc2FnZXMpO1xuXHR9XG5cdHB1YmxpYyBhc3luYyBjb3B5U3lzdGVtRGVmaW5pdGlvbiggc3lzdGVtIDogU3lzdGVtUHJldmlldyAsIHN5c3RlbU5ldyA6IFN5c3RlbVByZXZpZXcgLCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge30pIDogUHJvbWlzZTxTeXN0ZW1QcmV2aWV3IHwgbnVsbD4gIHtcblx0XHRcblx0XHRsZXQgY29waWVkU3lzdGVtID0gYXdhaXQgdGhpcy5jcmVhdGVTeXN0ZW1EZWZpbml0aW9uKHN5c3RlbU5ldywgbWVzc2FnZXMpO1xuXHRcdGlmICghY29waWVkU3lzdGVtKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRhc3luYyBmdW5jdGlvbiBERlNDb3B5QWxsRm9sZGVycyggcGF0aDpzdHJpbmcgLCBuZXdQYXRoOnN0cmluZyl7XG5cdFx0XHRsZXQgbHMgPSBhd2FpdCBGaWxlSGFuZGxlci5sc2RpcihwYXRoKTtcblx0XHRcdGF3YWl0IFByb21pc2UuYWxsKCBscy5mb2xkZXJzLm1hcChhc3luYyAoIGZvbGRlclBhdGggKSA9PiB7XG5cdFx0XHRcdGxldCBmb2xkZXJuYW1lID0gZm9sZGVyUGF0aC5zcGxpdCgnLycpLmxhc3QoKTtcblx0XHRcdFx0bGV0IG5ld0ZvbGRlclBhdGggPSBuZXdQYXRoICsgJy8nICsgZm9sZGVybmFtZTtcblx0XHRcdFx0RmlsZUhhbmRsZXIubWtkaXIobmV3Rm9sZGVyUGF0aCk7XG5cdFx0XHRcdGF3YWl0IERGU0NvcHlBbGxGb2xkZXJzKGZvbGRlclBhdGgsbmV3Rm9sZGVyUGF0aCk7XG5cdFx0XHR9KSk7XG5cdFx0fVxuXG5cdFx0YXN5bmMgZnVuY3Rpb24gQkZTQ29weUFsbEZpbGVzKCBwYXRoOnN0cmluZyAsIG5ld1BhdGg6c3RyaW5nKXtcblxuXG5cdFx0XHRsZXQgbHMgPSBhd2FpdCBGaWxlSGFuZGxlci5sc2RpcihwYXRoKTtcblx0XHRcdGF3YWl0IFByb21pc2UuYWxsKCBscy5maWxlcy5tYXAoYXN5bmMgKCBmaWxlUGF0aCApID0+IHsgXG5cdFx0XHRcdGxldCBmaWxlID0gYXdhaXQgRmlsZUhhbmRsZXIucmVhZEZpbGUoZmlsZVBhdGgpO1xuXHRcdFx0XHRsZXQgZmlsZU5hbWUgPSBmaWxlUGF0aC5zcGxpdCgnLycpLmxhc3QoKTtcblx0XHRcdFx0YXdhaXQgRmlsZUhhbmRsZXIuc2F2ZUZpbGUobmV3UGF0aCArICcvJysgZmlsZU5hbWUgLGZpbGUpO1xuXHRcdFx0fSkpO1xuIFxuXHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoIGxzLmZvbGRlcnMubWFwKGFzeW5jICggZm9sZGVyUGF0aCApID0+IHsgXG5cdFx0XHRcdGxldCBzZWdtZW50c1BhdGggPSBmb2xkZXJQYXRoLnNwbGl0KCcvJyk7IFxuXHRcdFx0XHRsZXQgZm9sZGVybmFtZSA9IHNlZ21lbnRzUGF0aC5wb3AoKTtcblx0XHRcdFx0bGV0IG5ld0ZvbGRlclBhdGggPSBuZXdQYXRoICsgJy8nICsgZm9sZGVybmFtZTtcblx0XHRcdFx0YXdhaXQgQkZTQ29weUFsbEZpbGVzKGZvbGRlclBhdGgsbmV3Rm9sZGVyUGF0aCk7XG5cdFx0XHR9KSk7XG5cdFx0fVxuXG5cdFx0YXdhaXQgREZTQ29weUFsbEZvbGRlcnMoc3lzdGVtLmZvbGRlclBhdGgsIGNvcGllZFN5c3RlbS5mb2xkZXJQYXRoKTtcblx0XHRhd2FpdCBCRlNDb3B5QWxsRmlsZXMoc3lzdGVtLmZvbGRlclBhdGgsIGNvcGllZFN5c3RlbS5mb2xkZXJQYXRoKTsgXG5cdFx0YXdhaXQgRmlsZUhhbmRsZXIuc2F2ZUZpbGUoY29waWVkU3lzdGVtLmZpbGVQYXRoLCBKU09OSGFuZGxlci5zZXJpYWxpemUoY29waWVkU3lzdGVtKSApXG5cdFx0cmV0dXJuIGNvcGllZFN5c3RlbTtcblxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBhc3luYyBzeXN0ZW1EZWZpbml0aW9uRXhpc3RzSW5Gb2xkZXIoIGZvbGRlcjpzdHJpbmcpe1xuXHRcdGxldCBpbnN0YW5jZSA9IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCk7XG5cdFx0cmV0dXJuIGluc3RhbmNlLnN5c3RlbURlZmluaXRpb25FeGlzdHNJbkZvbGRlcihmb2xkZXIpO1xuXHR9XG5cdHB1YmxpYyBhc3luYyBzeXN0ZW1EZWZpbml0aW9uRXhpc3RzSW5Gb2xkZXIoIGZvbGRlcjpzdHJpbmcgKXtcblx0XHRsZXQgZm9sZGVyUGF0aCA9IHRoaXMucGF0aCArICcvJyArIGZvbGRlcjtcblx0XHRpZiAoISBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMoZm9sZGVyUGF0aCkpe1xuXHRcdFx0IHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7IFxuXHRcdFx0aWYgKGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhmb2xkZXJQYXRoICsgJy9pbmRleC5qc29uJykpeyBcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IFxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXG5cdHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0T3JDcmVhdGVTeXN0ZW1zRGVzaWducyggZm9sZGVyOnN0cmluZyl7XG5cdFx0cmV0dXJuIEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCkuc3lzdGVtRGVmaW5pdGlvbkV4aXN0c0luRm9sZGVyKGZvbGRlcik7XG5cdH1cblx0cHVibGljIGFzeW5jIGdldE9yQ3JlYXRlU3lzdGVtc0Rlc2lnbnMoIGZvbGRlcjpzdHJpbmcgKXtcbiBcblx0XHQvLyBpZiB0aGUgZm9sZGVyIGRvZXMgbm90IGV4aXN0LiByZXR1cm4gZmFsc2UgXG5cdFx0aWYgKCEgYXdhaXQgRmlsZUhhbmRsZXIuZXhpc3RzKGZvbGRlcikpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGZvbGRlciBkb2VzIG5vdCBleGlzdC4gcmV0dXJuIGZhbHNlIFxuXHRcdGlmICghIGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhmb2xkZXIpKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIFNlZSBpZiB0aGUgZmlsZSBleGlzdHMuIFxuXHRcdGxldCBmaWxlcGF0aCA9IGZvbGRlciArICcvZGVzaWduZXIuanNvbic7XG5cdFx0aWYgKCFhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMoZmlsZXBhdGgpKXtcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaWxlLiBcblx0XHRcdGxldCBkZXNpZ25lciA9IG5ldyBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nKCk7XG5cdFx0XHRkZXNpZ25lci5pbml0QXNOZXcoKTtcblx0XHRcdGF3YWl0IEZpbGVIYW5kbGVyLnNhdmVGaWxlKCBmaWxlcGF0aCAsIEpTT05IYW5kbGVyLnNlcmlhbGl6ZShkZXNpZ25lcikgKTtcblxuXHRcdFx0cmV0dXJuIGRlc2lnbmVyO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgZmlsZSA9IGF3YWl0IEZpbGVIYW5kbGVyLnJlYWRGaWxlKGZpbGVwYXRoKTtcblx0XHRsZXQgbG9hZGVkID0gSlNPTkhhbmRsZXIuZGVzZXJpYWxpemU8VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZz4oIFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcsIGZpbGUgKTtcblx0XHRyZXR1cm4gbG9hZGVkIGFzIFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmc7XG5cdH1cblx0cHVibGljIGFzeW5jIHNhdmVTeXN0ZW1zRGVzaWducyggZm9sZGVyOnN0cmluZyAsIGRlc2lnbmVyOiBUVFJQR1N5c3RlbUpTT05Gb3JtYXR0aW5nICl7XG5cblx0XHQvLyBpZiB0aGUgZm9sZGVyIGRvZXMgbm90IGV4aXN0LiByZXR1cm4gZmFsc2UgXG5cdFx0aWYgKCEgYXdhaXQgRmlsZUhhbmRsZXIuZXhpc3RzKGZvbGRlcikpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGZvbGRlciBkb2VzIG5vdCBleGlzdC4gcmV0dXJuIGZhbHNlIFxuXHRcdGlmICghIGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhmb2xkZXIpKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIFNlZSBpZiB0aGUgZmlsZSBleGlzdHMuIFxuXHRcdGxldCBmaWxlcGF0aCA9IGZvbGRlciArICcvZGVzaWduZXIuanNvbic7XG5cdFx0YXdhaXQgRmlsZUhhbmRsZXIuc2F2ZUZpbGUoIGZpbGVwYXRoICwgSlNPTkhhbmRsZXIuc2VyaWFsaXplKGRlc2lnbmVyKSApOyBcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuIFxuXHRwcml2YXRlIGFzeW5jIGxvYWRGb2xkZXJBbmRGaWxlc1JlY3Vyc2ljZShmb2xkZXJQYXRoKTogUHJvbWlzZTxjb21tYW5kW10+e1xuXHRcdFxuXHRcdC8vIGZpcnN0IGNyZWF0ZSB0aGlzIGZvbGRlclxuXHRcdGxldCBjIDogY29tbWFuZFtdID0gW107IFxuXG5cdFx0Ly8gbG9hZCBhbGwgZmlsZXMgaW4gdGhlIEZvbGRlclxuXHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBGaWxlSGFuZGxlci5sc2Rpcihmb2xkZXJQYXRoKTtcblx0XHRsZXQgbWFwID0gYXdhaXQgUHJvbWlzZS5hbGwoIGNvbnRlbnQuZmlsZXMubWFwKGFzeW5jICggZiApID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmxvYWRGaWxlQW5kQ3JlYXRlQ29tbWFuZChmKTtcblx0XHR9KSkgXHRcblx0XHRtYXAuZm9yRWFjaCggcCA9PiB7XG5cdFx0XHRjLnB1c2gocCk7XG5cdFx0fSlcblxuXHRcdC8vIGxvYWQgYWxsIGZvbGRlcnMgaW4gdGhlIGZvbGRlciBcblx0XHRsZXQgbWFwMiA9IGF3YWl0IFByb21pc2UuYWxsKCBjb250ZW50LmZvbGRlcnMubWFwKGFzeW5jICggZiApID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmxvYWRGb2xkZXJBbmRGaWxlc1JlY3Vyc2ljZShmKTtcblx0XHR9KSkgXHRcblx0XHRtYXAyLmZvckVhY2goIHAgPT4ge1xuXHRcdFx0cC5mb3JFYWNoKHEgPT4ge1xuXHRcdFx0XHRjLnB1c2gocSk7XG5cdFx0XHR9KTtcblx0XHR9KVxuXHRcdFxuXG5cdFx0cmV0dXJuIGM7XG5cdH1cblx0cHJpdmF0ZSBhc3luYyBsb2FkRmlsZUFuZENyZWF0ZUNvbW1hbmQoIGZpbGVwYXRoICkgOiBQcm9taXNlPGNvbW1hbmQ+e1xuXHRcdGxldCBkYXRhID0gYXdhaXQgRmlsZUhhbmRsZXIucmVhZEZpbGUoZmlsZXBhdGgpO1xuXHRcdHJldHVybiB7IFxuXHRcdFx0Y29tbWFuZDonZmlsZScsXG5cdFx0XHRwYXRoOmZpbGVwYXRoLFxuXHRcdFx0Y29udGVudDpkYXRhXG5cdFx0fVxuXHR9XG5cblxuXHRwdWJsaWMgYXN5bmMgbG9hZEJsb2NrVUlUZW1wbGF0ZSggKXtcblx0XHRcblx0XHRjb25zdCBwYXRoID0gIFBsdWdpbkhhbmRsZXIuUExVR0lOX1JPT1QgKyAnLycgKyBQbHVnaW5IYW5kbGVyLkJVSUxUSU5fVUlTX0ZPTERFUl9OQU1FICsgJy8nOyBcblx0XHRsZXQgY29tbWFuZHMgOmNvbW1hbmRbXSA9IFtdO1xuXG5cdFx0Ly8gZmlyc3Qgd2UgZ2V0IHRoZSB1cHBlciBmaWxlcyBpbiB0aGUgZm9sZGVyIFxuXHRcdGxldCBleGlzdHMgPSBhd2FpdCBGaWxlSGFuZGxlci5leGlzdHMocGF0aClcblx0XHRpZiggIWV4aXN0cyApe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdGaWxlIGZvciBCbG9ja1VJIGhhdmUgYmVlbiBkZWxldGVkLiB0aGlzIGZlYXR1cmUgbG9uZ2VyIHdvcmtzIGFzIGEgcmVzdWx0Jylcblx0XHR9XG5cdFx0ICBcblx0XHQvLyBGSUxFUyBBREQgVE8gQ09NTUFORFMgXG5cdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IEZpbGVIYW5kbGVyLmxzZGlyKHBhdGgpO1xuXHRcdGxldCBtYXAgPSBhd2FpdCBQcm9taXNlLmFsbCggY29udGVudC5maWxlcy5tYXAoYXN5bmMgKCBmICkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMubG9hZEZpbGVBbmRDcmVhdGVDb21tYW5kKGYpO1xuXHRcdH0pKSBcdCBcblx0XHRtYXAuZm9yRWFjaCggcCA9PiB7XG5cdFx0XHRpZighcC5wYXRoLmVuZHNXaXRoKFwiL2RlY2xhcmF0aW9uLnRzXCIpKXtcblx0XHRcdFx0bGV0IG4gOiBzdHJpbmcgPSAocC5wYXRoLnNwbGl0KCdCbG9ja1VJRGV2LycpLmxhc3QoKSApPz8gJyc7XG5cdFx0XHRcdHAucGF0aCA9IFwic3JjL1wiICsgbjsgXG5cdFx0XHRcdGNvbW1hbmRzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0fSkgXG5cdFx0XG5cdFx0Ly8gdGhlbiB3ZSBsb2FkIHNwZWNpZmlrIEZvbGRlcnMuIFxuXHRcdGxldCBwYXRoc3JjID0gcGF0aCArICcvJyArICdzcmMvJztcblx0XHRsZXQgbWFwMiA9IGF3YWl0IHRoaXMubG9hZEZvbGRlckFuZEZpbGVzUmVjdXJzaWNlKHBhdGhzcmMpO1xuXHRcdG1hcDIuZm9yRWFjaChwPT57IFxuXHRcdFx0bGV0IG4gPSBwLnBhdGguc3BsaXQoJ0Jsb2NrVUlEZXYvJykubGFzdCgpID8/ICcnO1xuXHRcdFx0cC5wYXRoID0gbjtcblx0XHRcdGlmKG4gIT0gXCIvc3JjL1wiKXtcblx0XHRcdFx0Y29tbWFuZHMucHVzaChwKTtcblx0XHRcdH1cblx0XHR9KSBcblx0XHQgXG5cdFx0cmV0dXJuIGNvbW1hbmRzO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBsb2FkVUlMYXlvdXQoIGZvbGRlcnNyYyA6IHN0cmluZyAsIGVycm9ycyA6IHN0cmluZ1tdID0gW10pe1xuXHRcdGNvbnN0IHNyYyA9IGZvbGRlcnNyYyArICcvJyArIFBsdWdpbkhhbmRsZXIuU1lTVEVNX1VJX0xBWU9VVEZJTEVOQU1FIDtcblx0XHRjb25zdCBleGlzdHNcdD0gYXdhaXQgRmlsZUhhbmRsZXIuZXhpc3RzKCBzcmMgKTtcblx0XHRpZighZXhpc3RzKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCBmaWxlID0gYXdhaXQgRmlsZUhhbmRsZXIucmVhZEZpbGUoc3JjKTtcblx0XHRsZXQgbW9kZWwgOiBVSUxheW91dE1vZGVsO1xuXHRcdHRyeSB7XG5cdFx0XHRtb2RlbCA9IEpTT05IYW5kbGVyLmRlc2VyaWFsaXplKFVJTGF5b3V0TW9kZWwsZmlsZSk7XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0ZXJyb3JzLnB1c2goZS5tZXNzYWdlKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdG1vZGVsLmZvbGRlclNyYyA9IGZvbGRlcnNyYztcblx0XHRhd2FpdCBtb2RlbC5pc1ZhbGlkKCk7XG5cdFx0cmV0dXJuIG1vZGVsO1xuXHR9XG5cdHB1YmxpYyBhc3luYyBnZXRBbGxCbG9ja1VJQXZhaWxhYmxlUHJldmlldyggc3lzIDogU3lzdGVtUHJldmlldyApe1xuXHRcdGNvbnN0IFVJRm9sZGVycGF0aCA9IHN5cy5mb2xkZXJQYXRoICsgJy8nICsgUGx1Z2luSGFuZGxlci5TWVNURU1fVUlfQ09OVEFJTkVSX0ZPTERFUl9OQU1FO1xuXHRcdGNvbnN0IGV4aXN0cyA9IGF3YWl0IEZpbGVIYW5kbGVyLmV4aXN0cyhVSUZvbGRlcnBhdGgpXG5cdFx0XG5cdFx0bGV0IGxheW91dHMgOiBVSUxheW91dE1vZGVsW109W107XG5cdFx0aWYoIGV4aXN0cyApe1xuXHRcdFx0bGV0IGZvbGRlcnMgPSAoYXdhaXQgRmlsZUhhbmRsZXIubHNkaXIoVUlGb2xkZXJwYXRoKSkuZm9sZGVycztcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZm9sZGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSBmb2xkZXJzW2ldO1xuXHRcdFx0XHRsZXQgbGF5b3V0ID0gYXdhaXQgdGhpcy5sb2FkVUlMYXlvdXQoZm9sZGVyKTtcblx0XHRcdFx0aWYobGF5b3V0KVxuXHRcdFx0XHRcdGxheW91dHMucHVzaChsYXlvdXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbGF5b3V0cztcblx0fVxuXG5cblxuXG5cdFxufSIsIlxuaW1wb3J0IHsgRmlsZUNvbnRleHQgfSBmcm9tIFwiLi4vY29yZS9maWxlQ29udGV4dFwiO1xuaW1wb3J0IHsgU3lzdGVtUHJldmlldyB9IGZyb20gXCIuLi9jb3JlL21vZGVsL3N5c3RlbVByZXZpZXdcIjsgXG5pbXBvcnQgUGx1Z2luSGFuZGxlciBmcm9tIFwiLi4vdWktb2JzaWRpYW4vYXBwXCI7XG5pbXBvcnQgeyBBUElSZXR1cm5Nb2RlbCwgSUFQSSB9IGZyb20gXCIuL0lBUElcIjtcblxuXG5leHBvcnQgY2xhc3MgT2JzaWRpYW5BUEkgaW1wbGVtZW50cyBJQVBJe1xuXG5cdHBsdWdpbkhhbmRsZXIgOiBQbHVnaW5IYW5kbGVyO1xuXHRwdWJsaWMgY29uc3RydWN0b3IocGx1Z2luSGFuZGxlciA6IFBsdWdpbkhhbmRsZXIgKXtcblx0XHR0aGlzLnBsdWdpbkhhbmRsZXIgPSBwbHVnaW5IYW5kbGVyO1xuXHR9XG5cblx0Z2V0U3lzdGVtVUlzKHByZXZpZXc6IFN5c3RlbVByZXZpZXcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcblx0fVxuXHRnZXRGYWN0b3J5KHByZXZpZXc6IFN5c3RlbVByZXZpZXcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcblx0fVxuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsU3lzdGVtcygpIDogUHJvbWlzZTxBUElSZXR1cm5Nb2RlbDxTeXN0ZW1QcmV2aWV3W10+Pntcblx0XHRsZXQgbWVzc2FnZXMgPSBbXVxuXHRcdHRyeXtcblx0XHRcdGxldCBmaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCB0aGlzLnBsdWdpbkhhbmRsZXIgKTtcblx0XHRcdGF3YWl0IGZpbGVDb250ZXh0LmxvYWRBbGxBdmFpbGFibGVGaWxlcyggbWVzc2FnZXMgKTsgXG5cdFx0XHRsZXQgcHJldmlld3MgPSBmaWxlQ29udGV4dC5hdmFpbGFibGVTeXN0ZW1zID8/IFtdO1x0XG5cdFx0XHRsZXQgcmVzcG9uc2UgPSB7XG5cdFx0XHRcdHJlc3BvbnNlQ29kZSA6IDIwMCxcblx0XHRcdFx0bWVzc2FnZXMgOiBbXSxcblx0XHRcdFx0cmVzcG9uc2U6IHByZXZpZXdzXG5cdFx0XHR9IGFzIEFQSVJldHVybk1vZGVsPFN5c3RlbVByZXZpZXdbXT5cblx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGUpe1xuXHRcdFx0bWVzc2FnZXNbJ2V4Y2VwdGlvbiddID0ge21zZzplLm1lc3NhZ2UgLCB0eXBlOidlcnJvcid9O1xuXHRcdFx0bGV0IHJlc3BvbnNlID0ge1xuXHRcdFx0XHRyZXNwb25zZUNvZGUgOiAzMDAsXG5cdFx0XHRcdG1lc3NhZ2VzIDogWydjb3VsZCBub3QgbG9hZCBzeXN0ZW0gcHJldmlld3MnXSxcblx0XHRcdFx0cmVzcG9uc2U6IFtdXG5cdFx0XHR9IGFzIEFQSVJldHVybk1vZGVsPFN5c3RlbVByZXZpZXdbXT5cblx0XHRcdHJldHVybiByZXNwb25zZVxuXHRcdH0gXG5cdH1cbn1cblxuLypcblxuXG5jbGFzcyBTeXN0ZW1EZWZpbml0aW9uTWFuYWdlbWVudHtcblxuXHRwcml2YXRlIGFzeW5jIHJlY3Vyc2l2ZUZpbmROZXdGb2xkZXJOYW1lKCBkZXB0aCA9IDAsIG1heERlcHRoID0gNSkgOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ICB7XG5cblx0XHRpZiAoZGVwdGggPT0gbWF4RGVwdGgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IHV1aWQgPSBTdHJpbmdGdW5jdGlvbnMudXVpZFNob3J0KCk7XG5cdFx0aWYgKGF3YWl0IEZpbGVDb250ZXh0LnN5c3RlbURlZmluaXRpb25FeGlzdHNJbkZvbGRlcih1dWlkKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWN1cnNpdmVGaW5kTmV3Rm9sZGVyTmFtZShkZXB0aCArIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdXVpZDtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaXNWYWxpZFN5c3RlbVByZXZpZXcoIHN5cyA6IFN5c3RlbVByZXZpZXcsIGludmFsaWRNZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge30gKSA6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGxldCBpc1ZhbGlkID0gdHJ1ZTtcblx0XHRjb25zdCBzeXN0ZW1QcmV2aWV3VmFsaWRhdGlvbkNvZGUgPSAnc3B2JztcblxuXHRcdGxldCBfID0gJyc7IFxuXHRcdC8vIEF1dGhvciBcblx0XHRpZiAoICFzeXMuYXV0aG9yICApe1x0XG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKycxJ10gPSB7bXNnOidhIGF1dGhvciBpcyBub3QgcmVxdWlyZWQgYnV0IGhlbHBmdWxsIHRvIHVzZXJzJywgdHlwZTogIE1lc3NhZ2VUeXBlcy52ZXJib3NlIGFzIGFueSAgfSBcblx0XHR9XG5cblx0XHQvLyBWZXJzaW9uIFxuXHRcdGlmICggIXN5cy52ZXJzaW9uICApe1x0XG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKycyJ10gPSB7bXNnOidhIHZlcnNpb24gaXMgbm90IHJlcXVpcmVkIGJ1dCBoZWxwZnVsbCB0byB1c2VycycsIHR5cGU6ICBNZXNzYWdlVHlwZXMudmVyYm9zZSBhcyBhbnkgIH0gIFxuXHRcdH1cblxuXHRcdC8vIFN5c3RlbUNvZGVOYW1lIFxuXHRcdGlmICggIXN5cy5zeXN0ZW1Db2RlTmFtZSAgKXtcdFxuXHRcdFx0aXNWYWxpZCA9IGZhbHNlOyAgXG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKyczJ10gPSB7bXNnOidEaWQgbm90IGhhdmUgYSBzeXN0ZW1Db2RlTmFtZS5cXG4gY2FuIG9ubHkgY29udGFpbiByZWd1bGFyIGxldHRlciBhbmQgbnVtYmVycywgbm8gc3BlY2lhbCBjaGFyYWN0ZXJzIG9yIHdoaXRlc3BhY2UnLCB0eXBlOiAgTWVzc2FnZVR5cGVzLmVycm9yIGFzIGFueSAgfSAgXG5cdFx0fWVsc2UgaWYgKCFTdHJpbmdGdW5jdGlvbnMuaXNWYWxpZFN5c3RlbUNvZGVOYW1lKHN5cy5zeXN0ZW1Db2RlTmFtZSkpe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlOyAgXG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKyc0J10gPSB7bXNnOidEaWQgbm90IGhhdmUgYSB2YWxpZCBzeXN0ZW1Db2RlTmFtZS5cXG4gY2FuIG9ubHkgY29udGFpbiByZWd1bGFyIGxldHRlciBhbmQgbnVtYmVycywgbm8gc3BlY2lhbCBjaGFyYWN0ZXJzIG9yIHdoaXRlc3BhY2UnLCB0eXBlOiAgTWVzc2FnZVR5cGVzLmVycm9yIGFzIGFueSAgfSBcblx0XHR9XG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHQoRmlsZUNvbnRleHQuZ2V0SW5zdGFuY2UoKS5hdmFpbGFibGVTeXN0ZW1zLmZpbmRJbmRleCggcCA9PiBwLnN5c3RlbUNvZGVOYW1lID09IHN5cy5zeXN0ZW1Db2RlTmFtZSkpXG5cdFx0XHQhPSBcblx0XHRcdC0xXG5cdFx0KXtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTsgXG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKydkMSddID0ge21zZzonc2hhcmVzIENvZGVuYW1lIHdpdGggYW5vdGhlciBzeXN0ZW0nLCB0eXBlOiAgTWVzc2FnZVR5cGVzLmVycm9yIGFzIGFueSAgfVxuXHRcdH1cblxuXHRcdC8vIFN5c3RlbU5hbWUgTm8gXFxuIGNoYXJhY3RlcnMuXG5cdFx0aWYgKCAhc3lzLnN5c3RlbU5hbWUgICl7XHRcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTsgIFxuXHRcdFx0aW52YWxpZE1lc3NhZ2VzW3N5c3RlbVByZXZpZXdWYWxpZGF0aW9uQ29kZSsnNSddID0ge21zZzonRGlkIG5vdCBoYXZlIGEgc3lzdGVtIG5hbWUuJywgdHlwZTogIE1lc3NhZ2VUeXBlcy5lcnJvciBhcyBhbnkgIH0gIFxuXHRcdH1lbHNlIGlmICghU3RyaW5nRnVuY3Rpb25zLmlzVmFsaWRXaW5kb3dzRmlsZVN0cmluZyhzeXMuc3lzdGVtTmFtZSkpe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlOyAgXG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKyc2J10gPSB7bXNnOidEaWQgbm90IGhhdmUgYSB2YWxpZCBzeXN0ZW0gbmFtZS4nLCB0eXBlOiAgTWVzc2FnZVR5cGVzLmVycm9yIGFzIGFueSAgfSAgXG5cdFx0fVxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0KEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCkuYXZhaWxhYmxlU3lzdGVtcy5maW5kSW5kZXgoIHAgPT4gcC5zeXN0ZW1OYW1lID09IHN5cy5zeXN0ZW1OYW1lKSlcblx0XHRcdCE9IFxuXHRcdFx0LTFcblx0XHQpe1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlOyBcblx0XHRcdGludmFsaWRNZXNzYWdlc1tzeXN0ZW1QcmV2aWV3VmFsaWRhdGlvbkNvZGUrJ2QyJ10gPSB7bXNnOidzaGFyZXMgbmFtZSB3aXRoIGFub3RoZXIgc3lzdGVtJywgdHlwZTogIE1lc3NhZ2VUeXBlcy5lcnJvciBhcyBhbnkgIH1cblx0XHR9XG5cblx0XHQvLyBmb2xkZXIgb25seSBhbGxvdyB3aW5kb3dzIGZvbGRlciBuYW1lIGFjY2VwdGVkIGZvbGRlciBuYW1lcy5cblx0XHRpZiAoICFzeXMuZm9sZGVyTmFtZSAgKXtcdFxuXG5cdFx0XHRsZXQgbmV3Rm9sZGVybmFtZSA9IGF3YWl0IHRoaXMucmVjdXJzaXZlRmluZE5ld0ZvbGRlck5hbWUoMCw1KTtcblx0XHRcdGlmICghbmV3Rm9sZGVybmFtZSl7XG5cdFx0XHRcdGludmFsaWRNZXNzYWdlc1tzeXN0ZW1QcmV2aWV3VmFsaWRhdGlvbkNvZGUrJzcnXSA9IHttc2c6J0EgbmV3IGZvbGRlciBuYW1lIGlzIHJlcXVpcmVkLCBNdXN0IGJlIHVuaXF1ZS4nLCB0eXBlOiAgTWVzc2FnZVR5cGVzLmVycm9yIGFzIGFueSAgfSAgIFxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHN5cy5mb2xkZXJOYW1lID0gbmV3Rm9sZGVybmFtZS8vXG5cdFx0XHRcdGludmFsaWRNZXNzYWdlc1tzeXN0ZW1QcmV2aWV3VmFsaWRhdGlvbkNvZGUrJzgnXSA9IHttc2c6J0RpZCBub3QgaGF2ZSBhIGZvbGRlciBuYW1lIHNvIGNyZWF0ZWQgb25lLicsIHR5cGU6ICBNZXNzYWdlVHlwZXMudmVyYm9zZSBhcyBhbnkgIH0gICBcblx0XHRcdH1cblx0XHR9IFxuXHRcdGVsc2UgaWYgKCFTdHJpbmdGdW5jdGlvbnMuaXNWYWxpZFdpbmRvd3NGaWxlU3RyaW5nKHN5cy5mb2xkZXJOYW1lKSl7IFxuXHRcdFx0aXNWYWxpZCA9IGZhbHNlOyAgXG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKyc5J10gPSB7bXNnOidmb2xkZXIgbmFtZSB3YXMgbm90IHZhbGlkIHdpbmRvd3MgZm9sZGVyIG5hbWUuJywgdHlwZTogIE1lc3NhZ2VUeXBlcy5lcnJvciBhcyBhbnkgIH0gICBcblx0XHR9IFxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0KEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCkuYXZhaWxhYmxlU3lzdGVtcy5maW5kSW5kZXgoIHAgPT4gcC5mb2xkZXJQYXRoLmVuZHNXaXRoKCcvJyArIHN5cy5mb2xkZXJOYW1lKSkpXG5cdFx0XHQhPSBcblx0XHRcdC0xXG5cdFx0KXtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTsgIFxuXHRcdFx0aW52YWxpZE1lc3NhZ2VzW3N5c3RlbVByZXZpZXdWYWxpZGF0aW9uQ29kZSsnZDMnXSA9IHttc2c6J2ZvbGRlciBuYW1lIHdhcyBhbHJlYWR5IHVzZWQsIHlvdSBtdXN0IHVzZSBhbm90aGVyLCBvciB1c2UgYW4gb3ZlcndyaXRlIGZlYXR1cmUuJywgdHlwZTogIE1lc3NhZ2VUeXBlcy5lcnJvciBhcyBhbnkgIH1cblx0XHR9XG5cblx0XHRpZiAoaXNWYWxpZCl7XG5cdFx0XHRpbnZhbGlkTWVzc2FnZXNbc3lzdGVtUHJldmlld1ZhbGlkYXRpb25Db2RlKydPSyddID0ge21zZzonQWxsIGlzIEdvb2QuJywgdHlwZTogIE1lc3NhZ2VUeXBlcy5nb29kIGFzIGFueSAgfVxuXHRcdH1cblx0XHRyZXR1cm4gaXNWYWxpZDtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyB2YWxpZGF0ZVN5c3RlbSggc3lzIDogU3lzdGVtUHJldmlldyApe1xuXHRcdGxldCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge307XG5cdFx0dHJ5e1xuXHRcdFx0aWYgKCAhYXdhaXQgdGhpcy5pc1ZhbGlkU3lzdGVtUHJldmlldyhzeXMsIG1lc3NhZ2VzKSApe1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoNDA2LGZhbHNlLG1lc3NhZ2VzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoMjAwLHRydWUsbWVzc2FnZXMgKTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGUpe1xuXHRcdFx0bWVzc2FnZXNbJ2V4Y2VwdGlvbiddID0ge21zZzplLm1lc3NhZ2UgLCB0eXBlOidlcnJvcid9O1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDUwMCxudWxsLG1lc3NhZ2VzICk7XG5cdFx0fSBcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBDcmVhdGVOZXdTeXN0ZW0oIHN5cyA6IFN5c3RlbVByZXZpZXcgKSA6IFByb21pc2U8QVBJUmV0dXJuTW9kZWw8U3lzdGVtUHJldmlld3xudWxsPj4ge1xuXHRcdGxldCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge307XG5cdFx0dHJ5e1xuXHRcdFx0aWYgKCAhYXdhaXQgdGhpcy5pc1ZhbGlkU3lzdGVtUHJldmlldyhzeXMsIG1lc3NhZ2VzKSApe1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoNDA2LG51bGwsbWVzc2FnZXMgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGxldCBjcmVhdGVkQW5kUmVsb2FkZWQgPSBhd2FpdCBGaWxlQ29udGV4dC5jcmVhdGVTeXN0ZW1EZWZpbml0aW9uKCBzeXMgKTtcblx0XHRcdGlmIChjcmVhdGVkQW5kUmVsb2FkZWQpe1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoMjAwLGNyZWF0ZWRBbmRSZWxvYWRlZCxtZXNzYWdlcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDQwNixudWxsLG1lc3NhZ2VzICk7XG5cdFx0fVxuXHRcdGNhdGNoIChlKXtcblx0XHRcdG1lc3NhZ2VzWydleGNlcHRpb24nXSA9IHttc2c6ZS5tZXNzYWdlICwgdHlwZTonZXJyb3InfTtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg1MDAsbnVsbCxtZXNzYWdlcyApO1xuXHRcdH0gXG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgQ29weVN5c3RlbSggZnJvbSA6IFN5c3RlbVByZXZpZXcsIHRvIDogU3lzdGVtUHJldmlldykgOiBQcm9taXNlPEFQSVJldHVybk1vZGVsPFN5c3RlbVByZXZpZXd8bnVsbD4+IHtcblx0XHRsZXQgbWVzc2FnZXMgOiBtZXNzYWdlTGlzdCA9IHt9O1xuXHRcdHRyeXtcblx0XHRcdGlmICggIWF3YWl0IHRoaXMuaXNWYWxpZFN5c3RlbVByZXZpZXcodG8sIG1lc3NhZ2VzKSApe1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoNDA2LG51bGwsbWVzc2FnZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHNhdmVkQW5kUmVsb2FkZWQgPSBhd2FpdCBGaWxlQ29udGV4dC5jb3B5U3lzdGVtRGVmaW5pdGlvbiggZnJvbSAsIHRvICk7XG5cdFx0XHRpZiAoc2F2ZWRBbmRSZWxvYWRlZCl7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSgyMDAsc2F2ZWRBbmRSZWxvYWRlZCxtZXNzYWdlcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDQwNixudWxsLG1lc3NhZ2VzICk7XG5cdFx0fVxuXHRcdGNhdGNoIChlKXtcblx0XHRcdG1lc3NhZ2VzWydleGNlcHRpb24nXSA9IHttc2c6ZS5tZXNzYWdlICwgdHlwZTonZXJyb3InfTtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg1MDAsbnVsbCxtZXNzYWdlcyApO1xuXHRcdH0gXG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgRGVsZXRlc3lzdGVtKCBzeXMgOiBTeXN0ZW1QcmV2aWV3ICkgOiBQcm9taXNlPEFQSVJldHVybk1vZGVsPGJvb2xlYW4+PiB7XG5cdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDUwMSxmYWxzZSx7fSApO1xuXHR9XG5cblx0cHVibGljIGFzeW5jIEVkaXRTeXN0ZW0oIHN5cyA6IFN5c3RlbVByZXZpZXcgKSA6IFByb21pc2U8QVBJUmV0dXJuTW9kZWw8U3lzdGVtUHJldmlld3xudWxsPj57XG5cdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDUwMSxudWxsLHt9ICk7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsU3lzdGVtcygpIDogUHJvbWlzZTxBUElSZXR1cm5Nb2RlbDxTeXN0ZW1QcmV2aWV3W118bnVsbD4+e1xuXHRcdGxldCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge307XG5cdFx0dHJ5e1xuXHRcdFx0bGV0IGZpbGVDb250ZXh0ID0gRmlsZUNvbnRleHQuZ2V0SW5zdGFuY2UoKTtcblx0XHRcdGF3YWl0IGZpbGVDb250ZXh0LmxvYWRBbGxBdmFpbGFibGVGaWxlcyggbWVzc2FnZXMgKTsgXG5cdFx0XHRsZXQgcHJldmlld3MgPSBmaWxlQ29udGV4dC5hdmFpbGFibGVTeXN0ZW1zID8/IFtdO1x0XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoMjAwLHByZXZpZXdzLG1lc3NhZ2VzICk7XG5cdFx0fVxuXHRcdGNhdGNoIChlKXtcblx0XHRcdG1lc3NhZ2VzWydleGNlcHRpb24nXSA9IHttc2c6ZS5tZXNzYWdlICwgdHlwZTonZXJyb3InfTtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg1MDAsbnVsbCxtZXNzYWdlcyApO1xuXHRcdH0gXG5cdH1cbn1cblxuY2xhc3MgU3lzdGVtRmFjdG9yeXtcblx0cHVibGljIGFzeW5jIGdldE9yQ3JlYXRlU3lzdGVtRmFjdG9yeSggcHJldmlldyA6IFN5c3RlbVByZXZpZXcgKSA6IFByb21pc2U8QVBJUmV0dXJuTW9kZWw8VFRSUEdTeXN0ZW1KU09ORm9ybWF0dGluZ3xudWxsPj4ge1xuXHRcdFxuXHRcdGlmICghcHJldmlldy5mb2xkZXJQYXRoKXtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg0MDYsbnVsbCxjcmVhdGVNZXNzYWdlKCdnZXRPckNyZWF0ZVN5c3RlbUZhY3RvcnkxJywnc3lzdGVtUHJldmlldyB3YXMgaW52YWxpZCcsICdlcnJvcicpKTtcblx0XHR9XG5cblx0XHRsZXQgZmlsZUNvbnRlbnQgPSBGaWxlQ29udGV4dC5nZXRJbnN0YW5jZSgpO1xuXHRcdGxldCBkZXNpZ25lciA9IGF3YWl0IGZpbGVDb250ZW50LmdldE9yQ3JlYXRlU3lzdGVtc0Rlc2lnbnMoIHByZXZpZXcuZm9sZGVyUGF0aCApO1xuXHRcdGlmIChkZXNpZ25lcil7XG5cdFx0XHRyZXR1cm4gIGNyZWF0ZVJlc3BvbnNlKDIwMCwgZGVzaWduZXIsIGNyZWF0ZU1lc3NhZ2UoJ2dldE9yQ3JlYXRlU3lzdGVtRmFjdG9yeScsJ1N5c3RlbSBEZXNpZ25lciBMb2FkZWQnLCdnb29kJykgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDUwMCwgbnVsbCAsIGNyZWF0ZU1lc3NhZ2UoJ2dldE9yQ3JlYXRlU3lzdGVtRmFjdG9yeScsJ1NvbWV0aGluZyB3ZW50IHdyb25nIGxvYWRpbmcgdGhlIGZpbGUnLCdlcnJvcicpICk7XG5cdH1cblx0cHVibGljIGFzeW5jIHNhdmVTeXN0ZW1EZXNpZ25lciggcHJldmlldyA6IFN5c3RlbVByZXZpZXcgLCBkZXNpZ25lciA6IFRUUlBHU3lzdGVtSlNPTkZvcm1hdHRpbmcgKXtcblxuXHRcdGlmICghcHJldmlldy5mb2xkZXJQYXRoKXtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg0MDYsbnVsbCxjcmVhdGVNZXNzYWdlKCdzYXZlU3lzdGVtRmFjdG9yeTEnLCdzeXN0ZW1QcmV2aWV3IHdhcyBpbnZhbGlkJywgJ2Vycm9yJykpO1xuXHRcdH1cblxuXHRcdGlmICggIWRlc2lnbmVyLmlzVmFsaWQoKSApe1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDQwNixudWxsLGNyZWF0ZU1lc3NhZ2UoJ3NhdmVTeXN0ZW1GYWN0b3J5MScsJ3N5c3RlbSBEZXNpZ25lciB2YWxpZGF0ZWQgdG8gaW52YWxpZC4gJywgJ2Vycm9yJykpO1xuXHRcdH1cblxuXG5cdFx0bGV0IGZpbGVDb250ZW50ID0gRmlsZUNvbnRleHQuZ2V0SW5zdGFuY2UoKTtcblx0XHRpZiAoYXdhaXQgZmlsZUNvbnRlbnQuc2F2ZVN5c3RlbXNEZXNpZ25zKCBwcmV2aWV3LmZvbGRlclBhdGgsIGRlc2lnbmVyICkpe1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDIwMCwgbnVsbCAsIGNyZWF0ZU1lc3NhZ2UoJ3NhdmVTeXN0ZW1GYWN0b3J5MScsJ3NhdmVkIGRlc2lnbmVyJywnZ29vZCcpICk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSg1MDAsIG51bGwgLCBjcmVhdGVNZXNzYWdlKCdzYXZlU3lzdGVtRmFjdG9yeTEnLCdTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIHRoZSBmaWxlJywnZXJyb3InKSApO1xuXHR9XG5cdHB1YmxpYyBhc3luYyBkZWxldGVTeXN0ZW1GYWN0b3J5KCl7fVxufVxuXG5cblxuY2xhc3MgVUlJbXBvcnRlckV4cG90ZXJ7XG5cdHB1YmxpYyBhc3luYyBsb2FkQmxvY2tVSUZvckV4cG9ydCgpe1xuXG5cdFx0bGV0IG1lc3NhZ2VzIDogbWVzc2FnZUxpc3QgPSB7fTtcblx0XHR0cnl7ICBcblx0XHRcdGxldCBibG9ja1VJRmlsZXNSZXNwb25zZSA9IGF3YWl0IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCkubG9hZEJsb2NrVUlUZW1wbGF0ZSgpOztcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSgyMDAsYmxvY2tVSUZpbGVzUmVzcG9uc2UsIHt9ICk7XG5cdFx0fVxuXHRcdGNhdGNoIChlKXtcblx0XHRcdG1lc3NhZ2VzWydFcnJvciddPSh7bXNnOmUubWVzc2FnZSAsIHR5cGU6J2Vycm9yJ30pO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc3BvbnNlKDMwMCxbXSxtZXNzYWdlcyApO1xuXHRcdH0gXG5cdH1cblx0XG5cdHB1YmxpYyBhc3luYyBnZXRBbGxBdmFpbGFibGVVSXNGb3JTeXN0ZW0oIHN5cyA6IFN5c3RlbVByZXZpZXcgKXtcblx0XHRsZXQgbWVzc2FnZXMgOiBtZXNzYWdlTGlzdCA9IHt9O1xuXHRcdHRyeXtcblx0XHRcdGxldCBmaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmdldEluc3RhbmNlKCk7XG5cdFx0XHRsZXQgbGF5b3V0cyA9IGF3YWl0IGZpbGVDb250ZXh0LmdldEFsbEJsb2NrVUlBdmFpbGFibGVQcmV2aWV3KCBzeXMgKTtcblx0XHRcdHJldHVybiBjcmVhdGVSZXNwb25zZSgyMDAsbGF5b3V0cyxtZXNzYWdlcyApO1xuXHRcdH1cblx0XHRjYXRjaCAoZSl7XG5cdFx0XHRtZXNzYWdlc1snZXhjZXB0aW9uJ10gPSB7bXNnOmUubWVzc2FnZSAsIHR5cGU6J2Vycm9yJ307XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoNTAwLG51bGwsbWVzc2FnZXMgKTtcblx0XHR9IFxuXHR9IFxufVxuXG5cblxuY2xhc3MgVGVzdHtcblxuXHRwdWJsaWMgYXN5bmMgQ2FsbFRlc3RFcnJvciggZXJyb3JDb2RlID0gMzAwICApe1xuXHRcdFxuXHRcdGxldCBtZXNzYWdlcyA6IG1lc3NhZ2VMaXN0ID0ge307XG5cdFx0bWVzc2FnZXNbJ0Vycm9yMCddPSh7bXNnOidUZXN0IE1lc3NhZ2UgMScsIHR5cGU6J2Vycm9yJ30pO1xuXHRcdG1lc3NhZ2VzWydFcnJvcjEnXT0oe21zZzonVGVzdCBNZXNzYWdlIDInLCB0eXBlOid2ZXJib3NlJ30pO1xuXHRcdG1lc3NhZ2VzWydFcnJvcjInXT0oe21zZzonVGVzdCBNZXNzYWdlIDMnLCB0eXBlOidnb29kJ30pO1xuXG5cblx0XHRyZXR1cm4gY3JlYXRlUmVzcG9uc2UoZXJyb3JDb2RlLFtdLG1lc3NhZ2VzICk7XG5cdH1cbn1cblxuKi8iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgRGVzaWduZXIgZnJvbSAnLi4vdWkvVmlld3MvTGF5b3V0MDEvRGVzaWduZXIuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBJQVBJIH0gZnJvbSAnLi4vYXBpL0lBUEknO1xuICAgIGltcG9ydCB7IE9ic2lkaWFuQVBJIH0gZnJvbSAnLi4vYXBpL09ic2lkaWFuQVBJJztcbiAgICBpbXBvcnQgeyBXZWJBcGlDb25uZWN0aW9uIH0gZnJvbSAnLi4vYXBpL1dlYkFQSUNvbm5lY3Rpb24nO1xuICAgIGltcG9ydCB7IExheW91dDAxQ29udGV4dCB9IGZyb20gJy4uL3VpL1ZpZXdzL0xheW91dDAxL2NvbnRleHQnO1x0XG4gICAgaW1wb3J0IFBsdWdpbkhhbmRsZXIgZnJvbSAnLi9hcHAnO1xuXG5cdGV4cG9ydCBsZXQgcGx1Z2luSGFuZGxlciA6IFBsdWdpbkhhbmRsZXI7XG5cdGxldCBjb250ZXh0XHQ6IExheW91dDAxQ29udGV4dCA9IG5ldyBMYXlvdXQwMUNvbnRleHQoKTsgXG5cdGxldCBBUEkgOiBJQVBJID0gbmV3IE9ic2lkaWFuQVBJKHBsdWdpbkhhbmRsZXIpO1xuXHRjb250ZXh0LkFQSSA9IEFQSTtcblx0XG48L3NjcmlwdD5cbjxkaXYgaWQ9XCJTdmVsdGVDb250YWluZXJGb3JUVFBSUEdTeXN0ZW1cIiA+XG5cdDxEZXNpZ25lciBcblx0XHRjb250ZXh0ID0ge2NvbnRleHR9XG5cdC8+XG48L2Rpdj5cbjxzdHlsZT48L3N0eWxlPiIsImltcG9ydCB7IEFwcCwgSXRlbVZpZXcsIE1vZGFsLCBQbGF0Zm9ybSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBURmlsZSwgV29ya3NwYWNlTGVhZiwgcGFyc2VZYW1sIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0ICBTdmVsdGVBcHAgZnJvbSAnLi9hcHAuc3ZlbHRlJztcbmltcG9ydCB7IEJsb2NrUmVuZGVyZXIgfSBmcm9tICcuL0Jsb2NrUmVuZGVyZXIvQmxvY2tSZW5kZXJlcic7XG4gXG5cbmNvbnN0IFZJRVdfVFlQRSA9IFwic3ZlbHRlLXZpZXdcIjsgICAgXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG5cdG15U2V0dGluZzogc3RyaW5nO1xuIFxufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xuXHRteVNldHRpbmc6ICdkZWZhdWx0J1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbHVnaW5IYW5kbGVyIGV4dGVuZHMgUGx1Z2luIHsgXG5cblx0cHVibGljIHN0YXRpYyBBcHAgOiBBcHA7IFxuXHRwdWJsaWMgc3RhdGljIFJPT1RcdFx0ICBcdDogc3RyaW5nO1x0XG5cdHB1YmxpYyBzdGF0aWMgUExVR0lOX1JPT1RcdDogc3RyaW5nO1xuXHRwdWJsaWMgc3RhdGljIFNZU1RFTVNfRk9MREVSX05BTUVcdDogc3RyaW5nO1xuXHRwdWJsaWMgc3RhdGljIEJVSUxUSU5fVUlTX0ZPTERFUl9OQU1FXHQ6IHN0cmluZztcblx0cHVibGljIHN0YXRpYyBTWVNURU1fVUlfQ09OVEFJTkVSX0ZPTERFUl9OQU1FXHQ6IHN0cmluZztcblx0cHVibGljIHN0YXRpYyBTWVNURU1fVUlfTEFZT1VURklMRU5BTUVcdDogc3RyaW5nO1xuXHRwdWJsaWMgc3RhdGljIFNZU1RFTV9MQVlPVVRfQkxPQ0tOQU1FIDpzdHJpbmc7XG5cdHB1YmxpYyBzdGF0aWMgR0xPQkFMX1NZU1RFTV9QQVNTRVIgOnN0cmluZztcblxuXHRwdWJsaWMgc3RhdGljIHNlbGZcdFx0XHQ6IFBsdWdpbkhhbmRsZXI7IFxuXHRcblx0Ly9AdHMtaWdub3JlXG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzOyAgXG5cblx0cHVibGljIHN0YXRpYyB1dWlkdjQoKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnXG5cdFx0LnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRcdGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCBcblx0XHRcdFx0diA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7IFxuXHRcdFBsdWdpbkhhbmRsZXIuc2VsZiA9IHRoaXM7XG5cdFx0UGx1Z2luSGFuZGxlci5BcHAgID0gdGhpcy5hcHA7ICBcblx0XHRQbHVnaW5IYW5kbGVyLlJPT1QgPSBQbHVnaW5IYW5kbGVyLkFwcC52YXVsdC5jb25maWdEaXI7IFxuXHRcdFBsdWdpbkhhbmRsZXIuUExVR0lOX1JPT1QgPSB0aGlzLm1hbmlmZXN0LmRpciBhcyBzdHJpbmc7IFxuXHRcdFxuXHRcdC8vIEZPTERFUlMgXG5cdFx0UGx1Z2luSGFuZGxlci5TWVNURU1TX0ZPTERFUl9OQU1FIFx0XHRcdFx0PSBcIlN5c3RlbXNcIlxuXHRcdFBsdWdpbkhhbmRsZXIuQlVJTFRJTl9VSVNfRk9MREVSX05BTUUgXHRcdFx0PSBcInN1YlByb2plY3RzL0Jsb2NrVUlEZXZcIjtcblx0XHRQbHVnaW5IYW5kbGVyLlNZU1RFTV9VSV9DT05UQUlORVJfRk9MREVSX05BTUUgXHQ9ICdVSUxheW91dHMnO1xuXHRcdFBsdWdpbkhhbmRsZXIuU1lTVEVNX1VJX0xBWU9VVEZJTEVOQU1FIFx0XHRcdD0gXCJVSVByZXZpZXcuanNvblwiXG5cblx0XHQvLyBTdHJpbmdzIHVzZWQgZm9yIGdsb2JhbCB2YXJpYWJsZXMgXG5cdFx0UGx1Z2luSGFuZGxlci5HTE9CQUxfU1lTVEVNX1BBU1NFUlx0XHRcdFx0PSAnR3JvYmF4VFRSUEdHbG9iYWxWYXJpYWJsZSc7XG5cdFx0XG5cblx0XHRQbHVnaW5IYW5kbGVyLlNZU1RFTV9MQVlPVVRfQkxPQ0tOQU1FIFx0XHRcdD0gXCJUVFJQR1wiO1x0XG5cdFx0IFxuXHRcdC8vIGFkZCBSaWJib24gSWNvbnMsIHRoZXNlIGFyZSB0aGUgaWNvbnMgaW4gdGhlIGxlZnQgYmFyIG9mIHRoZSB3aW5kb3dcblx0XHR0aGlzLmFkZFJpYmJvbkljb24oJ2RpY2UnLCAnSGFuc3NcXCcgUGx1Z2luJywgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0bmV3IE1vZGFsTW91bnQodGhpcy5hcHAsIHRoaXMgKS5vcGVuKCk7IFxuXHRcdH0pO1xuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMub25MYXlvdXRSZWFkeS5iaW5kKHRoaXMpKTtcblx0XHQgXG5cdFx0Ly8gQWRkaW5mIHRoZSB0YWIgaW4gc2V0dGluZ3MuIFxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG5cdFx0dGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFBsdWdpbkhhbmRsZXIuU1lTVEVNX0xBWU9VVF9CTE9DS05BTUUsIChzb3VyY2UsIGVsLCBjdHgpID0+IHtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gbmV3IEJsb2NrUmVuZGVyZXIoc291cmNlLGVsLGN0eCk7XG5cdFx0XHQvL3JlbmRlcmVyLnJlbmRlcigpOyBcblx0XHR9KTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKGxlYWYpID0+IHtcblx0XHRcdFx0aWYgKGxlYWYpIHtcblx0XHRcdFx0XHR3aW5kb3dbUGx1Z2luSGFuZGxlci5HTE9CQUxfU1lTVEVNX1BBU1NFUl0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQpO1xuXHQgIFxuXHRcdFxuXHR9IFxuXHRvbkxheW91dFJlYWR5KCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSkubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpPy5zZXRWaWV3U3RhdGUoe1xuXHRcdFx0dHlwZTogVklFV19UWVBFLFxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cbn1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IFBsdWdpbkhhbmRsZXI7XG5cdFxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQbHVnaW5IYW5kbGVyKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9IFxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpczsgXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTsgICAgXG5cdFx0bmV3IFN2ZWx0ZUFwcCh7XG5cdFx0XHR0YXJnZXQ6dGhpcy5jb250YWluZXJFbCxcblx0XHRcdHByb3BzOntcblx0XHRcdFx0Ly9AdHMtaWdub3JlXG5cdFx0XHRcdHBsdWdpbjogdGhpcy5wbHVnaW5cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG59XG5jbGFzcyBNb2RhbE1vdW50IGV4dGVuZHMgTW9kYWwgeyAgXG5cdHBsdWdpbjogIFBsdWdpbkhhbmRsZXI7IFxuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwICwgcGx1Z2luOiBQbHVnaW5IYW5kbGVyKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjsgXG5cdH0gXG5cblx0b25PcGVuKCkge1xuXHRcdG5ldyBTdmVsdGVBcHAoe1xuXHRcdFx0dGFyZ2V0OnRoaXMuY29udGVudEVsLFxuXHRcdFx0cHJvcHM6e1xuXHRcdFx0XHQvL0B0cy1pZ25vcmVcblx0XHRcdFx0cGx1Z2luOiB0aGlzLnBsdWdpblxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHRjb25zdCB7Y29udGVudEVsfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XG5cdH1cbn0iXSwibmFtZXMiOlsidmFsdWUiLCJub3ciLCJjaGlsZHJlbiIsImVsZW1lbnQiLCJ0ZXh0IiwiaGFzaCIsImRldGFjaCIsImluaXQiLCJjcmVhdGVfZWFjaF9ibG9jayIsImluc3RhbmNlIiwiY3JlYXRlX2ZyYWdtZW50IiwiYXBwZW5kX3N0eWxlcyIsImxpbmVhciIsImQiLCJiIiwiX19hc3NpZ24iLCJ2IiwiY3R4IiwiY3JlYXRlX2lmX2Jsb2NrIiwiZGlzcGF0Y2giLCJ1cGRhdGUiLCJzdWJzY3JpYmUiLCJydW4iLCJjcmVhdGVfaWZfYmxvY2tfMSIsIktleU1hbmFnZXJfMSIsIktleU1hbmFnZXIiLCJBR3JhcGhJdGVtXzEiLCJyZXF1aXJlJCQwIiwiQUdyYXBoSXRlbSIsIkdyb2JDb2xsZWN0aW9uXzEiLCJ0c2xpYl8xIiwicmVxdWlyZSQkMSIsIl9zdXBlciIsIkdyb2JDb2xsZWN0aW9uIiwiR3JvYkdyb3VwXzEiLCJHcm9iR3JvdXAiLCJUVFJQR1N5c3RlbUdyYXBoQWJzdHJhY3RNb2RlbF8xIiwicmVxdWlyZSQkMiIsIlRUUlBHU3lzdGVtR3JhcGhBYnN0cmFjdE1vZGVsIiwiVFRSUEdTeXN0ZW1HcmFwaE1vZGVsXzEiLCJJT3V0cHV0SGFuZGxlcl8xIiwicmVxdWlyZSQkMyIsIlRUUlBHU3lzdGVtR3JhcGhNb2RlbCIsIkdyb2JBbGdvcml0aG1zIiwiYWxnTGV2ZWwiLCJzdHJvbmdDb21wb25lbnRzIiwicXVlIiwiY3VyciIsIkFHcm9iTm9kZSIsIkdyb2JPcmlnaW5fMSIsIkdyb2JPcmlnaW4iLCJHcm9iRGVyaXZlZE5vZGVfMSIsIkFHcm9iTm9kdGVfMSIsIm9yaWdpbiIsInN5bWJvbHMiLCJyZWMiLCJzdGF0ZW1lbnQiLCJyZXMiLCJHcm9iQm9udXNOb2RlXzEiLCJHcm9iQm9udXNOb2RlIiwiVFRSUEdTeXN0ZW1Cb251c0Rlc2lnbmVyXzEiLCJUVFJQR1N5c3RlbUJvbnVzRGVzaWduZXIiLCJHcm9iRml4ZWROb2RlXzEiLCJHcm9iRml4ZWROb2RlIiwiQURhdGFUYWJsZSIsIkFEYXRhUm93IiwiZXhwb3J0cyIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsIkpTT05fVEFHUyIsIkpTT05fQkFTRVRZUEVTIiwiUmVmbGVjdCIsIkpTT05IYW5kbGVyIiwiaSIsImoiLCJvYmoiLCJlIiwidHlwZWtleSIsIkdyb2JEZXJpdmVkT3JpZ2luIiwiX19kZWNvcmF0ZUNsYXNzIiwiR3JvYkRlcml2ZWROb2RlIiwiVFRSUEdTeXN0ZW0iLCJ1dWlkdjQiLCJhY3RpdmUiLCJnZXQiLCJ1cGRhdGVFdmVudHMiLCJfZCIsIl9jIiwiX2IiLCJfYSIsIl9nIiwiX2YiLCJfZSIsIl9oIiwiY3JlYXRlX2lmX2Jsb2NrXzIiLCJ0YXJnZXROb2RlIiwibmFtZUNhbGMiLCJUb29sdGlwIiwidHlwZSIsImFuaW1YIiwiYW5pbVkiLCJYb2Zmc2V0IiwiWW9mZnNldCIsIm9uRWRpdENhbmNlbFNpbmdsZSIsIm9uRWRpdEZvY3VzIiwiY3JlYXRlX2lmX2Jsb2NrXzMiLCJfaiIsIl9pIiwiX2wiLCJfayIsIl9uIiwiX20iLCJTZW1hcGhvcmUiLCJNdXRleCIsImtleU1hbmFnZXJJbnN0YW5jZSIsImZvbGRlciIsIlBsdWdpbiIsIlBsdWdpblNldHRpbmdUYWIiLCJTdmVsdGVBcHAiLCJNb2RhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBQVMsT0FBTztBQUFHO0FBQ25CLE1BQU0sV0FBVyxPQUFLO0FBQ3RCLFNBQVMsT0FBTyxLQUFLLEtBQUs7QUFFdEIsYUFBVyxLQUFLO0FBQ1osUUFBSSxLQUFLLElBQUk7QUFDakIsU0FBTztBQUNYO0FBV0EsU0FBUyxJQUFJLElBQUk7QUFDYixTQUFPLEdBQUU7QUFDYjtBQUNBLFNBQVMsZUFBZTtBQUNwQixTQUFP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
